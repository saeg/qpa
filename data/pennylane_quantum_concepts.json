[
  {
    "name": "/pennylane/pennylane.templates.embeddings.amplitude.AmplitudeEmbedding",
    "summary": "Encodes :math:`2^n` features into the amplitude vector of :math:`n` qubits.",
    "docstring": "Encodes :math:`2^n` features into the amplitude vector of :math:`n` qubits.\n\nBy setting ``pad_with`` to a real or complex number, ``features`` is automatically padded to dimension\n:math:`2^n` where :math:`n` is the number of qubits used in the embedding.\n\nTo represent a valid quantum state vector, the L2-norm of ``features`` must be one.\nThe argument ``normalize`` can be set to ``True`` to automatically normalize the features.\n\nIf both automatic padding and normalization are used, padding is executed *before* normalizing.\n\nArgs:\n    features (tensor_like): input tensor of dimension ``(2^len(wires),)``, or less if `pad_with` is specified\n    wires (Any or Iterable[Any]): wires that the template acts on\n    pad_with (float or complex): if not None, the input is padded with this constant to size :math:`2^n`\n    normalize (bool): whether to automatically normalize the features\n    id (str): custom label given to an operator instance,\n        can be useful for some applications where the instance has to be identified\n    validate_norm (bool): whether to validate the norm of the input state\n\nExample:\n\n    Amplitude embedding encodes a normalized :math:`2^n`-dimensional feature vector into the state\n    of :math:`n` qubits:\n\n    .. code-block:: python\n\n        import pennylane as qml\n\n        dev = qml.device('default.qubit', wires=2)\n\n        @qml.qnode(dev)\n        def circuit(f=None):\n            qml.AmplitudeEmbedding(features=f, wires=range(2))\n            return qml.state()\n\n        state = circuit(f=[1/2, 1/2, 1/2, 1/2])\n\n    The final state of the device is - up to a global phase - equivalent to the input passed to the circuit:\n\n    >>> state\n    array([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j])\n\n    **Differentiating with respect to the features**\n\n    Due to non-trivial classical processing to construct the state preparation circuit,\n    the features argument is in general **not differentiable**.\n\n    **Normalization**\n\n    The template will raise an error if the feature input is not normalized.\n    One can set ``normalize=True`` to automatically normalize it:\n\n    .. code-block:: python\n\n        @qml.qnode(dev)\n        def circuit(f=None):\n            qml.AmplitudeEmbedding(features=f, wires=range(2), normalize=True)\n            return qml.state()\n\n        state = circuit(f=[15, 15, 15, 15])\n\n    >>> state\n    array([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j])\n\n    **Padding**\n\n    If the dimension of the feature vector is smaller than the number of amplitudes,\n    one can automatically pad it with a constant for the missing dimensions using the ``pad_with`` option:\n\n    .. code-block:: python\n\n        from math import sqrt\n\n        @qml.qnode(dev)\n        def circuit(f=None):\n            qml.AmplitudeEmbedding(features=f, wires=range(2), pad_with=0.)\n            return qml.state()\n\n        state = circuit(f=[1/sqrt(2), 1/sqrt(2)])\n\n    >>> state # doctest: +SKIP\n    array([0.7071+0.j, 0.7071+0.j, 0.    +0.j, 0.    +0.j])"
  },
  {
    "name": "/pennylane/pennylane.templates.embeddings.angle.AngleEmbedding",
    "summary": "Encodes :math:`N` features into the rotation angles of :math:`n` qubits, where :math:`N \\leq n`.",
    "docstring": "Encodes :math:`N` features into the rotation angles of :math:`n` qubits, where :math:`N \\leq n`.\n\nThe rotations can be chosen as either :class:`~pennylane.ops.RX`, :class:`~pennylane.ops.RY`\nor :class:`~pennylane.ops.RZ` gates, as defined by the ``rotation`` parameter:\n\n* ``rotation='X'`` uses the features as angles of RX rotations\n\n* ``rotation='Y'`` uses the features as angles of RY rotations\n\n* ``rotation='Z'`` uses the features as angles of RZ rotations\n\nThe length of ``features`` has to be smaller or equal to the number of qubits. If there are fewer entries in\n``features`` than rotations, the circuit does not apply the remaining rotation gates.\n\nArgs:\n    features (tensor_like): input tensor of shape ``(N,)``, where N is the number of input features to embed,\n        with :math:`N\\leq n`\n    wires (Any or Iterable[Any]): wires that the template acts on\n    rotation (str): type of rotations used\n    id (str): custom label given to an operator instance,\n        can be useful for some applications where the instance has to be identified.\n\nExample:\n\n    Angle embedding encodes the features by using the specified rotation operation.\n\n    .. code-block:: python\n\n        dev = qml.device('default.qubit', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(feature_vector):\n            qml.AngleEmbedding(features=feature_vector, wires=range(3), rotation='Z')\n            qml.Hadamard(0)\n            return qml.probs(wires=range(3))\n\n        X = [1,2,3]\n\n    Here, we have also used rotation angles :class:`RZ`. If not specified, :class:`RX` is used as default.\n    The resulting circuit is:\n\n    >>> print(qml.draw(circuit, level=\"device\")(X))\n    0: \u2500\u2500RZ(1.00)\u2500\u2500H\u2500\u2524 \u256dProbs\n    1: \u2500\u2500RZ(2.00)\u2500\u2500\u2500\u2500\u2524 \u251cProbs\n    2: \u2500\u2500RZ(3.00)\u2500\u2500\u2500\u2500\u2524 \u2570Probs"
  },
  {
    "name": "/pennylane/pennylane.templates.embeddings.basis.BasisEmbedding",
    "summary": "Encodes :math:`n` binary features into a basis state of :math:`n` qubits.",
    "docstring": "Encodes :math:`n` binary features into a basis state of :math:`n` qubits.\n\nFor example, for ``features=np.array([0, 1, 0])`` or ``features=2`` (binary 010), the\nquantum system will be prepared in state :math:`|010 \\rangle`.\n\n.. warning::\n\n    ``BasisEmbedding`` calls a circuit whose architecture depends on the binary features.\n    The ``features`` argument is therefore not differentiable when using the template, and\n    gradients with respect to the argument cannot be computed by PennyLane.\n\nArgs:\n    features (tensor_like or int): Binary input of shape ``(len(wires), )`` or integer\n        that represents the binary input.\n    wires (Any or Iterable[Any]): the wire(s) that the template acts on\n\nExample:\n\n    Basis embedding encodes the binary feature vector into a basis state.\n\n    .. code-block:: python\n\n        dev = qml.device('reference.qubit', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(feature_vector):\n            qml.BasisEmbedding(features=feature_vector, wires=range(3))\n            return qml.state()\n\n        X = [1,1,1]\n\n    The resulting circuit is:\n\n    >>> print(qml.draw(circuit, level=\"device\")(X))\n    0: \u2500\u2500X\u2500\u2524 \u256dState\n    1: \u2500\u2500X\u2500\u2524 \u251cState\n    2: \u2500\u2500X\u2500\u2524 \u2570State\n\n    And, the output state is:\n\n    >>> print(circuit(X))\n        [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j]\n\n    Thus, ``[1,1,1]`` is mapped to :math:`|111 \\rangle`."
  },
  {
    "name": "/pennylane/pennylane.templates.embeddings.displacement.DisplacementEmbedding",
    "summary": "Encodes :math:`N` features into the displacement amplitudes :math:`r` or phases :math:`\\phi` of :math:`M` modes, where :math:`N\\leq M`.",
    "docstring": "Encodes :math:`N` features into the displacement amplitudes :math:`r` or phases :math:`\\phi` of :math:`M` modes,\nwhere :math:`N\\leq M`.\n\nThe mathematical definition of the displacement gate is given by the operator\n\n.. math::\n        D(\\alpha) = \\exp(r (e^{i\\phi}\\ad -e^{-i\\phi}\\a)),\n\nwhere :math:`\\a` and :math:`\\ad` are the bosonic creation and annihilation operators.\n\n``features`` has to be an array of at most ``len(wires)`` floats. If there are fewer entries in\n``features`` than wires, the circuit does not apply the remaining displacement gates.\n\nArgs:\n    features (tensor_like): tensor of features\n    wires (Any or Iterable[Any]): wires that the template acts on\n    method (str): ``'phase'`` encodes the input into the phase of single-mode displacement, while\n        ``'amplitude'`` uses the amplitude\n    c (float): value of the phase of all displacement gates if ``execution='amplitude'``, or\n        the amplitude of all displacement gates if ``execution='phase'``\n\nRaises:\n    ValueError: if inputs do not have the correct format\n\nExample:\n\n    Depending on the ``method`` argument, the feature vector will be encoded in the phase or the amplitude.\n    The argument ``c`` will define the value of the other quantity.\n    The default values are :math:`0.1` for ``c`` and ``'amplitude'`` for ``method``.\n\n    .. code-block:: python\n\n        dev = qml.device('default.gaussian', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(feature_vector):\n            qml.DisplacementEmbedding(features=feature_vector, wires=range(3))\n            qml.QuadraticPhase(0.1, wires=1)\n            return qml.expval(qml.NumberOperator(wires=1))\n\n        X = [1, 2, 3]\n\n    >>> print(circuit(X))\n        4.1215690638748494\n\n    And, the resulting circuit is:\n\n    >>> print(qml.draw(circuit, show_matrices=False)(X))\n    0: \u2500\u256dDisplacementEmbedding(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    1: \u2500\u251cDisplacementEmbedding(M0)\u2500\u2500P(0.10)\u2500\u2524  <n>\n    2: \u2500\u2570DisplacementEmbedding(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n    Using different parameters:\n\n    .. code-block:: python\n\n        dev = qml.device('default.gaussian', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(feature_vector):\n            qml.DisplacementEmbedding(features=feature_vector, wires=range(3), method='phase', c=0.5)\n            qml.QuadraticPhase(0.1, wires=1)\n            return qml.expval(qml.NumberOperator(wires=1))\n\n        X = [1, 2, 3]\n\n    >>> print(circuit(X))\n        0.23401288309122226\n\n    And, the resulting circuit is:\n\n    >>> print(qml.draw(circuit, show_matrices=False)(X))\n    0: \u2500\u256dDisplacementEmbedding(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    1: \u2500\u251cDisplacementEmbedding(M0)\u2500\u2500P(0.10)\u2500\u2524  <n>\n    2: \u2500\u2570DisplacementEmbedding(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524"
  },
  {
    "name": "/pennylane/pennylane.templates.embeddings.iqp.IQPEmbedding",
    "summary": "Encodes :math:`n` features into :math:`n` qubits using diagonal gates of an IQP circuit.",
    "docstring": "Encodes :math:`n` features into :math:`n` qubits using diagonal gates of an IQP circuit.\n\nThe embedding has been proposed by `Havlicek et al. (2018) <https://arxiv.org/abs/1804.11326>`_.\n\nThe basic IQP circuit can be repeated by specifying ``n_repeats``. Repetitions can make the\nembedding \"richer\" through interference.\n\n.. warning::\n\n    ``IQPEmbedding`` calls a circuit that involves non-trivial classical processing of the\n    features. The ``features`` argument is therefore **not differentiable** when using the template, and\n    gradients with respect to the features cannot be computed by PennyLane.\n\nAn IQP circuit is a quantum circuit of a block of Hadamards, followed by a block of gates that are\ndiagonal in the computational basis. Here, the diagonal gates are single-qubit ``RZ`` rotations, applied to each\nqubit and encoding the :math:`n` features, followed by two-qubit ZZ entanglers,\n:math:`e^{-i x_i x_j \\sigma_z \\otimes \\sigma_z}`. The entangler applied to wires ``(wires[i], wires[j])``\nencodes the product of features ``features[i]*features[j]``. The pattern in which the entanglers are\napplied is either the default, or a custom pattern:\n\n* If ``pattern`` is not specified, the default pattern will be used, in which the entangling gates connect all\n  pairs of neighbours:\n\n  |\n\n  .. figure:: ../../_static/templates/embeddings/iqp.png\n      :align: center\n      :width: 50%\n      :target: javascript:void(0);\n\n  |\n\n* Else, ``pattern`` is a list of wire pairs ``[[a, b], [c, d],...]``, applying the entangler\n  on wires ``[a, b]``, ``[c, d]``, etc. For example, ``pattern = [[0, 1], [1, 2]]`` produces\n  the following entangler pattern:\n\n  |\n\n  .. figure:: ../../_static/templates/embeddings/iqp_custom.png\n      :align: center\n      :width: 50%\n      :target: javascript:void(0);\n\n  |\n\n  Since diagonal gates commute, the order of the entanglers does not change the result.\n\nArgs:\n    features (tensor_like): tensor of features to encode\n    wires (Any or Iterable[Any]): wires that the template acts on\n    n_repeats (int): number of times the basic embedding is repeated\n    pattern (list[int]): specifies the wires and features of the entanglers\n\nRaises:\n    ValueError: if inputs do not have the correct format\n\n.. details::\n    :title: Usage Details\n\n    A typical usage example of the template is the following:\n\n    .. code-block:: python\n\n        import pennylane as qml\n\n        dev = qml.device('default.qubit', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(features):\n            qml.IQPEmbedding(features, wires=range(3))\n            return [qml.expval(qml.Z(w)) for w in range(3)]\n\n        circuit([1., 2., 3.])\n\n    **Repeating the embedding**\n\n    The embedding can be repeated by specifying the ``n_repeats`` argument:\n\n    .. code-block:: python\n\n        @qml.qnode(dev)\n        def circuit(features):\n            qml.IQPEmbedding(features, wires=range(3), n_repeats=4)\n            return [qml.expval(qml.Z(w)) for w in range(3)]\n\n        circuit([1., 2., 3.])\n\n    Every repetition uses exactly the same quantum circuit.\n\n    **Using a custom entangler pattern**\n\n    A custom entangler pattern can be used by specifying the ``pattern`` argument. A pattern has to be\n    a nested list of dimension ``(K, 2)``, where ``K`` is the number of entanglers to apply.\n\n    .. code-block:: python\n\n        pattern = [[1, 2], [0, 2], [1, 0]]\n\n        @qml.qnode(dev)\n        def circuit(features):\n            qml.IQPEmbedding(features, wires=range(3), pattern=pattern)\n            return [qml.expval(qml.Z(w)) for w in range(3)]\n\n        circuit([1., 2., 3.])\n\n    Since diagonal gates commute, the order of the wire pairs has no effect on the result.\n\n    .. code-block:: python\n\n        from pennylane import numpy as np\n\n        pattern1 = [[1, 2], [0, 2], [1, 0]]\n        pattern2 = [[1, 0], [0, 2], [1, 2]]  # a reshuffling of pattern1\n\n        @qml.qnode(dev)\n        def circuit(features, pattern):\n            qml.IQPEmbedding(features, wires=range(3), pattern=pattern, n_repeats=3)\n            return [qml.expval(qml.Z(w)) for w in range(3)]\n\n        res1 = circuit([1., 2., 3.], pattern=pattern1)\n        res2 = circuit([1., 2., 3.], pattern=pattern2)\n\n        assert np.allclose(res1, res2)\n\n    **Non-consecutive wires**\n\n    In principle, the user can also pass a non-consecutive wire list to the template.\n    For single qubit gates, the i'th feature is applied to the i'th wire index (which may not be the i'th wire).\n    For the entanglers, the product of i'th and j'th features is applied to the wire indices at the i'th and j'th\n    position in ``wires``.\n\n    For example, for ``wires=[2, 0, 1]`` the ``RZ`` block applies the first feature to wire 2,\n    the second feature to wire 0, and the third feature to wire 1.\n\n    Likewise, using the default pattern, the entangler block applies the product of the first and second\n    feature to the wire pair ``[2, 0]``, the product of the second and third feature to ``[2, 1]``, and so\n    forth."
  },
  {
    "name": "/pennylane/pennylane.templates.embeddings.qaoaembedding.QAOAEmbedding",
    "summary": "Encodes :math:`N` features into :math:`n>N` qubits, using a layered, trainable quantum circuit that is inspired by the QAOA ansatz proposed by `Killoran et al. (2020) <https://arxiv.org/abs/2001.03622>`_.",
    "docstring": "Encodes :math:`N` features into :math:`n>N` qubits, using a layered, trainable quantum\ncircuit that is inspired by the QAOA ansatz proposed by `Killoran et al. (2020) <https://arxiv.org/abs/2001.03622>`_.\n\nA single layer applies two circuits or \"Hamiltonians\": The first encodes the features, and the second is\na variational ansatz inspired by a 1-dimensional Ising model. The feature-encoding circuit associates features with\nthe angles of :class:`RX` rotations. The Ising ansatz consists of trainable two-qubit ZZ interactions\n:math:`e^{-i \\frac{\\alpha}{2} \\sigma_z \\otimes \\sigma_z}` (in PennyLane represented by the :class:`~.MultiRZ` gate),\nand trainable local fields :math:`e^{-i \\frac{\\beta}{2} \\sigma_{\\mu}}`, where :math:`\\sigma_{\\mu}`\ncan be chosen to be :math:`\\sigma_{x}`, :math:`\\sigma_{y}` or :math:`\\sigma_{z}`\n(default choice is :math:`\\sigma_{y}` or the ``RY`` gate), and :math:`\\alpha, \\beta` are adjustable gate parameters.\n\nThe number of features has to be smaller or equal to the number of qubits. If there are fewer features than\nqubits, the feature-encoding rotation is replaced by a Hadamard gate.\n\nThe argument ``weights`` contains an array of the :math:`\\alpha, \\beta` parameters for each layer.\nThe number of layers :math:`L` is derived from the first dimension of ``weights``, which has the following\nshape:\n\n* :math:`(L, 1)`, if the embedding acts on a single wire,\n* :math:`(L, 3)`, if the embedding acts on two wires,\n* :math:`(L, 2n)` else.\n\nAfter the :math:`L` th layer, another set of feature-encoding :class:`RX` gates is applied.\n\nThis is an example for the full embedding circuit using 2 layers, 3 features, 4 wires, and ``RY`` local fields:\n\n|\n\n.. figure:: ../../_static/qaoa_layers.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\n|\n\n.. note::\n    ``QAOAEmbedding`` supports gradient computations with respect to both the ``features`` and the ``weights``\n    arguments. Note that trainable parameters need to be passed to the quantum node as positional arguments.\n\nArgs:\n    features (tensor_like): tensor of features to encode\n    weights (tensor_like): tensor of weights\n    wires (Iterable): wires that the template acts on\n    local_field (str, type): type of local field used, either one of ``'X'``, ``'Y'``, or ``'Z'`` or\n        :class:`~.RX`, :class:`~.RY`, or :class:`~.RZ`.\n\nRaises:\n    ValueError: if inputs do not have the correct format\n\n.. details::\n    :title: Usage Details\n\n    The QAOA embedding encodes an :math:`n`-dimensional feature vector into at most :math:`n` qubits. The\n    embedding applies layers of a circuit, and each layer is defined by a set of weight parameters.\n\n    .. code-block:: python\n\n        import pennylane as qml\n\n        dev = qml.device('default.qubit', wires=2)\n\n        @qml.qnode(dev)\n        def circuit(weights, f=None):\n            qml.QAOAEmbedding(features=f, weights=weights, wires=range(2))\n            return qml.expval(qml.Z(0))\n\n        features = [1., 2.]\n        layer1 = [0.1, -0.3, 1.5]\n        layer2 = [3.1, 0.2, -2.8]\n        weights = [layer1, layer2]\n\n        print(circuit(weights, f=features))\n\n    **Parameter shape**\n\n    The shape of the weights argument can be computed by the static method\n    :meth:`~.QAOAEmbedding.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shape = qml.QAOAEmbedding.shape(n_layers=2, n_wires=2)\n        weights = np.random.random(shape)\n\n    **Training the embedding**\n\n    The embedding is typically trained with respect to a given cost. For example, one can train it to\n    minimize the PauliZ expectation of the first qubit:\n\n    .. code-block:: python\n\n        opt = qml.GradientDescentOptimizer()\n        for i in range(10):\n            weights = opt.step(lambda w : circuit(w, f=features), weights)\n            print(\"Step \", i, \" weights = \", weights)\n\n\n    **Training the features**\n\n    In principle, also the features are trainable, which means that gradients with respect to feature values\n    can be computed. To train both weights and features, they need to be passed to the qnode as\n    positional arguments. If the built-in optimizer is used, they have to be merged to one input:\n\n    .. code-block:: python\n\n        @qml.qnode(dev)\n        def circuit2(weights, features):\n            qml.QAOAEmbedding(features=features, weights=weights, wires=range(2))\n            return qml.expval(qml.Z(0))\n\n\n        features = [1., 2.]\n        weights = [[0.1, -0.3, 1.5], [3.1, 0.2, -2.8]]\n\n        opt = qml.GradientDescentOptimizer()\n        for i in range(10):\n            weights, features = opt.step(circuit2, weights, features)\n            print(\"Step \", i, \"\\n weights = \", weights, \"\\n features = \", features,\"\\n\")\n\n    **Local Fields**\n\n    While by default, ``RY`` gates are used as local fields, one may also choose ``local_field='Z'`` or\n    ``local_field='X'`` as hyperparameters of the embedding.\n\n    .. code-block:: python\n\n        @qml.qnode(dev)\n        def circuit(weights, f=None):\n            qml.QAOAEmbedding(features=f, weights=weights, wires=range(2), local_field='Z')\n            return qml.expval(qml.Z(0))\n\n    Choosing ``'Z'`` fields implements a QAOAEmbedding where the second Hamiltonian is a\n    1-dimensional Ising model."
  },
  {
    "name": "/pennylane/pennylane.templates.embeddings.squeezing.SqueezingEmbedding",
    "summary": "Encodes :math:`N` features into the squeezing amplitudes :math:`r \\geq 0` or phases :math:`\\phi \\in [0, 2\\pi)` of :math:`M` modes, where :math:`N\\leq M`.",
    "docstring": "Encodes :math:`N` features into the squeezing amplitudes :math:`r \\geq 0` or phases :math:`\\phi \\in [0, 2\\pi)`\nof :math:`M` modes, where :math:`N\\leq M`.\n\nThe mathematical definition of the squeezing gate is given by the operator\n\n.. math::\n\n    S(z) = \\exp\\left(\\frac{r}{2}\\left(e^{-i\\phi}\\a^2 -e^{i\\phi}{\\ad}^{2} \\right) \\right),\n\nwhere :math:`\\a` and :math:`\\ad` are the bosonic creation and annihilation operators.\n\n``features`` has to be an iterable of at most ``len(wires)`` floats. If there are fewer entries in\n``features`` than wires, the circuit does not apply the remaining squeezing gates.\n\nArgs:\n    features (tensor_like): tensor of features\n    wires (Any or Iterable[Any]): wires that the template acts on\n    method (str): ``'phase'`` encodes the input into the phase of single-mode squeezing, while\n        ``'amplitude'`` uses the amplitude\n    c (float): value of the phase of all squeezing gates if ``execution='amplitude'``, or the\n        amplitude of all squeezing gates if ``execution='phase'``\n\nRaises:\n    ValueError: if inputs do not have the correct format\n\nExample:\n\n    Depending on the ``method`` argument, the feature vector will be encoded in the phase or the amplitude.\n    The argument ``c`` will define the value of the other quantity.\n    The default values are :math:`0.1` for ``c`` and ``'amplitude'`` for ``method``.\n\n    .. code-block:: python\n\n        dev = qml.device('default.gaussian', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(feature_vector):\n            qml.SqueezingEmbedding(features=feature_vector, wires=range(3))\n            qml.QuadraticPhase(0.1, wires=1)\n            return qml.expval(qml.NumberOperator(wires=1))\n\n        X = [1, 2, 3]\n\n    >>> print(circuit(X))\n        13.018280763205285\n\n    And, the resulting circuit is:\n\n    >>> print(qml.draw(circuit, show_matrices=False)(X))\n    0: \u2500\u256dSqueezingEmbedding(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    1: \u2500\u251cSqueezingEmbedding(M0)\u2500\u2500P(0.10)\u2500\u2524  <n>\n    2: \u2500\u2570SqueezingEmbedding(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n    Using different parameters:\n\n    .. code-block:: python\n\n        dev = qml.device('default.gaussian', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(feature_vector):\n            qml.SqueezingEmbedding(features=feature_vector, wires=range(3), method='phase', c=0.5)\n            qml.QuadraticPhase(0.1, wires=1)\n            return qml.expval(qml.NumberOperator(wires=1))\n\n        X = [1, 2, 3]\n\n    >>> print(circuit(X))\n        0.22319028857312428\n\n    And, the resulting circuit is:\n\n    >>> print(qml.draw(circuit, show_matrices=False)(X))\n    0: \u2500\u256dSqueezingEmbedding(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    1: \u2500\u251cSqueezingEmbedding(M0)\u2500\u2500P(0.10)\u2500\u2524  <n>\n    2: \u2500\u2570SqueezingEmbedding(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524"
  },
  {
    "name": "/pennylane/pennylane.templates.layers.basic_entangler.BasicEntanglerLayers",
    "summary": "Layers consisting of one-parameter single-qubit rotations on each qubit, followed by a closed chain or *ring* of CNOT gates.",
    "docstring": "Layers consisting of one-parameter single-qubit rotations on each qubit, followed by a closed chain\nor *ring* of CNOT gates.\n\nThe ring of CNOT gates connects every qubit with its neighbour,\nwith the last qubit being considered as a neighbour to the first qubit.\n\n.. figure:: ../../_static/templates/layers/basic_entangler.png\n    :align: center\n    :width: 40%\n    :target: javascript:void(0);\n\nThe number of layers :math:`L` is determined by the first dimension of the argument ``weights``.\nWhen using a single wire, the template only applies the single\nqubit gates in each layer.\n\n.. note::\n\n    This template follows the convention of dropping the entanglement between the last and the first\n    qubit when using only two wires, so the entangler is not repeated on the same wires.\n    In this case, only one CNOT gate is applied in each layer:\n\n    .. figure:: ../../_static/templates/layers/basic_entangler_2wires.png\n        :align: center\n        :width: 30%\n        :target: javascript:void(0);\n\nArgs:\n    weights (tensor_like): Weight tensor of shape ``(L, len(wires))``. Each weight is used as a parameter\n        for the rotation.\n    wires (Iterable): wires that the template acts on\n    rotation (pennylane.ops.Operation): one-parameter single-qubit gate to use,\n        if ``None``, :class:`~pennylane.ops.RX` is used as default\n\nRaises:\n    ValueError: if inputs do not have the correct format\n\n.. details::\n    :title: Usage Details\n\n    The template is used inside a qnode:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        from math import pi\n\n        n_wires = 3\n        dev = qml.device('default.qubit', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(weights):\n            qml.BasicEntanglerLayers(weights=weights, wires=range(n_wires))\n            return [qml.expval(qml.Z(i)) for i in range(n_wires)]\n\n    >>> circuit([[pi, pi, pi]])\n    [np.float64(1.0), np.float64(1.0), np.float64(-1.0)]\n\n    **Parameter shape**\n\n    The shape of the weights argument can be computed by the static method\n    :meth:`~.BasicEntanglerLayers.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shape = qml.BasicEntanglerLayers.shape(n_layers=2, n_wires=2)\n        weights = np.random.random(size=shape)\n\n    **No periodic boundary for two wires**\n\n    When using two wires, the convention is to drop the periodic boundary condition.\n    This means that the connection from the second to the first wire is omitted.\n\n    .. code-block:: python\n\n        n_wires = 2\n        dev = qml.device('default.qubit', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(weights):\n            qml.BasicEntanglerLayers(weights=weights, wires=range(n_wires))\n            return [qml.expval(qml.Z(i)) for i in range(n_wires)]\n\n    >>> circuit([[pi, pi]])\n    [np.float64(-1.0), np.float64(1.0)]\n\n\n    **Changing the rotation gate**\n\n    Any single-qubit gate can be used as a rotation gate, as long as it only takes a single parameter. The default is the ``RX`` gate.\n\n    .. code-block:: python\n\n        @qml.qnode(dev)\n        def circuit(weights):\n            qml.BasicEntanglerLayers(weights=weights, wires=range(n_wires), rotation=qml.RZ)\n            return [qml.expval(qml.Z(i)) for i in range(n_wires)]\n\n    Accidentally using a gate that expects more parameters throws a\n    ``ValueError: Wrong number of parameters``."
  },
  {
    "name": "/pennylane/pennylane.templates.layers.cv_neural_net.CVNeuralNetLayers",
    "summary": "A sequence of layers of a continuous-variable quantum neural network, as specified in `Killoran et al. (2019) <https://doi.org/10.1103/PhysRevResearch.1.033063>`_.",
    "docstring": "A sequence of layers of a continuous-variable quantum neural network,\nas specified in `Killoran et al. (2019) <https://doi.org/10.1103/PhysRevResearch.1.033063>`_.\n\nThe layer consists\nof interferometers, displacement and squeezing gates mimicking the linear transformation of\na neural network in the x-basis of the quantum system, and uses a Kerr gate\nto introduce a 'quantum' non-linearity.\n\nThe layers act on the :math:`M` modes given in ``wires``,\nand include interferometers of :math:`K=M(M-1)/2` beamsplitters. The different weight parameters\ncontain the weights for each layer. The number of layers :math:`L` is therefore derived\nfrom the first dimension of ``weights``.\n\nThis example shows a 4-mode CVNeuralNet layer with squeezing gates :math:`S`, displacement gates :math:`D` and\nKerr gates :math:`K`. The two big blocks are interferometers of type\n:mod:`pennylane.Interferometer`:\n\n.. figure:: ../../_static/layer_cvqnn.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\n.. note::\n   The CV neural network architecture includes :class:`~pennylane.ops.Kerr` operations.\n   Make sure to use a suitable device, such as the :code:`strawberryfields.fock`\n   device of the `PennyLane-SF <https://github.com/XanaduAI/pennylane-sf>`_ plugin.\n\nArgs:\n    theta_1 (tensor_like): shape :math:`(L, K)` tensor of transmittivity angles for first interferometer\n    phi_1 (tensor_like): shape :math:`(L, K)` tensor of phase angles for first interferometer\n    varphi_1 (tensor_like): shape :math:`(L, M)` tensor of rotation angles to apply after first interferometer\n    r (tensor_like): shape :math:`(L, M)` tensor of squeezing amounts for :class:`~pennylane.ops.Squeezing` operations\n    phi_r (tensor_like): shape :math:`(L, M)` tensor of squeezing angles for :class:`~pennylane.ops.Squeezing` operations\n    theta_2 (tensor_like): shape :math:`(L, K)` tensor of transmittivity angles for second interferometer\n    phi_2 (tensor_like): shape :math:`(L, K)` tensor of phase angles for second interferometer\n    varphi_2 (tensor_like): shape :math:`(L, M)` tensor of rotation angles to apply after second interferometer\n    a (tensor_like): shape :math:`(L, M)` tensor of displacement magnitudes for :class:`~pennylane.ops.Displacement` operations\n    phi_a (tensor_like): shape :math:`(L, M)` tensor of displacement angles for :class:`~pennylane.ops.Displacement` operations\n    k (tensor_like): shape :math:`(L, M)` tensor of kerr parameters for :class:`~pennylane.ops.Kerr` operations\n    wires (Iterable): wires that the template acts on\n\n.. details::\n    :title: Usage Details\n\n    **Parameter shapes**\n\n    A list of shapes for the 11 input parameter tensors can be computed by the static method\n    :meth:`~.CVNeuralNetLayers.shape` and used when creating randomly\n    initialised weights:\n\n    .. code-block:: python\n\n        shapes = CVNeuralNetLayers.shape(n_layers=2, n_wires=2)\n        weights = [np.random.random(shape) for shape in shapes]\n\n        def circuit():\n          CVNeuralNetLayers(*weights, wires=[0, 1])\n          return qml.expval(qml.QuadX(0))"
  },
  {
    "name": "/pennylane/pennylane.templates.layers.gate_fabric.GateFabric",
    "summary": "Implements a local, expressive, and quantum-number-preserving ansatz proposed by `Anselmetti et al. (2021) <https://doi.org/10.1088/1367-2630/ac2cb3>`_.",
    "docstring": "Implements a local, expressive, and quantum-number-preserving ansatz proposed by\n`Anselmetti et al. (2021) <https://doi.org/10.1088/1367-2630/ac2cb3>`_.\n\nThis template prepares the :math:`N`-qubit trial state by applying :math:`D` layers of gate-fabric blocks\n:math:`\\hat{U}_{GF}(\\vec{\\theta},\\vec{\\phi})` to the Hartree-Fock state in the Jordan-Wigner basis\n\n.. math::\n\n    \\vert \\Psi(\\vec{\\theta},\\vec{\\phi})\\rangle =\n    \\hat{U}_{GF}^{(D)}(\\vec{\\theta}_{D},\\vec{\\phi}_{D}) \\ldots\n    \\hat{U}_{GF}^{(2)}(\\vec{\\theta}_{2},\\vec{\\phi}_{2})\n    \\hat{U}_{GF}^{(1)}(\\vec{\\theta}_{1},\\vec{\\phi}_{1}) \\vert HF \\rangle,\n\nwhere each of the gate fabric blocks :math:`\\hat{U}_{GF}(\\vec{\\theta},\\vec{\\phi})` is comprised of two-parameter four-qubit\ngates :math:`\\hat{Q}(\\theta, \\phi)` that act on four nearest-neighbour qubits. The circuit implementing a\nsingle layer of the gate fabric block for :math:`N = 8` is shown in the figure below:\n\n.. figure:: ../../_static/templates/layers/gate_fabric_layer.png\n    :align: center\n    :width: 100%\n    :target: javascript:void(0);\n\nThe gate element :math:`\\hat{Q}(\\theta, \\phi)` (`Anselmetti et al. (2021) <https://doi.org/10.1088/1367-2630/ac2cb3>`_)\nis composed of a four-qubit spin-adapted spatial orbital rotation gate, which is implemented by the :class:`~.OrbitalRotation()`\noperation and a four-qubit diagonal pair-exchange gate, which is equivalent to the :class:`~.DoubleExcitation()`\noperation. In addition to these two gates, the gate element :math:`\\hat{Q}(\\theta, \\phi)` can also include an optional\nconstant :math:`\\hat{\\Pi} \\in \\{\\hat{I}, \\text{OrbitalRotation}(\\pi)\\}` gate.\n\n.. figure:: ../../_static/templates/layers/q_gate_decompositon.png\n    :align: center\n    :width: 75%\n    :target: javascript:void(0);\n\n|\n\nThe four-qubit :class:`~.DoubleExcitation()` and :class:`~.OrbitalRotation()` gates given here are equivalent to the\n:math:`\\text{QNP}_{PX}(\\theta)` and :math:`\\text{QNP}_{OR}(\\phi)` gates presented in\n`Anselmetti et al. (2021) <https://doi.org/10.1088/1367-2630/ac2cb3>`_,\nrespectively. Moreover, regardless of the choice of :math:`\\hat{\\Pi}`, this gate fabric will exactly preserve the number of particles\nand total spin of the state.\n\nArgs:\n    weights (tensor_like): Array of weights of shape ``(D, L, 2)``\\,\n        where ``D`` is the number of gate fabric layers and ``L = N/2-1``\n        is the number of :math:`\\hat{Q}(\\theta, \\phi)` gates per layer with N being the total number of qubits.\n    wires (Iterable): wires that the template acts on.\n    init_state (tensor_like): iterable of shape ``(len(wires),)``\\, representing the input Hartree-Fock state\n        in the Jordan-Wigner representation.\n    include_pi (boolean): If True, the optional constant :math:`\\hat{\\Pi}` gate  is set to :math:`\\text{OrbitalRotation}(\\pi)`.\n        Default value is :math:`\\hat{I}`.\n\n.. details::\n    :title: Usage Details\n\n    #. The number of wires :math:`N` has to be equal to the number of\n       spin-orbitals included in the active space, and should be even.\n\n    #. The number of trainable parameters scales linearly with the number of layers as\n       :math:`2 D (N/2-1)`.\n\n    An example of how to use this template is shown below:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        from pennylane import numpy as np\n\n        # Build the electronic Hamiltonian\n        symbols = [\"H\", \"H\"]\n        coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])\n        H, qubits = qml.qchem.molecular_hamiltonian(symbols, coordinates)\n\n        # Define the Hartree-Fock state\n        electrons = 2\n        ref_state = qml.qchem.hf_state(electrons, qubits)\n\n        # Define the device\n        dev = qml.device('default.qubit', wires=qubits)\n\n        # Define the ansatz\n        @qml.qnode(dev)\n        def ansatz(weights):\n            qml.GateFabric(weights, wires=[0,1,2,3],\n                        init_state=ref_state, include_pi=True)\n            return qml.expval(H)\n\n        # Get the shape of the weights for this template\n        layers = 2\n        shape = qml.GateFabric.shape(n_layers=layers, n_wires=qubits)\n\n        # Initialize the weight tensors\n        np.random.seed(42)\n        weights = np.random.random(size=shape)\n\n        # Define the optimizer\n        opt = qml.GradientDescentOptimizer(stepsize=0.4)\n\n        # Store the values of the cost function\n        energy = [ansatz(weights)]\n\n        # Store the values of the circuit weights\n        angle = [weights]\n\n        max_iterations = 100\n        conv_tol = 1e-06\n\n        for n in range(max_iterations):\n            weights, prev_energy = opt.step_and_cost(ansatz, weights)\n            energy.append(ansatz(weights))\n            angle.append(weights)\n            conv = np.abs(energy[-1] - prev_energy)\n\n            if n % 2 == 0:\n                print(f\"Step = {n},  Energy = {energy[-1]:.8f} Ha\")\n\n            if conv <= conv_tol:\n                break\n\n        print(\"\\n\" f\"Final value of the ground-state energy = {energy[-1]:.8f} Ha\")\n        print(\"\\n\" f\"Optimal value of the circuit parameters = {angle[-1]}\")\n\n    .. code-block:: none\n\n        Step = 0,  Energy = -0.87007254 Ha\n        Step = 2,  Energy = -1.13107530 Ha\n        Step = 4,  Energy = -1.13611971 Ha\n        Step = 6,  Energy = -1.13618810 Ha\n\n        Final value of the ground-state energy = -1.13618903 Ha\n\n        Optimal value of the circuit parameters = [[[ 0.60328427  0.41850407]]\n        [[ 0.85581129 -0.24522642]]]\n\n\n    **Parameter shape**\n\n    The shape of the weights argument can be computed by the static method\n    :meth:`~.GateFabric.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shape = GateFabric.shape(n_layers=2, n_wires=4)\n        weights = np.random.random(size=shape)\n\n    >>> weights.shape\n    (2, 1, 2)"
  },
  {
    "name": "/pennylane/pennylane.templates.layers.particle_conserving_u1.ParticleConservingU1",
    "summary": "Implements the heuristic VQE ansatz for quantum chemistry simulations using the particle-conserving gate :math:`U_{1,\\mathrm{ex}}` proposed by Barkoutsos *et al.* in `arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_.",
    "docstring": "Implements the heuristic VQE ansatz for quantum chemistry simulations using the\nparticle-conserving gate :math:`U_{1,\\mathrm{ex}}` proposed by Barkoutsos *et al.* in\n`arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_.\n\nThis template prepares :math:`N`-qubit trial states by applying :math:`D` layers of the\nentangler block :math:`U_\\mathrm{ent}(\\vec{\\phi}, \\vec{\\theta})` to the Hartree-Fock\nstate\n\n.. math::\n\n    \\vert \\Psi(\\vec{\\phi}, \\vec{\\theta}) \\rangle = \\hat{U}^{(D)}_\\mathrm{ent}(\\vec{\\phi}_D,\n    \\vec{\\theta}_D) \\dots \\hat{U}^{(2)}_\\mathrm{ent}(\\vec{\\phi}_2, \\vec{\\theta}_2)\n    \\hat{U}^{(1)}_\\mathrm{ent}(\\vec{\\phi}_1, \\vec{\\theta}_1) \\vert \\mathrm{HF}\\rangle.\n\nThe circuit implementing the entangler blocks is shown in the figure below:\n\n|\n\n.. figure:: ../../_static/templates/layers/particle_conserving_u1.png\n    :align: center\n    :width: 50%\n    :target: javascript:void(0);\n\n|\n\nThe repeated units across several qubits are shown in dotted boxes. Each layer\ncontains :math:`N-1` particle-conserving two-parameter exchange gates\n:math:`U_{1,\\mathrm{ex}}(\\phi, \\theta)` that act on pairs of nearest neighbors qubits.\nThe unitary matrix representing :math:`U_{1,\\mathrm{ex}}(\\phi, \\theta)`\nis given by (see `arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_),\n\n.. math::\n\n    U_{1, \\mathrm{ex}}(\\phi, \\theta) = \\left(\\begin{array}{cccc}\n    1 & 0 & 0 & 0 \\\\\n    0 & \\mathrm{cos}(\\theta) & e^{i\\phi} \\mathrm{sin}(\\theta) & 0 \\\\\n    0 & e^{-i\\phi} \\mathrm{sin}(\\theta) & -\\mathrm{cos}(\\theta) & 0 \\\\\n    0 & 0 & 0 & 1 \\\\\n    \\end{array}\\right).\n\nThe figure below shows the circuit decomposing :math:`U_{1, \\mathrm{ex}}` in\nelementary gates. The Pauli matrix :math:`\\sigma_z` and single-qubit rotation\n:math:`R(0, 2 \\theta, 0)` apply the Pauli Z operator and an arbitrary rotation\non the qubit ``n`` with qubit ``m`` bein the control qubit,\n\n|\n\n.. figure:: ../../_static/templates/layers/u1_decomposition.png\n    :align: center\n    :width: 80%\n    :target: javascript:void(0);\n\n|\n\n:math:`U_A(\\phi)` is the unitary matrix\n\n.. math::\n\n    U_A(\\phi) = \\left(\\begin{array}{cc} 0 & e^{-i\\phi} \\\\ e^{-i\\phi} & 0 \\\\ \\end{array}\\right),\n\nwhich is applied controlled on the state of qubit ``m`` and can be further decomposed in\nterms of the\n`quantum operations <https://pennylane.readthedocs.io/en/stable/introduction/operations.html>`_\nsupported by Pennylane,\n\n|\n\n.. figure:: ../../_static/templates/layers/ua_decomposition.png\n    :align: center\n    :width: 70%\n    :target: javascript:void(0);\n\n|\n\nwhere,\n\n|\n\n.. figure:: ../../_static/templates/layers/phaseshift_decomposition.png\n    :align: center\n    :width: 65%\n    :target: javascript:void(0);\n\n|\n\nThe quantum circuits above decomposing the unitaries :math:`U_{1,\\mathrm{ex}}(\\phi, \\theta)`\nand :math:`U_A(\\phi)` are implemented by the ``u1_ex_gate`` and ``decompose_ua``\nfunctions, respectively. :math:`R_\\phi` refers to the ``PhaseShift`` gate in the\ncircuit diagram.\n\nArgs:\n    weights (tensor_like): Array of weights of shape ``(D, M, 2)``.\n        ``D`` is the number of entangler block layers and :math:`M=N-1`\n        is the number of exchange gates :math:`U_{1,\\mathrm{ex}}` per layer.\n    wires (Iterable): wires that the template acts on.\n    init_state (tensor_like): iterable or shape ``(len(wires),)`` tensor representing the Hartree-Fock state\n        used to initialize the wires. If ``None``, a tuple of zeros is selected as initial state.\n\n.. details::\n    :title: Usage Details\n\n    #. The number of wires :math:`N` has to be equal to the number of\n       spin orbitals included in the active space.\n\n    #. The number of trainable parameters scales linearly with the number of layers as\n       :math:`2D(N-1)`.\n\n    An example of how to use this template is shown below:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        import numpy as np\n        from functools import partial\n\n        # Build the electronic Hamiltonian\n        symbols, coordinates = (['H', 'H'], np.array([0., 0., -0.66140414, 0., 0., 0.66140414]))\n        h, qubits = qml.qchem.molecular_hamiltonian(symbols, coordinates)\n\n        # Define the Hartree-Fock state\n        electrons = 2\n        ref_state = qml.qchem.hf_state(electrons, qubits)\n\n        # Define the device\n        dev = qml.device('default.qubit', wires=qubits)\n\n        # Define the ansatz\n        ansatz = partial(qml.ParticleConservingU1, init_state=ref_state, wires=dev.wires)\n\n        # Define the cost function\n        @qml.qnode(dev)\n        def cost_fn(params):\n            ansatz(params)\n            return qml.expval(h)\n\n        # Compute the expectation value of 'h'\n        layers = 2\n        shape = qml.ParticleConservingU1.shape(layers, qubits)\n        params = np.random.random(shape)\n        print(cost_fn(params))\n\n    **Parameter shape**\n\n    The shape of the trainable weights tensor can be computed by the static method\n    :meth:`~.ParticleConservingU1.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shape = qml.ParticleConservingU1.shape(n_layers=2, n_wires=2)\n        params = np.random.random(size=shape)"
  },
  {
    "name": "/pennylane/pennylane.templates.layers.particle_conserving_u2.ParticleConservingU2",
    "summary": "Implements the heuristic VQE ansatz for Quantum Chemistry simulations using the particle-conserving entangler :math:`U_\\mathrm{ent}(\\vec{\\theta}, \\vec{\\phi})` proposed in `arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`__.",
    "docstring": "Implements the heuristic VQE ansatz for Quantum Chemistry simulations using the\nparticle-conserving entangler :math:`U_\\mathrm{ent}(\\vec{\\theta}, \\vec{\\phi})` proposed in\n`arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`__.\n\nThis template prepares :math:`N`-qubit trial states by applying :math:`D` layers of the entangler\nblock :math:`U_\\mathrm{ent}(\\vec{\\theta}, \\vec{\\phi})` to the Hartree-Fock state\n\n.. math::\n\n    \\vert \\Psi(\\vec{\\theta}, \\vec{\\phi}) \\rangle = \\hat{U}^{(D)}_\\mathrm{ent}(\\vec{\\theta}_D,\n    \\vec{\\phi}_D) \\dots \\hat{U}^{(2)}_\\mathrm{ent}(\\vec{\\theta}_2, \\vec{\\phi}_2)\n    \\hat{U}^{(1)}_\\mathrm{ent}(\\vec{\\theta}_1, \\vec{\\phi}_1) \\vert \\mathrm{HF}\\rangle,\n\nwhere :math:`\\hat{U}^{(i)}_\\mathrm{ent}(\\vec{\\theta}_i, \\vec{\\phi}_i) =\n\\hat{R}_\\mathrm{z}(\\vec{\\theta}_i) \\hat{U}_\\mathrm{2,\\mathrm{ex}}(\\vec{\\phi}_i)`.\nThe circuit implementing the entangler blocks is shown in the figure below:\n\n|\n\n.. figure:: ../../_static/templates/layers/particle_conserving_u2.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\n|\n\nEach layer contains :math:`N` rotation gates :math:`R_\\mathrm{z}(\\vec{\\theta})` and\n:math:`N-1` particle-conserving exchange gates :math:`U_{2,\\mathrm{ex}}(\\phi)`\nthat act on pairs of nearest-neighbors qubits. The repeated units across several qubits are\nshown in dotted boxes.  The unitary matrix representing :math:`U_{2,\\mathrm{ex}}(\\phi)`\n(`arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_) is decomposed into its elementary\ngates and implemented in the :func:`~.u2_ex_gate` function using PennyLane quantum operations.\n\n|\n\n.. figure:: ../../_static/templates/layers/u2_decomposition.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\n|\n\n\nArgs:\n    weights (tensor_like): Weight tensor of shape ``(D, M)`` where ``D`` is the number of\n        layers and ``M`` = ``2N-1`` is the total number of rotation ``(N)`` and exchange\n        ``(N-1)`` gates per layer.\n    wires (Iterable): wires that the template acts on.\n    init_state (tensor_like): iterable or shape ``(len(wires),)`` tensor representing the Hartree-Fock state\n        used to initialize the wires. If ``None``, a tuple of zeros is selected as initial state.\n\n.. details::\n    :title: Usage Details\n\n    #. The number of wires has to be equal to the number of spin orbitals included in\n       the active space.\n\n    #. The number of trainable parameters scales with the number of layers :math:`D` as\n       :math:`D(2N-1)`.\n\n    An example of how to use this template is shown below:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        import numpy as np\n        from functools import partial\n\n        # Build the electronic Hamiltonian\n        symbols, coordinates = (['H', 'H'], np.array([0., 0., -0.66140414, 0., 0., 0.66140414]))\n        h, qubits = qml.qchem.molecular_hamiltonian(symbols, coordinates)\n\n        # Define the HF state\n        ref_state = qml.qchem.hf_state(2, qubits)\n\n        # Define the device\n        dev = qml.device('default.qubit', wires=qubits)\n\n        # Define the ansatz\n        ansatz = partial(qml.ParticleConservingU2, init_state=ref_state, wires=dev.wires)\n\n        # Define the cost function\n        @qml.qnode(dev)\n        def cost_fn(params):\n            ansatz(params)\n            return qml.expval(h)\n\n        # Compute the expectation value of 'h' for a given set of parameters\n        layers = 1\n        shape = qml.ParticleConservingU2.shape(layers, qubits)\n        params = np.random.random(shape)\n        print(cost_fn(params))\n\n    **Parameter shape**\n\n    The shape of the trainable weights tensor can be computed by the static method\n    :meth:`~qml.ParticleConservingU2.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shape = qml.ParticleConservingU2.shape(n_layers=2, n_wires=2)\n        params = np.random.random(size=shape)"
  },
  {
    "name": "/pennylane/pennylane.templates.layers.random.RandomLayers",
    "summary": "Layers of randomly chosen single qubit rotations and 2-qubit entangling gates, acting on randomly chosen qubits.",
    "docstring": "Layers of randomly chosen single qubit rotations and 2-qubit entangling gates, acting\non randomly chosen qubits.\n\n.. warning::\n    This template uses random number generation inside qnodes. Find more\n    details about how to invoke the desired random behaviour in the \"Usage Details\" section below.\n\nThe argument ``weights`` contains the weights for each layer. The number of layers :math:`L` is therefore derived\nfrom the first dimension of ``weights``.\n\nThe two-qubit gates of type ``imprimitive`` and the rotations are distributed randomly in the circuit.\nThe number of random rotations is derived from the second dimension of ``weights``. The number of\ntwo-qubit gates is determined by ``ratio_imprim``. For example, a ratio of ``0.3`` with ``30`` rotations\nwill lead to the use of ``10`` two-qubit gates.\n\n.. note::\n    If applied to one qubit only, this template will use no imprimitive gates.\n\nThis is an example of two 4-qubit random layers with four Pauli-Y/Pauli-Z rotations :math:`R_y, R_z`,\ncontrolled-Z gates as imprimitives, as well as ``ratio_imprim=0.3``:\n\n.. figure:: ../../_static/layer_rnd.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\nArgs:\n    weights (tensor_like): weight tensor of shape ``(L, k)``,\n    wires (Iterable): wires that the template acts on\n    ratio_imprim (float): value between 0 and 1 that determines the ratio of imprimitive to rotation gates\n    imprimitive (pennylane.ops.Operation): two-qubit gate to use, defaults to :class:`~pennylane.ops.CNOT`\n    rotations (tuple[pennylane.ops.Operation]): List of Pauli-X, Pauli-Y and/or Pauli-Z gates. The frequency\n        determines how often a particular rotation type is used. Defaults to the use of all three\n        rotations with equal frequency.\n    seed (int): seed to generate random architecture, defaults to 42\n\n.. details::\n    :title: Usage Details\n\n    **Default seed**\n\n    ``RandomLayers`` always uses a seed to initialize the construction of a random circuit. This means\n    that the template creates the same circuit every time it is called. If no seed is provided, the default\n    seed of ``42`` is used.\n\n    .. code-block:: python\n\n        import pennylane as qml\n        from pennylane import numpy as pnp\n\n        dev = qml.device(\"default.qubit\", wires=2)\n        weights = pnp.array([[0.1, -2.1, 1.4]])\n\n        @qml.qnode(dev)\n        def circuit1(weights):\n            qml.RandomLayers(weights=weights, wires=range(2))\n            return qml.expval(qml.Z(0))\n\n        @qml.qnode(dev)\n        def circuit2(weights):\n            qml.RandomLayers(weights=weights, wires=range(2))\n            return qml.expval(qml.Z(0))\n\n    >>> pnp.allclose(circuit1(weights), circuit2(weights))\n    True\n\n    You can verify this by drawing the circuits.\n\n    >>> print(qml.draw(circuit1, level=\"device\")(weights))\n    0: \u2500\u2500RY(0.10)\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <Z>\n    1: \u2500\u2500RX(-2.10)\u2500\u2570X\u2500\u2500RZ(1.40)\u2500\u2524\n\n    >>> print(qml.draw(circuit2, level=\"device\")(weights))\n    0: \u2500\u2500RY(0.10)\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <Z>\n    1: \u2500\u2500RX(-2.10)\u2500\u2570X\u2500\u2500RZ(1.40)\u2500\u2524\n\n\n    **Changing the seed**\n\n    To change the randomly generated circuit architecture, you have to change the seed passed to the template.\n    For example, these two calls of ``RandomLayers`` *do not* create the same circuit:\n\n    >>> @qml.qnode(dev)\n    ... def circuit(weights, seed=None):\n    ...     qml.RandomLayers(weights=weights, wires=range(2), seed=seed)\n    ...     return qml.expval(qml.Z(0))\n    >>> np.allclose(circuit(weights, seed=9), circuit(weights, seed=12))\n    False\n    >>> print(qml.draw(circuit, level=\"device\")(weights, seed=9))\n    0: \u2500\u2500RZ(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <Z>\n    1: \u2500\u2500RZ(-2.10)\u2500\u2500RZ(1.40)\u2500\u2524\n    >>> print(qml.draw(circuit, level=\"device\")(weights, seed=12))\n    0: \u2500\u256d\u25cf\u2500\u256dX\u2500\u2500RY(0.10)\u2500\u2500RY(-2.10)\u2500\u2524  <Z>\n    1: \u2500\u2570X\u2500\u2570\u25cf\u2500\u2500RX(1.40)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n\n    **Automatic creation of random circuits**\n\n    To automate the process of creating different circuits with ``RandomLayers``,\n    you can set ``seed=None`` to avoid specifying a seed. However, in this case care needs\n    to be taken. The quantum function is re-evaluated every time it is called.\n\n    .. code-block:: python\n\n        @qml.qnode(dev)\n        def circuit_rnd(weights):\n            qml.RandomLayers(weights=weights, wires=range(2), seed=None)\n            return qml.expval(qml.Z(0))\n\n        first_call = circuit_rnd(weights)\n        second_call = circuit_rnd(weights)\n\n    >>> np.allclose(first_call, second_call) # doctest: +SKIP\n    False\n\n    **Parameter shape**\n\n    The expected shape for the weight tensor can be computed with the static method\n    :meth:`~.RandomLayers.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shape = qml.RandomLayers.shape(n_layers=2, n_rotations=3)\n        weights = np.random.random(size=shape)"
  },
  {
    "name": "/pennylane/pennylane.templates.layers.simplified_two_design.SimplifiedTwoDesign",
    "summary": "Layers consisting of a simplified 2-design architecture of Pauli-Y rotations and controlled-Z entanglers proposed in `Cerezo et al. (2021) <https://doi.org/10.1038/s41467-021-21728-w>`_.",
    "docstring": "Layers consisting of a simplified 2-design architecture of Pauli-Y rotations and controlled-Z entanglers\nproposed in `Cerezo et al. (2021) <https://doi.org/10.1038/s41467-021-21728-w>`_.\n\nA 2-design is an ensemble of unitaries whose statistical properties are the same as sampling random unitaries\nwith respect to the Haar measure up to the first 2 moments.\n\nThe template is not a strict 2-design, since\nit does not consist of universal 2-qubit gates as building blocks, but has been shown in\n`Cerezo et al. (2021) <https://doi.org/10.1038/s41467-021-21728-w>`_ to exhibit important properties to study \"barren plateaus\"\nin quantum optimization landscapes.\n\nThe template starts with an initial layer of single qubit Pauli-Y rotations, before the main\n:math:`L` layers are applied. The basic building block of the main layers are controlled-Z entanglers\nfollowed by a pair of Pauli-Y rotation gates (one for each wire).\nEach layer consists of an \"even\" part whose entanglers start with the first qubit,\nand an \"odd\" part that starts with the second qubit.\n\nThis is an example of two layers, including the initial layer:\n\n.. figure:: ../../_static/templates/layers/simplified_two_design.png\n    :align: center\n    :width: 40%\n    :target: javascript:void(0);\n\n|\n\nThe argument ``initial_layer_weights`` contains the rotation angles of the initial layer of Pauli-Y rotations,\nwhile ``weights`` contains the pairs of Pauli-Y rotation angles of the respective layers. Each layer takes\n:math:`\\lfloor M/2 \\rfloor + \\lfloor (M-1)/2 \\rfloor = M-1` pairs of angles, where :math:`M` is the number of wires.\nThe number of layers :math:`L` is derived from the first dimension of ``weights``.\n\nArgs:\n    initial_layer_weights (tensor_like): weight tensor for the initial rotation block, shape ``(M,)``\n    weights (tensor_like): tensor of rotation angles for the layers, shape ``(L, M-1, 2)``\n    wires (Iterable): wires that the template acts on\n\n\n.. details::\n    :title: Usage Details\n\n    template - here shown for two layers - is used inside a :class:`QNode <pennylane.QNode>`:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        from math import pi\n\n        n_wires = 3\n        dev = qml.device('default.qubit', wires=n_wires)\n\n        @qml.qnode(dev)\n        def circuit(init_weights, weights):\n            qml.SimplifiedTwoDesign(initial_layer_weights=init_weights, weights=weights, wires=range(n_wires))\n            return [qml.expval(qml.Z(i)) for i in range(n_wires)]\n\n        init_weights = [pi, pi, pi]\n        weights_layer1 = [[0., pi],\n                          [0., pi]]\n        weights_layer2 = [[pi, 0.],\n                          [pi, 0.]]\n        weights = [weights_layer1, weights_layer2]\n\n    >>> circuit(init_weights, weights)\n    [np.float64(1.0), np.float64(-1.0), np.float64(1.0)]\n\n    **Parameter shapes**\n\n    A list of shapes for the two weights arguments can be computed with the static method\n    :meth:`~.qml.SimplifiedTwoDesign.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shapes = qml.SimplifiedTwoDesign.shape(n_layers=2, n_wires=2)\n        weights = [np.random.random(size=shape) for shape in shapes]"
  },
  {
    "name": "/pennylane/pennylane.templates.layers.strongly_entangling.StronglyEntanglingLayers",
    "summary": "Layers consisting of single qubit rotations and entanglers, inspired by the circuit-centric classifier design `arXiv:1804.00633 <https://arxiv.org/abs/1804.00633>`_.",
    "docstring": "Layers consisting of single qubit rotations and entanglers, inspired by the circuit-centric classifier design\n`arXiv:1804.00633 <https://arxiv.org/abs/1804.00633>`_.\n\nThe argument ``weights`` contains the weights for each layer. The number of layers :math:`L` is therefore derived\nfrom the first dimension of ``weights``.\n\nThe 2-qubit gates, whose type is specified by the ``imprimitive`` argument,\nact chronologically on the :math:`M` wires, :math:`i = 1,...,M`. The second qubit of each gate is given by\n:math:`(i+r)\\mod M`, where :math:`r` is a  hyperparameter called the *range*, and :math:`0 < r < M`.\nIf applied to one qubit only, this template will use no imprimitive gates.\n\nThis is an example of two 4-qubit strongly entangling layers (ranges :math:`r=1` and :math:`r=2`, respectively) with\nrotations :math:`R` and CNOTs as imprimitives:\n\n.. figure:: ../../_static/layer_sec.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\n.. note::\n    The two-qubit gate used as the imprimitive or entangler must not depend on parameters.\n\nArgs:\n\n    weights (tensor_like): weight tensor of shape ``(L, M, 3)``\n    wires (Iterable): wires that the template acts on\n    ranges (Sequence[int]): sequence determining the range hyperparameter for each subsequent layer; if ``None``\n                            using :math:`r=l \\mod M` for the :math:`l` th layer and :math:`M` wires.\n    imprimitive (type of pennylane.ops.Operation): two-qubit gate to use, defaults to :class:`~pennylane.ops.CNOT`\n\nExample:\n\n    There are multiple arguments that the user can use to customize the layer.\n\n    The required arguments are ``weights`` and ``wires``.\n\n    .. code-block:: python\n\n        dev = qml.device('default.qubit', wires=4)\n\n        @qml.qnode(dev)\n        def circuit(parameters):\n            qml.StronglyEntanglingLayers(weights=parameters, wires=range(4))\n            return qml.expval(qml.Z(0))\n\n        shape = qml.StronglyEntanglingLayers.shape(n_layers=2, n_wires=4)\n        rng = np.random.default_rng(12345)\n        weights = rng.random(size=shape)\n\n    The shape of the ``weights`` argument decides the number of layers.\n\n    The resulting circuit is:\n\n    >>> print(qml.draw(circuit, level=\"device\")(weights))\n    0: \u2500\u2500Rot(0.23,0.32,0.80)\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dX\u2500\u2500Rot(0.67,0.10,0.44)\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u256dX\u2500\u2500\u2500\u2500\u2524  <Z>\n    1: \u2500\u2500Rot(0.68,0.39,0.33)\u2500\u2570X\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500Rot(0.89,0.70,0.33)\u2500\u2502\u2500\u2500\u256d\u25cf\u2500\u2502\u2500\u2500\u256dX\u2500\u2524\n    2: \u2500\u2500Rot(0.60,0.19,0.67)\u2500\u2500\u2500\u2500\u2570X\u2500\u256d\u25cf\u2500\u2502\u2500\u2500\u2500Rot(0.73,0.22,0.08)\u2500\u2570X\u2500\u2502\u2500\u2500\u2570\u25cf\u2500\u2502\u2500\u2500\u2524\n    3: \u2500\u2500Rot(0.94,0.25,0.95)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2570\u25cf\u2500\u2500Rot(0.16,0.34,0.47)\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2524\n\n    The default two-qubit gate used is :class:`~pennylane.ops.CNOT`. This can be changed by using the ``imprimitive`` argument.\n\n    The ``ranges`` argument takes an integer sequence where each element\n    determines the range hyperparameter for each layer. This range hyperparameter\n    is the difference of the wire indices representing the two qubits the\n    ``imprimitive`` gate acts on. For example, for ``range=[2,3]`` the\n    first layer will have a range parameter of ``2`` and the second layer will\n    have a range parameter of ``3``.\n    Assuming ``wires=[0, 1, 2, 3]`` and a range parameter of ``2``, there will be\n    an imprimitive gate acting on:\n\n    * qubits ``(0, 2)``;\n    * qubits ``(1, 3)``;\n    * qubits ``(2, 0)``;\n    * qubits ``(3, 1)``.\n\n    .. code-block:: python\n\n        dev = qml.device('default.qubit', wires=4)\n\n        @qml.qnode(dev)\n        def circuit(parameters):\n            qml.StronglyEntanglingLayers(weights=parameters, wires=range(4), ranges=[2, 3], imprimitive=qml.ops.CZ)\n            return qml.expval(qml.Z(0))\n\n        shape = qml.StronglyEntanglingLayers.shape(n_layers=2, n_wires=4)\n        rng = np.random.default_rng(12345)\n        weights = rng.random(size=shape)\n\n    The resulting circuit is:\n\n    >>> print(qml.draw(circuit, level=\"device\")(weights))\n    0: \u2500\u2500Rot(0.23,0.32,0.80)\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u256dZ\u2500\u2500Rot(0.67,0.10,0.44)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u256dZ\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <Z>\n    1: \u2500\u2500Rot(0.68,0.39,0.33)\u2500\u2502\u2500\u2500\u256d\u25cf\u2500\u2502\u2500\u2500\u256dZ\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500Rot(0.89,0.70,0.33)\u2500\u2502\u2500\u2500\u2570\u25cf\u2500\u256dZ\u2500\u2500\u2500\u2500\u2524\n    2: \u2500\u2500Rot(0.60,0.19,0.67)\u2500\u2570Z\u2500\u2502\u2500\u2500\u2570\u25cf\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500Rot(0.73,0.22,0.08)\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u256dZ\u2500\u2524\n    3: \u2500\u2500Rot(0.94,0.25,0.95)\u2500\u2500\u2500\u2500\u2570Z\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500Rot(0.16,0.34,0.47)\u2500\u2570Z\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2524\n\n.. details::\n    :title: Usage Details\n\n    **Parameter shape**\n\n    The expected shape for the weight tensor can be computed with the static method\n    :meth:`~.qml.StronglyEntanglingLayers.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shape = qml.StronglyEntanglingLayers.shape(n_layers=2, n_wires=2)\n        weights = np.random.random(size=shape)"
  },
  {
    "name": "/pennylane/pennylane.templates.state_preparations.arbitrary_state_preparation.ArbitraryStatePreparation",
    "summary": "Implements an arbitrary state preparation on the specified wires.",
    "docstring": "Implements an arbitrary state preparation on the specified wires.\n\nAn arbitrary state on :math:`n` wires is parametrized by :math:`2^{n+1} - 2`\nindependent real parameters. This templates uses Pauli word rotations to\nparametrize the unitary.\n\nArgs:\n    weights (tensor_like): Angles of the Pauli word rotations. Needs to have length :math:`2^{n+1} - 2`\n        where :math:`n` is the number of wires the template acts upon.\n    wires (Iterable): wires that the template acts on\n\n**Example**\n\nArbitraryStatePreparation can be used to train state preparations,\nfor example using a circuit with some measurement observable ``H``:\n\n.. code-block:: python\n\n    dev = qml.device(\"default.qubit\", wires=4)\n\n    @qml.qnode(dev)\n    def vqe(weights):\n        qml.ArbitraryStatePreparation(weights, wires=[0, 1, 2, 3])\n\n        return qml.expval(qml.Hermitian(H, wires=[0, 1, 2, 3]))\n\nThe shape of the weights parameter can be computed as follows:\n\n.. code-block:: python\n\n    shape = qml.ArbitraryStatePreparation.shape(n_wires=4)"
  },
  {
    "name": "/pennylane/pennylane.templates.state_preparations.basis_qutrit.QutritBasisStatePreparation",
    "summary": "Prepares a basis state on the given wires using a sequence of TShift gates.",
    "docstring": "Prepares a basis state on the given wires using a sequence of TShift gates.\n\n.. warning::\n\n    ``basis_state`` influences the circuit architecture and is therefore incompatible with\n    gradient computations.\n\nArgs:\n    basis_state (array): Input array of shape ``(n,)``, where n is the number of wires\n        the state preparation acts on.\n    wires (Iterable): wires that the template acts on\n\n**Example**\n\n.. code-block:: python\n\n    dev = qml.device(\"default.qutrit\", wires=4)\n\n    @qml.qnode(dev)\n    def circuit(basis_state, obs):\n        qml.QutritBasisStatePreparation(basis_state, wires=range(4))\n        return [qml.expval(qml.THermitian(obs, wires=i)) for i in range(4)]\n\n    basis_state = [0, 1, 1, 0]\n    obs = np.array([[1, 1, 0], [1, -1, 0], [0, 0, np.sqrt(2)]]) / np.sqrt(2)\n\n>>> print(circuit(basis_state, obs)) # doctest: +SKIP\n[array(0.7071), array(-0.7071), array(-0.7071), array(0.7071)]"
  },
  {
    "name": "/pennylane/pennylane.templates.state_preparations.cosine_window.CosineWindow",
    "summary": "CosineWindow(wires) Prepares an initial state with a cosine wave function.",
    "docstring": "CosineWindow(wires)\nPrepares an initial state with a cosine wave function.\n\nThe wave function is defined below where :math:`m` is the number of wires.\n\n.. math::\n\n    |\\psi\\rangle = \\sqrt{2^{1-m}} \\sum_{k=0}^{2^m-1} \\cos(\\frac{\\pi k}{2^m} - \\frac{\\pi}{2}) |k\\rangle,\n\n.. figure:: ../../_static/templates/state_preparations/cosine_window.png\n    :align: center\n    :width: 65%\n    :target: javascript:void(0);\n\n.. note::\n\n    The wave function is shifted by :math:`\\frac{\\pi}{2}` units so that the window is centered.\n\nFor more details see `Phys. Rev. D 106 (2022) <https://journals.aps.org/prd/abstract/10.1103/PhysRevD.106.034503>`_.\n\n.. seealso:: :class:`~.QuantumPhaseEstimation` and :class:`~.QFT`.\n\nArgs:\n    wires (Sequence[int] or int): the wire(s) the operation acts on\n\n**Example**\n\n>>> dev = qml.device('default.qubit', wires=2)\n>>> @qml.qnode(dev)\n... def example_circuit():\n...     qml.CosineWindow(wires=range(2))\n...     return qml.probs()\n>>> print(example_circuit()) # doctest: +SKIP\n[1.8747e-33 2.5000e-01 5.0000e-01 2.5000e-01]"
  },
  {
    "name": "/pennylane/pennylane.templates.state_preparations.mottonen.MottonenStatePreparation",
    "summary": "Prepares an arbitrary state on the given wires using a decomposition into gates developed by `M\u00f6tt\u00f6nen et al. (2004) <https://arxiv.org/abs/quant-ph/0407010>`_.",
    "docstring": "Prepares an arbitrary state on the given wires using a decomposition into gates developed\nby `M\u00f6tt\u00f6nen et al. (2004) <https://arxiv.org/abs/quant-ph/0407010>`_.\n\nThe state is prepared via a sequence\nof uniformly controlled rotations. A uniformly controlled rotation on a target qubit is\ncomposed from all possible controlled rotations on the qubit and can be used to address individual\nelements of the state vector.\n\nIn the work of M\u00f6tt\u00f6nen et al., inverse state preparation\nis executed by first equalizing the phases of the state vector via uniformly controlled Z rotations,\nand then rotating the now real state vector into the direction of the state :math:`|0\\rangle` via\nuniformly controlled Y rotations.\n\nThis code is adapted from code written by Carsten Blank for PennyLane-Qiskit.\n\n.. warning::\n\n    Due to non-trivial classical processing of the state vector,\n    this template is not always fully differentiable.\n\nArgs:\n    state_vector (tensor_like): Input array of shape ``(2^n,)``, where ``n`` is the number of wires\n        the state preparation acts on. The input array must be normalized.\n    wires (Iterable): wires that the template acts on\n\nExample:\n\n    ``MottonenStatePreparation`` creates any arbitrary state on the given wires depending on the input state vector.\n\n    .. code-block:: python\n\n        dev = qml.device('default.qubit', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(state):\n            qml.MottonenStatePreparation(state_vector=state, wires=range(3))\n            return qml.state()\n\n        state = np.array([1, 2j, 3, 4j, 5, 6j, 7, 8j])\n        state = state / np.linalg.norm(state)\n\n        print(qml.draw(circuit, level=\"device\", max_length=80)(state))\n\n    .. code-block::\n\n        0: \u2500\u2500RY(2.35)\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\n        1: \u2500\u2500RY(2.09)\u2500\u2570X\u2500\u2500RY(0.21)\u2500\u2570X\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\n        2: \u2500\u2500RY(1.88)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500RY(0.10)\u2500\u2570X\u2500\u2500RY(0.08)\u2500\u2570X\u2500\u2500RY(0.15)\u2500\u2570X\n\n        \u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u256dGlobalPhase(-0.79)\u2500\u2524 \u256dState\n        \u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u256d\u25cf\u2500\u2502\u2500\u2500\u256d\u25cf\u2500\u2502\u2500\u2500\u251cGlobalPhase(-0.79)\u2500\u2524 \u251cState\n        \u2500\u2500\u2500RZ(1.57)\u2500\u2500\u2500\u2500\u2570X\u2500\u2570X\u2500\u2570X\u2500\u2570X\u2500\u2570GlobalPhase(-0.79)\u2500\u2524 \u2570State\n\n    The state preparation can be checked by running:\n\n    >>> print(np.allclose(state, circuit(state)))\n    True"
  },
  {
    "name": "/pennylane/pennylane.templates.state_preparations.qrom_state_prep.QROMStatePreparation",
    "summary": "Prepares a quantum state using Quantum Read-Only Memory (QROM).",
    "docstring": "Prepares a quantum state using Quantum Read-Only Memory (QROM).\n\nThis operation implements the state preparation method described\nin `arXiv:0208112 <https://arxiv.org/abs/quant-ph/0208112>`_.\n\nArgs:\n    state_vector (tensor_like): The state vector of length :math:`2^n` to be prepared on :math:`n` wires.\n    wires (Sequence[int]): The wires on which to prepare the state.\n    precision_wires (Sequence[int]): The wires allocated for storing the binary representations of the\n        rotation angles utilized in the template.\n    work_wires (Sequence[int], optional):  The work wires used for the QROM operations. Defaults to ``None``.\n\nRaises:\n    ValueError: If the length of the input state vector array is not :math:`2^n` where :math:`n` is an integer, or if\n        its norm is not equal to one.\n\n**Example**\n\n.. code-block:: python\n\n    import numpy as np\n\n    probs_vector = np.array([0.5, 0., 0.25, 0.25])\n\n    dev = qml.device(\"default.qubit\", wires = 6)\n\n    wires = qml.registers({\"work_wires\": 1, \"prec_wires\": 3, \"state_wires\": 2})\n\n    @qml.qnode(dev)\n    def circuit():\n        qml.QROMStatePreparation(\n            np.sqrt(probs_vector), wires[\"state_wires\"], wires[\"prec_wires\"], wires[\"work_wires\"]\n        )\n        return qml.probs(wires[\"state_wires\"])\n\n.. code-block:: pycon\n\n    >>> circuit()\n    array([0.5 , 0.  , 0.25, 0.25])\n\n.. seealso:: :class:`~.QROM`\n\n.. details::\n    :title: Usage Details\n\n    The ``precision_wires`` are used as the target wires in the underlying QROM operations.\n    The number of ``precision_wires`` determines the precision with which the rotation angles of the\n    template are encoded. This means that the binary representation of the angle is truncated up to\n    the :math:`m`-th digit, where :math:`m` is the number of precision wires given. See  Eq. 5 in\n    `arXiv:0208112 <https://arxiv.org/abs/quant-ph/0208112>`_ for more details.\n    The ``work_wires`` correspond to auxiliary qubits that can be specified in :class:`~.QROM` to\n    reduce the overall resource requirements on the implementation."
  },
  {
    "name": "/pennylane/pennylane.templates.state_preparations.state_prep_mps.MPSPrep",
    "summary": "Prepares an initial state from a matrix product state (MPS) representation.",
    "docstring": "Prepares an initial state from a matrix product state (MPS) representation.\n\n.. note::\n\n    This operator is natively supported on the ``lightning.tensor`` device, which is designed to run MPS\n    structures efficiently. For other devices, this operation prepares the state vector represented by the\n    MPS using a gate-based decomposition from Eq. (23) in `arXiv:2310.18410\n    <https://arxiv.org/pdf/2310.18410>`_, which requires the right canonicalization of the MPS using\n    the :func:`~.right_canonicalize_mps` function and defining auxiliary qubits with ``work_wires``.\n\nArgs:\n    mps (list[TensorLike]):  list of arrays of rank-3 and rank-2 tensors representing an MPS state\n        as a product of site matrices. See the usage details section for more information.\n\n    wires (Sequence[int]): wires that the template acts on. It should match the number of MPS tensors.\n    work_wires (Sequence[int]): list of extra qubits needed in the decomposition. If the maximum dimension\n        of the MPS tensors is :math:`2^k`, then :math:`k` ``work_wires`` will be needed. If no ``work_wires`` are given,\n        this operator can only be executed on the ``lightning.tensor`` device. Default is ``None``.\n\n    right_canonicalize (bool): indicates whether a conversion to right-canonical form should be performed to the MPS.\n        Default is ``False``.\n\n\n.. seealso:: :func:`~.right_canonicalize_mps`.\n\n**Example**\n\nExample using the ``lightning.tensor`` device:\n\n.. code-block:: python\n\n    mps = [\n        np.array([[0.0, 0.107], [0.994, 0.0]]),\n        np.array(\n            [\n                [[0.0, 0.0], [1.0, 0.0]],\n                [[0.0, 1.0], [0.0, 0.0]],\n            ]\n        ),\n        np.array([[-1.0, -0.0], [-0.0, -1.0]]),\n    ]\n\n.. code-block::\n\n    dev = qml.device(\"lightning.tensor\", wires=3)\n    @qml.qnode(dev)\n    def circuit():\n        qml.MPSPrep(mps, wires = [0,1,2])\n        return qml.state()\n\n>>> print(circuit()) # doctest: +SKIP\n[ 0.        +0.j -0.10705513+0.j  0.        +0.j  0.        +0.j\n0.        +0.j  0.        +0.j -0.99451217+0.j  0.        +0.j]\n\nExample using the ``default.qubit`` device:\n\n.. code-block:: python\n\n    dev = qml.device(\"default.qubit\", wires=4)\n    @qml.qnode(dev)\n    def circuit():\n        qml.MPSPrep(mps, wires = [1,2,3], work_wires = [0])\n        return qml.state()\n\n>>> print(circuit()[:8]) # doctest: +SKIP\n[ 0.        +0.j -0.10702756+0.j  0.        +0.j  0.        +0.j\n  0.        +0.j  0.        +0.j -0.99425605+0.j  0.        +0.j]\n\n.. details::\n    :title: Usage Details\n\n    The input MPS must be a list of :math:`n` tensors :math:`[A^{(0)}, ..., A^{(n-1)}]`\n    with shapes :math:`d_0, ..., d_{n-1}`, respectively. The first and last tensors have rank :math:`2`\n    while the intermediate tensors have rank :math:`3`.\n\n    The first tensor must have the shape :math:`d_0 = (d_{0,0}, d_{0,1})` where :math:`d_{0,0}`\n    and :math:`d_{0,1}`  correspond to the physical dimension of the site and an auxiliary bond\n    dimension connecting it to the next tensor, respectively.\n\n    The last tensor must have the shape :math:`d_{n-1} = (d_{n-1,0}, d_{n-1,1})` where :math:`d_{n-1,0}`\n    and :math:`d_{n-1,1}` represent the auxiliary dimension from the previous site and the physical\n    dimension of the site, respectively.\n\n    The intermediate tensors must have the shape :math:`d_j = (d_{j,0}, d_{j,1}, d_{j,2})`, where:\n\n    - :math:`d_{j,0}` is the bond dimension connecting to the previous tensor\n    - :math:`d_{j,1}` is the physical dimension of the site\n    - :math:`d_{j,2}` is the bond dimension connecting to the next tensor\n\n    Note that the bond dimensions must match between adjacent tensors such that :math:`d_{j-1,2} = d_{j,0}`.\n\n    Additionally, the physical dimension of the site should always be fixed at :math:`2`\n    (since the dimension of a qubit is :math:`2`), while the other dimensions must be powers of two.\n\n    The following example shows a valid MPS input containing four tensors with\n    dimensions :math:`[(2,2), (2,2,4), (4,2,2), (2,2)]` which satisfy the criteria described above.\n\n    .. code-block::\n\n        mps = [\n            np.array([[0.0, 0.107], [0.994, 0.0]]),\n            np.array(\n                [\n                    [[0.0, 0.0, 0.0, -0.0], [1.0, 0.0, 0.0, -0.0]],\n                    [[0.0, 1.0, 0.0, -0.0], [0.0, 0.0, 0.0, -0.0]],\n                ]\n            ),\n            np.array(\n                [\n                    [[-1.0, 0.0], [0.0, 0.0]],\n                    [[0.0, 0.0], [0.0, 1.0]],\n                    [[0.0, -1.0], [0.0, 0.0]],\n                    [[0.0, 0.0], [1.0, 0.0]],\n                ]\n            ),\n            np.array([[-1.0, -0.0], [-0.0, -1.0]]),\n        ]"
  },
  {
    "name": "/pennylane/pennylane.templates.state_preparations.superposition.Superposition",
    "summary": "Prepare a superposition of computational basis states.",
    "docstring": "Prepare a superposition of computational basis states.\n\nGiven a list of :math:`m` coefficients :math:`c_i` and basic states :math:`|b_i\\rangle`,\nthis operator prepares the state:\n\n.. math::\n\n    |\\phi\\rangle = \\sum_i^m c_i |b_i\\rangle.\n\nSee the Details section for more information about the decomposition.\n\nArgs:\n    coeffs (tensor-like[float]): normalized coefficients of the superposition\n    bases (tensor-like[int]): basis states of the superposition\n    wires (Sequence[int]): wires that the operator acts on\n    work_wire (Union[Wires, int, str]): the auxiliary wire used for the permutation\n\n**Example**\n\n.. code-block:: python\n\n    import pennylane as qml\n    import numpy as np\n\n    coeffs = np.sqrt(np.array([1/3, 1/3, 1/3]))\n    bases = np.array([[1, 1, 1], [0, 1, 0], [0, 0, 0]])\n    wires = [0, 1, 2]\n    work_wire = 3\n\n    dev = qml.device('default.qubit')\n    @qml.qnode(dev)\n    def circuit():\n        qml.Superposition(coeffs, bases, wires, work_wire)\n        return qml.probs(wires)\n\n>>> print(circuit()) # doctest: +SKIP\n[0.3333 0.     0.3333 0.     0.     0.     0.     0.3333]\n\n\n.. details::\n    :title: Details\n\n    The input superposition state , :math:`|\\phi\\rangle = \\sum_i^m c_i |b_i\\rangle`, is implemented in two steps. First, the coefficients :math:`c_i` are used to prepares the state:\n\n    .. math::\n\n        |\\phi\\rangle = \\sum_i^m c_i |i\\rangle,\n\n    where :math:`|i\\rangle` is a computational basis states and :math:`m` is the number of terms\n    in the superposition. This is done using the\n    :class:`~.StatePrep` template in the fisrt :math:`\\lceil \\log_2 m \\rceil` qubits. Note that the number of qubits depends on the number of terms in the superposition, which helps to reduce the complexity of the operation.\n\n    The second step permutes the basis states prepared previously to\n    the target basis states:\n\n    .. math::\n\n        |i\\rangle \\rightarrow |b_i\\rangle.\n\n    This block maps the elements one by one using an auxiliary qubit.\n    This can be done in three separate steps:\n\n    1. By using a multi-controlled NOT gate, check if the input state is :math:`|i\\rangle` and\n    store the information in the auxiliary qubit. If the state is :math:`|i\\rangle` the auxiliary\n    qubit will be in the :math:`|1\\rangle` state.\n\n    2. If the auxiliary qubit is in the :math:`|1\\rangle` state, the input state is modified by applying\n    ``X`` gates to the bits that are different between :math:`|i\\rangle` and :math:`|b_i\\rangle`.\n\n    3. By using a multi-controlled ``NOT`` gate, check if the final state is :math:`|b_i\\rangle` and\n    return the auxiliary qubit back to :math:`|0\\rangle` state.\n\n    Applying all these together prepares the desired superposition:\n\n    .. math::\n\n        |\\phi\\rangle = \\sum_i^m c_i |b_i\\rangle.\n\n    The decomposition has a complexity that grows linearly with the number of terms in the superposition,\n    unlike other methods such as :class:`~.MottonenStatePreparation` that grows exponentially\n    with the number of qubits."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.amplitude_amplification.AmplitudeAmplification",
    "summary": "Applies amplitude amplification.",
    "docstring": "Applies amplitude amplification.\n\nGiven a state :math:`|\\Psi\\rangle = \\alpha |\\phi\\rangle + \\beta|\\phi^{\\perp}\\rangle`, this\nsubroutine amplifies the amplitude of the state :math:`|\\phi\\rangle` such that\n\n.. math::\n\n        \\text{A}(U, O)|\\Psi\\rangle \\sim |\\phi\\rangle.\n\nThe implementation of the algorithm is based on [`arXiv:quant-ph/0005055 <https://arxiv.org/abs/quant-ph/0005055>`__].\nThe template also unlocks advanced techniques such as fixed-point quantum search\n[`arXiv:1409.3305 <https://arxiv.org/abs/1409.3305>`__] and oblivious amplitude amplification\n[`arXiv:1312.1414 <https://arxiv.org/abs/1312.1414>`__], by reflecting on a subset of wires.\n\nArgs:\n    U (Operator): the operator that prepares the state :math:`|\\Psi\\rangle`\n    O (Operator): the oracle that flips the sign of the state :math:`|\\phi\\rangle` and does nothing to the state :math:`|\\phi^{\\perp}\\rangle`\n    iters (int): the number of iterations of the amplitude amplification subroutine, default is ``1``\n    fixed_point (bool): whether to use the fixed-point amplitude amplification algorithm, default is ``False``\n    work_wire (int): the auxiliary wire to use for the fixed-point amplitude amplification algorithm, default is ``None``\n    reflection_wires (Wires): the wires to reflect on, default is the wires of ``U``\n    p_min (int): the lower bound for the probability of success in fixed-point amplitude amplification, default is ``0.9``\n\nRaises:\n    ValueError: ``work_wire`` must be specified if ``fixed_point == True``.\n    ValueError: ``work_wire`` must be different from the wires of the oracle ``O``.\n\n**Example**\n\nAmplification of state :math:`|2\\rangle` using Grover's algorithm with 3 qubits.\nThe state :math:`|\\Psi\\rangle` is constructed as a uniform superposition of basis states.\n\n.. code-block:: python\n\n    @qml.prod\n    def generator(wires):\n        for wire in wires:\n            qml.Hadamard(wires=wire)\n\n    U = generator(wires=range(3))\n    O = qml.FlipSign(2, wires=range(3))\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.qnode(dev)\n    def circuit():\n\n        generator(wires=range(3))\n        qml.AmplitudeAmplification(U, O, iters=5, fixed_point=True, work_wire=3)\n\n        return qml.probs(wires=range(3))\n\n>>> print(np.round(circuit(),3))\n[0.013 0.013 0.91  0.013 0.013 0.013 0.013 0.013]"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.aqft.AQFT",
    "summary": "AQFT(order, wires) Apply an approximate quantum Fourier transform (AQFT).",
    "docstring": "AQFT(order, wires)\nApply an approximate quantum Fourier transform (AQFT).\n\nThe `AQFT <https://arxiv.org/abs/1803.04933>`_ method helps to reduce the number of ``ControlledPhaseShift`` operations required\nfor QFT by only using a maximum of ``order`` number of ``ControlledPhaseShift`` gates per qubit.\n\n.. seealso:: :class:`~.QFT`\n\nArgs:\n    order (int): the order of approximation\n    wires (int or Iterable[Number, str]]): the wire(s) the operation acts on\n\n**Example**\n\nThe approximate quantum Fourier transform is applied by specifying the corresponding wires and\nthe order of approximation:\n\n.. code-block:: python\n\n    wires = 3\n    dev = qml.device('default.qubit', wires=wires)\n\n    @qml.qnode(dev)\n    def circuit_aqft():\n        qml.X(0)\n        qml.Hadamard(1)\n        qml.AQFT(order=1,wires=range(wires))\n        return qml.state()\n\n\n>>> circuit_aqft()\narray([ 0.5 +0.j  , -0.25-0.25j,  0.  +0.j  , -0.25+0.25j,  0.5 +0.j  ,\n    -0.25-0.25j,  0.  +0.j  , -0.25+0.25j])\n\n\n.. details::\n    :title: Usage Details\n\n    **Order**\n\n    The order of approximation must be a whole number less than :math:`n-1`\n    where :math:`n` is the number of wires the operation is being applied on.\n    This creates four cases for different ``order`` values:\n\n    * ``order`` :math:`< 0`\n        This will raise a ``ValueError``\n\n    * ``order`` :math:`= 0`\n        This will warn the user that only a Hadamard transform is being applied.\n\n        .. code-block:: python\n\n            @qml.qnode(qml.device('default.qubit'))\n            def circ():\n                qml.AQFT(order=0, wires=range(6))\n                return qml.probs()\n\n        The resulting circuit is:\n\n        >>> print(qml.draw(circ, level='device')()) # doctest: +SKIP\n        UserWarning: order=0, applying Hadamard transform warnings.warn(\"order=0, applying Hadamard transform\")\n        0: \u2500\u2500H\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u256dProbs\n        1: \u2500\u2500H\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cProbs\n        2: \u2500\u2500H\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2524 \u251cProbs\n        3: \u2500\u2500H\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u2524 \u251cProbs\n        4: \u2500\u2500H\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cProbs\n        5: \u2500\u2500H\u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2570Probs\n\n    * :math:`0 <` ``order`` :math:`< n-1`\n        This is the intended AQFT use case.\n\n        .. code-block:: python\n\n            @qml.qnode(qml.device('default.qubit'))\n            def circ():\n                qml.AQFT(order=2, wires=range(4))\n                return qml.probs()\n\n        The resulting circuit is:\n\n        >>> print(qml.draw(circ, level='device')())\n        0: \u2500\u2500H\u2500\u256dR\u03d5(1.57)\u2500\u256dR\u03d5(0.79)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  Probs\n        1: \u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500H\u2500\u256dR\u03d5(1.57)\u2500\u256dR\u03d5(0.79)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2524  Probs\n        2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500H\u2500\u256dR\u03d5(1.57)\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u2524  Probs\n        3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500H\u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  Probs\n\n    * ``order`` :math:`\\geq n-1`\n        Using the QFT class is recommended in this case. The AQFT operation here is\n        equivalent to QFT."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arbitrary_unitary.ArbitraryUnitary",
    "summary": "Implements an arbitrary unitary on the specified wires.",
    "docstring": "Implements an arbitrary unitary on the specified wires.\n\nAn arbitrary unitary on :math:`n` wires is parametrized by :math:`4^n - 1`\nindependent real parameters. This templates uses Pauli word rotations to\nparametrize the unitary.\n\n**Example**\n\nArbitraryUnitary can be used as a building block, e.g. to parametrize arbitrary\ntwo-qubit operations in a circuit:\n\n.. code-block:: python\n\n    def arbitrary_nearest_neighbour_interaction(weights, wires):\n        for i, w in enumerate(range(0, len(wires) - 1, 2)):\n            ArbitraryUnitary(weights[i], wires=[w, w + 1])\n\nArgs:\n    weights (tensor_like): The angles of the Pauli word rotations, needs to have length :math:`4^n - 1`\n        where :math:`n` is the number of wires the template acts upon.\n    wires (Iterable): wires that the template acts on"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.adder.Adder",
    "summary": "Performs the in-place modular addition operation.",
    "docstring": "Performs the in-place modular addition operation.\n\nThis operator performs the modular addition by an integer :math:`k` modulo :math:`mod` in the\ncomputational basis:\n\n.. math::\n\n    \\text{Adder}(k, mod) |x \\rangle = | x+k \\; \\text{mod} \\; mod \\rangle.\n\nThe implementation is based on the quantum Fourier transform method presented in\n`arXiv:2311.08555 <https://arxiv.org/abs/2311.08555>`_.\n\n.. note::\n\n    To obtain the correct result, :math:`x` must be smaller than :math:`mod`.\n\n.. seealso:: :class:`~.PhaseAdder` and :class:`~.OutAdder`.\n\nArgs:\n    k (int): the number that needs to be added\n    x_wires (Sequence[int]): the wires the operation acts on. The number of wires must be enough\n        for encoding `x` in the computational basis. The number of wires also limits the\n        maximum value for `mod`.\n    mod (int): the modulo for performing the addition. If not provided, it will be set to its maximum value, :math:`2^{\\text{len(x_wires)}}`.\n    work_wires (Sequence[int]): the auxiliary wires to use for the addition. The\n        work wires are not needed if :math:`mod=2^{\\text{len(x_wires)}}`, otherwise two work wires\n        should be provided. Defaults to empty tuple.\n\n**Example**\n\nThis example computes the sum of two integers :math:`x=8` and :math:`k=5` modulo :math:`mod=15`.\n\n.. code-block:: python\n\n    x = 8\n    k = 5\n    mod = 15\n\n    x_wires =[0,1,2,3]\n    work_wires=[4,5]\n\n    dev = qml.device(\"default.qubit\")\n    @qml.qnode(dev, shots=1)\n    def circuit():\n        qml.BasisEmbedding(x, wires=x_wires)\n        qml.Adder(k, x_wires, mod, work_wires)\n        return qml.sample(wires=x_wires)\n\n>>> print(circuit())\n[[1 1 0 1]]\n\nThe result, :math:`[[1 1 0 1]]`, is the binary representation of\n:math:`8 + 5  \\; \\text{modulo} \\; 15 = 13`.\n\n.. details::\n    :title: Usage Details\n\n    This template takes as input two different sets of wires.\n\n    The first one is ``x_wires``, used to encode the integer :math:`x < \\text{mod}` in the Fourier basis.\n    To represent :math:`x`, ``x_wires`` must include at least :math:`\\lceil \\log_2(x) \\rceil` wires.\n    After the modular addition, the result can be as large as :math:`\\text{mod} - 1`,\n    requiring at least :math:`\\lceil \\log_2(\\text{mod}) \\rceil` wires. Since :math:`x < \\text{mod}`,\n    :math:`\\lceil \\log_2(\\text{mod}) \\rceil` is a sufficient length for ``x_wires`` to cover all possible inputs and outputs.\n\n    The second set of wires is ``work_wires`` which consist of the auxiliary qubits used to perform the modular addition operation.\n\n    - If :math:`mod = 2^{\\text{len(x_wires)}}`, there will be no need for ``work_wires``, hence ``work_wires=()``. This is the case by default.\n\n    - If :math:`mod \\neq 2^{\\text{len(x_wires)}}`, two ``work_wires`` have to be provided.\n\n    Note that the ``Adder`` template allows us to perform modular addition in the computational basis. However if one just wants to perform standard addition (with no modulo), that would be equivalent to setting\n    the modulo :math:`mod` to a large enough value to ensure that :math:`x+k < mod`."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.mod_exp.ModExp",
    "summary": "Performs the out-place modular exponentiation operation.",
    "docstring": "Performs the out-place modular exponentiation operation.\n\nThis operator performs the modular exponentiation of the integer :math:`base` to the power\n:math:`x` modulo :math:`mod` in the computational basis:\n\n.. math::\n\n    \\text{ModExp}(base,mod) |x \\rangle |b \\rangle = |x \\rangle |b \\cdot base^x \\; \\text{mod} \\; mod \\rangle,\n\nThe implementation is based on the quantum Fourier transform method presented in\n`arXiv:2311.08555 <https://arxiv.org/abs/2311.08555>`_.\n\n.. note::\n\n    To obtain the correct result, :math:`x` must be smaller than :math:`mod`.\n    Also, it is required that :math:`base` has a modular inverse, :math:`base^{-1}`, with respect to :math:`mod`.\n    That means :math:`base \\cdot base^{-1}` modulo :math:`mod` is equal to 1, which will only be possible if :math:`base`\n    and :math:`mod` are coprime.\n\n.. seealso:: :class:`~.Multiplier`.\n\nArgs:\n    x_wires (Sequence[int]): the wires that store the integer :math:`x`\n    output_wires (Sequence[int]): the wires that store the operator result. These wires also encode :math:`b`.\n    base (int): integer that needs to be exponentiated\n    mod (int): the modulo for performing the exponentiation. If not provided, it will be set to its maximum value, :math:`2^{\\text{len(output_wires)}}`\n    work_wires (Sequence[int]): the auxiliary wires to use for the exponentiation. If\n        :math:`mod=2^{\\text{len(output_wires)}}`, the number of auxiliary wires must be ``len(output_wires)``. Otherwise\n        ``len(output_wires) + 2`` auxiliary wires are needed. Defaults to empty tuple.\n\n**Example**\n\nThis example performs the exponentiation of :math:`base=2` to the power :math:`x=3` modulo :math:`mod=7`.\n\n.. code-block:: python\n\n    x, b = 3, 1\n    base = 2\n    mod = 7\n\n    x_wires = [0, 1]\n    output_wires = [2, 3, 4]\n    work_wires = [5, 6, 7, 8, 9]\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.qnode(dev, shots=1)\n    def circuit():\n        qml.BasisEmbedding(x, wires = x_wires)\n        qml.BasisEmbedding(b, wires = output_wires)\n        qml.ModExp(x_wires, output_wires, base, mod, work_wires)\n        return qml.sample(wires = output_wires)\n\n>>> print(circuit())\n[[0 0 1]]\n\nThe result :math:`[0 0 1]`, is the binary representation of\n:math:`2^3 \\; \\text{modulo} \\; 7 = 1`.\n\n.. details::\n    :title: Usage Details\n\n    This template takes as input three different sets of wires.\n\n    The first one is ``x_wires`` which is used\n    to encode the integer :math:`x < mod` in the computational basis. Therefore, ``x_wires`` must contain at least\n    :math:`\\lceil \\log_2(x)\\rceil` wires to represent :math:`x`.\n\n    The second one is ``output_wires`` which is used\n    to encode the integer :math:`b \\cdot base^x \\; \\text{mod} \\; mod` in the computational basis. Therefore, at least\n    :math:`\\lceil \\log_2(mod)\\rceil` ``output_wires`` are required to represent :math:`b \\cdot base^x \\; \\text{mod} \\; mod`. Note that these wires can be initialized with any integer\n    :math:`b`, but the most common choice is :math:`b=1` to obtain as a final result :math:`base^x \\; \\text{mod} \\; mod`.\n\n    The third set of wires is ``work_wires`` which consist of the auxiliary qubits used to perform the modular exponentiation operation.\n\n    - If :math:`mod = 2^{\\text{len(output_wires)}}`,  the length of ``work_wires`` must be equal to the length of ``output_wires``.\n\n    - If :math:`mod \\neq 2^{\\text{len(output_wires)}}`, the length of ``work_wires`` must be ``len(output_wires) + 2``\n\n    Note that the ``ModExp`` template allows us to perform modular exponentiation in the computational basis. However if one just wants to perform standard exponentiation (with no modulo),\n    that would be equivalent to setting the modulo :math:`mod` to a large enough value to ensure that :math:`base^x < mod`.\n\n    Also, to perform the out-place modular exponentiation operator it is required that :math:`base` has inverse, :math:`base^{-1} \\; \\text{mod} \\; mod`. That means\n    :math:`base \\cdot base^{-1}` modulo :math:`mod` is equal to 1, which will only be possible if :math:`base` and\n    :math:`mod` are coprime. In other words, :math:`base` and :math:`mod` should not have any common factors other than 1."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.multiplier.Multiplier",
    "summary": "Performs the in-place modular multiplication operation.",
    "docstring": "Performs the in-place modular multiplication operation.\n\nThis operator performs the modular multiplication by an integer :math:`k` modulo :math:`mod` in\nthe computational basis:\n\n.. math::\n\n    \\text{Multiplier}(k,mod) |x \\rangle = | x \\cdot k \\; \\text{mod} \\; mod \\rangle.\n\nThe implementation is based on the quantum Fourier transform method presented in\n`arXiv:2311.08555 <https://arxiv.org/abs/2311.08555>`_.\n\n.. note::\n\n    To obtain the correct result, :math:`x` must be smaller than :math:`mod`. Also, it\n    is required that :math:`k` has modular inverse :math:`k^{-1}` with respect to :math:`mod`. That means\n    :math:`k \\cdot k^{-1}` modulo :math:`mod` is equal to 1, which will only be possible if :math:`k` and\n    :math:`mod` are coprime.\n\n.. seealso:: :class:`~.PhaseAdder` and :class:`~.OutMultiplier`.\n\nArgs:\n    k (int): the number that needs to be multiplied\n    x_wires (Sequence[int]): the wires the operation acts on. The number of wires must be enough for encoding `x` in the computational basis. The number of wires also limits the maximum value for `mod`.\n    mod (int): the modulo for performing the multiplication. If not provided, it will be set to its maximum value, :math:`2^{\\text{len(x_wires)}}`.\n    work_wires (Sequence[int]): the auxiliary wires to use for the multiplication. If :math:`mod=2^{\\text{len(x_wires)}}`, the number of auxiliary wires must be ``len(x_wires)``. Otherwise ``len(x_wires) + 2`` auxiliary wires are needed.\n\n**Example**\n\nThis example performs the multiplication of two integers :math:`x=3` and :math:`k=4` modulo :math:`mod=7`.\n\n.. code-block:: python\n\n    x = 3\n    k = 4\n    mod = 7\n\n    x_wires = [0,1,2]\n    work_wires = [3,4,5,6,7]\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.qnode(dev, shots=1)\n    def circuit():\n        qml.BasisEmbedding(x, wires=x_wires)\n        qml.Multiplier(k, x_wires, mod, work_wires)\n        return qml.sample(wires=x_wires)\n\n>>> print(circuit())\n[[1 0 1]]\n\nThe result :math:`[1 0 1]`, is the binary representation of\n:math:`3 \\cdot 4 \\; \\text{modulo} \\; 7 = 5`.\n\n.. details::\n    :title: Usage Details\n\n    This template takes as input two different sets of wires.\n\n    The first one is ``x_wires``, used to encode the integer :math:`x < \\text{mod}` in the Fourier basis.\n    To represent :math:`x`, ``x_wires`` must include at least :math:`\\lceil \\log_2(x) \\rceil` wires.\n    After the modular addition, the result can be as large as :math:`\\text{mod} - 1`,\n    requiring at least :math:`\\lceil \\log_2(\\text{mod}) \\rceil` wires. Since :math:`x < \\text{mod}`,\n    :math:`\\lceil \\log_2(\\text{mod}) \\rceil` is a sufficient length for ``x_wires`` to cover all possible inputs and outputs.\n\n    The second set of wires is ``work_wires`` which consist of the auxiliary qubits used to perform the modular multiplication operation.\n\n    - If :math:`mod = 2^{\\text{len(x_wires)}}`, the length of ``work_wires`` must be equal to the length of ``x_wires``.\n\n    - If :math:`mod \\neq 2^{\\text{len(x_wires)}}`, the length of ``work_wires`` must be ``len(x_wires) + 2``.\n\n    Note that the ``Multiplier`` template allows us to perform modular multiplication in the computational basis. However if one just want to perform standard multiplication (with no modulo),\n    that would be equivalent to setting the modulo :math:`mod` to a large enough value to ensure that :math:`x \\cdot k < mod`.\n\n    Also, to perform the in-place multiplication operator it is required that :math:`k` has inverse, :math:`k^{-1} \\; \\text{mod} \\; mod`. That means\n    :math:`k \\cdot k^{-1}` modulo :math:`mod` is equal to 1, which will only be possible if :math:`k` and\n    :math:`mod` are coprime. In other words, :math:`k` and :math:`mod` should not have any common factors other than 1."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.out_adder.OutAdder",
    "summary": "Performs the out-place modular addition operation.",
    "docstring": "Performs the out-place modular addition operation.\n\nThis operator performs the modular addition of two integers :math:`x` and :math:`y` modulo\n:math:`mod` in the computational basis:\n\n.. math::\n\n    \\text{OutAdder}(mod) |x \\rangle | y \\rangle | b \\rangle = |x \\rangle | y \\rangle | b+x+y \\; \\text{mod} \\; mod \\rangle,\n\nThe implementation is based on the quantum Fourier transform method presented in\n`arXiv:2311.08555 <https://arxiv.org/abs/2311.08555>`_.\n\n.. note::\n\n    To obtain the correct result, :math:`x`, :math:`y` and :math:`b` must be smaller than :math:`mod`.\n\n.. seealso:: :class:`~.PhaseAdder` and :class:`~.Adder`.\n\nArgs:\n    x_wires (Sequence[int]): the wires that store the integer :math:`x`\n    y_wires (Sequence[int]): the wires that store the integer :math:`y`\n    output_wires (Sequence[int]): the wires that store the addition result. If the register is in a non-zero state :math:`b`, the solution will be added to this value.\n    mod (int): the modulo for performing the addition. If not provided, it will be set to its maximum value, :math:`2^{\\text{len(output_wires)}}`.\n    work_wires (Sequence[int]): the auxiliary wires to use for the addition. The work wires are not needed if :math:`mod=2^{\\text{len(output_wires)}}`, otherwise two work wires should be provided. Defaults to empty tuple.\n\n**Example**\n\nThis example computes the sum of two integers :math:`x=5` and :math:`y=6` modulo :math:`mod=7`.\nWe'll let :math:`b=0`. See Usage Details for :math:`b \\neq 0`.\n\n.. code-block:: python\n\n    x=5\n    y=6\n    mod=7\n\n    x_wires=[0,1,2]\n    y_wires=[3,4,5]\n    output_wires=[7,8,9]\n    work_wires=[6,10]\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.qnode(dev, shots=1)\n    def circuit():\n        qml.BasisEmbedding(x, wires=x_wires)\n        qml.BasisEmbedding(y, wires=y_wires)\n        qml.OutAdder(x_wires, y_wires, output_wires, mod, work_wires)\n        return qml.sample(wires=output_wires)\n\n>>> print(circuit())\n[[1 0 0]]\n\nThe result :math:`[[1 0 0]]`, is the binary representation of\n:math:`5 + 6 \\; \\text{modulo} \\; 7 = 4`.\n\n.. details::\n    :title: Usage Details\n\n    This template takes as input four different sets of wires.\n\n    The first one is ``x_wires`` which is used\n    to encode the integer :math:`x < mod` in the computational basis. Therefore, ``x_wires`` must contain\n    at least :math:`\\lceil \\log_2(x)\\rceil` to represent :math:`x`.\n\n    The second one is ``y_wires`` which is used\n    to encode the integer :math:`y < mod` in the computational basis. Therefore, ``y_wires`` must contain\n    at least :math:`\\lceil \\log_2(y)\\rceil` wires to represent :math:`y`.\n\n    The third one is ``output_wires`` which is used\n    to encode the integer :math:`b+x+y \\; \\text{mod} \\; mod` in the computational basis. Therefore, it will require at least\n    :math:`\\lceil \\log_2(mod)\\rceil` ``output_wires`` to represent :math:`b+x+y \\; \\text{mod} \\; mod`. Note that these wires can be initialized with any integer\n    :math:`b < mod`, but the most common choice is :math:`b=0` to obtain as a final result :math:`x + y \\; \\text{mod} \\; mod`.\n    The following is an example for :math:`b = 1`.\n\n    .. code-block:: python\n\n        b=1\n        x=5\n        y=6\n        mod=7\n\n        x_wires=[0,1,2]\n        y_wires=[3,4,5]\n        output_wires=[7,8,9]\n        work_wires=[6,10]\n\n        dev = qml.device(\"default.qubit\")\n\n        @qml.qnode(dev, shots=1)\n        def circuit():\n            qml.BasisEmbedding(x, wires=x_wires)\n            qml.BasisEmbedding(y, wires=y_wires)\n            qml.BasisEmbedding(b, wires=output_wires)\n            qml.OutAdder(x_wires, y_wires, output_wires, mod, work_wires)\n            return qml.sample(wires=output_wires)\n\n    >>> print(circuit())\n    [[1 0 1]]\n\n    The result :math:`[[1 0 1]]`, is the binary representation of\n    :math:`5 + 6 + 1\\; \\text{modulo} \\; 7 = 5`.\n\n    The fourth set of wires is ``work_wires`` which consist of the auxiliary qubits used to perform the modular addition operation.\n\n    - If :math:`mod = 2^{\\text{len(output_wires)}}`, there will be no need for ``work_wires``, hence ``work_wires=None``. This is the case by default.\n\n    - If :math:`mod \\neq 2^{\\text{len(output_wires)}}`, two ``work_wires`` have to be provided.\n\n    Note that the ``OutAdder`` template allows us to perform modular addition in the computational basis. However if one just wants to perform standard addition (with no modulo),\n    that would be equivalent to setting the modulo :math:`mod` to a large enough value to ensure that :math:`x+k < mod`."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.out_multiplier.OutMultiplier",
    "summary": "Performs the out-place modular multiplication operation.",
    "docstring": "Performs the out-place modular multiplication operation.\n\nThis operator performs the modular multiplication of integers :math:`x` and :math:`y` modulo\n:math:`mod` in the computational basis:\n\n.. math::\n    \\text{OutMultiplier}(mod) |x \\rangle |y \\rangle |b \\rangle = |x \\rangle |y \\rangle |b + x \\cdot y \\; \\text{mod} \\; mod \\rangle,\n\nThe implementation is based on the quantum Fourier transform method presented in\n`arXiv:2311.08555 <https://arxiv.org/abs/2311.08555>`_.\n\n.. note::\n\n    To obtain the correct result, :math:`x`, :math:`y` and :math:`b` must be smaller than :math:`mod`.\n\n.. seealso:: :class:`~.PhaseAdder` and :class:`~.Multiplier`.\n\nArgs:\n    x_wires (Sequence[int]): the wires that store the integer :math:`x`\n    y_wires (Sequence[int]): the wires that store the integer :math:`y`\n    output_wires (Sequence[int]): the wires that store the multiplication result. If the register is in a non-zero state :math:`b`, the solution will be added to this value\n    mod (int): the modulo for performing the multiplication. If not provided, it will be set to its maximum value, :math:`2^{\\text{len(output_wires)}}`\n    work_wires (Sequence[int]): the auxiliary wires to use for the multiplication. The\n        work wires are not needed if :math:`mod=2^{\\text{len(output_wires)}}`, otherwise two work wires\n        should be provided. Defaults to empty tuple.\n\n**Example**\n\nThis example performs the multiplication of two integers :math:`x=2` and :math:`y=7` modulo :math:`mod=12`.\nWe'll let :math:`b=0`. See Usage Details for :math:`b \\neq 0`.\n\n.. code-block:: python\n\n    x = 2\n    y = 7\n    mod = 12\n\n    x_wires = [0, 1]\n    y_wires = [2, 3, 4]\n    output_wires = [6, 7, 8, 9]\n    work_wires = [5, 10]\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.qnode(dev, shots=1)\n    def circuit():\n        qml.BasisEmbedding(x, wires=x_wires)\n        qml.BasisEmbedding(y, wires=y_wires)\n        qml.OutMultiplier(x_wires, y_wires, output_wires, mod, work_wires)\n        return qml.sample(wires=output_wires)\n\n>>> print(circuit())\n[[0 0 1 0]]\n\nThe result :math:`[[0 0 1 0]]`, is the binary representation of\n:math:`2 \\cdot 7 \\; \\text{modulo} \\; 12 = 2`.\n\n.. details::\n    :title: Usage Details\n\n    This template takes as input four different sets of wires.\n\n    The first one is ``x_wires`` which is used\n    to encode the integer :math:`x < mod` in the computational basis. Therefore, ``x_wires`` must contain\n    at least :math:`\\lceil \\log_2(x)\\rceil` wires to represent :math:`x`.\n\n    The second one is ``y_wires`` which is used\n    to encode the integer :math:`y < mod` in the computational basis. Therefore, ``y_wires`` must contain\n    at least :math:`\\lceil \\log_2(y)\\rceil` wires to represent :math:`y`.\n\n    The third one is ``output_wires`` which is used\n    to encode the integer :math:`b+ x \\cdot y \\; \\text{mod} \\; mod` in the computational basis. Therefore, it will require at least\n    :math:`\\lceil \\log_2(mod)\\rceil` ``output_wires`` to represent :math:`b + x \\cdot y \\; \\text{mod} \\; mod`.  Note that these wires can be initialized with any integer\n    :math:`b < mod`, but the most common choice is :math:`b=0` to obtain as a final result :math:`x \\cdot y \\; \\text{mod} \\; mod`.\n    The following is an example for :math:`b = 1`.\n\n    .. code-block:: python\n\n        b = 1\n        x = 2\n        y = 7\n        mod = 12\n\n        x_wires = [0, 1]\n        y_wires = [2, 3, 4]\n        output_wires = [6, 7, 8, 9]\n        work_wires = [5, 10]\n\n        dev = qml.device(\"default.qubit\")\n\n        @qml.qnode(dev, shots=1)\n        def circuit():\n            qml.BasisEmbedding(x, wires=x_wires)\n            qml.BasisEmbedding(y, wires=y_wires)\n            qml.BasisEmbedding(b, wires=output_wires)\n            qml.OutMultiplier(x_wires, y_wires, output_wires, mod, work_wires)\n            return qml.sample(wires=output_wires)\n\n    >>> print(circuit())\n    [[0 0 1 1]]\n\n    The result :math:`[[0 0 1 1]]`, is the binary representation of\n    :math:`2 \\cdot 7 + 1\\; \\text{modulo} \\; 12 = 3`.\n\n    The fourth set of wires is ``work_wires`` which consist of the auxiliary qubits used to perform the modular multiplication operation.\n\n    - If :math:`mod = 2^{\\text{len(output_wires)}}`, there will be no need for ``work_wires``, hence ``work_wires=()``. This is the case by default.\n\n    - If :math:`mod \\neq 2^{\\text{len(output_wires)}}`, two ``work_wires`` have to be provided.\n\n    Note that the ``OutMultiplier`` template allows us to perform modular multiplication in the computational basis. However if one just wants to perform\n    standard multiplication (with no modulo), that would be equivalent to setting the modulo :math:`mod` to a large enough value to ensure that :math:`x \\cdot k < mod`."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.out_poly.OutPoly",
    "summary": "Performs the out-of-place polynomial operation.",
    "docstring": "Performs the out-of-place polynomial operation.\n\nGiven a function :math:`f(x_1, \\dots, x_m)` and an integer modulus :math:`mod`, this operator performs:\n\n.. math::\n\n    \\text{OutPoly}_{f, mod} |x_1 \\rangle \\dots |x_m \\rangle |0 \\rangle\n    = |x_1 \\rangle \\dots |x_m \\rangle |f(x_1, \\dots, x_m)\\, \\text{mod} \\; mod\\rangle,\n\nwhere the integer inputs :math:`x_i` are embedded in the ``input_registers``. The result of the\npolynomial function :math:`f(x_1, \\dots, x_m)` is computed modulo :math:`mod` in the computational\nbasis and stored in the ``output_wires``. If the output wires are not initialized to zero, the evaluated\nresult :math:`f(x_1, \\dots, x_m)\\ \\text{mod}\\ mod` will be added to the value initialized in the output register.\nThis implementation is based on the Section II-B of `arXiv:2112.10537 <https://arxiv.org/abs/2112.10537>`_.\n\n\n.. note::\n\n    The integer values :math:`x_i` stored in each input register must\n    be smaller than the modulus ``mod``.\n\nArgs:\n\n    polynomial_function (callable): The polynomial function to be applied. The number of arguments in the function\n        must be equal to the number of input registers.\n    input_registers (List[Union[Wires, Sequence[int]]]): List containing the wires (or the wire indices) used to\n        store each variable of the polynomial.\n    output_wires (Union[Wires, Sequence[int]]): The wires (or wire indices) used to store the output of the operation.\n    mod (int, optional): The integer for performing the modulo on the result of the polynomial operation. If not provided,\n        it defaults to :math:`2^{n}`, where :math:`n` is the number of qubits in the output register.\n    work_wires (Union[Wires, Sequence[int]], optional): The auxiliary wires to use for performing the polynomial operation.\n        The work wires are not needed if :math:`mod=2^{\\text{length(output_wires)}}`, otherwise two work wires should be\n        provided. Defaults to empty tuple.\n\nRaises:\n    ValueError: If `mod` is not :math:`2^{\\text{length(output_wires)}}` and insufficient number of work wires are provided.\n    ValueError: If the wires used in the input and output registers overlap.\n    ValueError: If the function is not defined with integer coefficients.\n\nExample:\n    Given a polynomial function :math:`f(x, y) = x^2 + y`,\n    we can calculate :math:`f(3, 2)` as follows:\n\n    .. code-block:: python\n\n        wires = qml.registers({\"x\": 2, \"y\": 2, \"output\": 4})\n\n        def f(x, y):\n            return x ** 2 + y\n\n        @qml.qnode(qml.device(\"default.qubit\"), shots=1)\n        def circuit():\n            # load values of x and y\n            qml.BasisEmbedding(3, wires=wires[\"x\"])\n            qml.BasisEmbedding(2, wires=wires[\"y\"])\n\n            # apply the polynomial\n            qml.OutPoly(\n                f,\n                input_registers = [wires[\"x\"], wires[\"y\"]],\n                output_wires = wires[\"output\"])\n\n            return qml.sample(wires=wires[\"output\"])\n\n    >>> print(circuit())\n    [[1 0 1 1]]\n\n    The result, :math:`[[1 0 1 1]]`, is the binary representation of :math:`3^2 + 2 = 11`.\n    Note that the default value of `mod` in this example is :math:`2^{\\text{len(output_wires)}} = 2^4 = 16`.\n    For more information on using `mod`, see the Usage Details section.\n\n.. seealso:: The decomposition of this operator consists of controlled :class:`~.PhaseAdder` gates.\n\n.. details::\n    :title: Usage Details\n\n    If the value of `mod` is not :math:`2^{\\text{length(output_wires)}}`, then two auxiliary qubits must be provided.\n\n    .. code-block:: python\n\n        x_wires = [0, 1, 2]\n        y_wires = [3, 4, 5]\n        input_registers = [x_wires, y_wires]\n\n        output_wires = [6, 7, 8]\n        work_wires = [9,10]\n\n\n        def f(x, y):\n            return x ** 2 + y\n\n        @qml.qnode(qml.device(\"default.qubit\"), shots=1)\n        def circuit():\n            # loading values for x and y\n            qml.BasisEmbedding(3, wires=x_wires)\n            qml.BasisEmbedding(2, wires=y_wires)\n            qml.BasisEmbedding(1, wires=output_wires)\n\n            # applying the polynomial\n            qml.OutPoly(\n                f,\n                input_registers,\n                output_wires,\n                mod = 7,\n                work_wires = work_wires\n            )\n\n            return qml.sample(wires=output_wires)\n\n    >>> print(circuit())\n    [[1 0 1]]\n\n    The result, :math:`[[1 0 1]]`, is the binary representation\n    of :math:`1 + f(3, 2) = 1 + 3^2 + 2  \\; \\text{mod} \\; 7 = 5`.\n    In this example ``output_wires`` is initialized to :math:`1`, so this value is added to the solution.\n    Generically, the expression is definded as:\n\n    .. math::\n\n        \\text{OutPoly}_{f, mod} |x_1 \\rangle \\dots |x_m \\rangle |b \\rangle\n        = |x_1 \\rangle \\dots |x_m \\rangle |b + f(x_1, \\dots, x_m) \\mod mod \\rangle."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.phase_adder.PhaseAdder",
    "summary": "Performs the in-place modular phase addition operation.",
    "docstring": "Performs the in-place modular phase addition operation.\n\nThis operator performs the modular addition by an integer :math:`k` modulo :math:`mod` in the\nFourier basis:\n\n.. math::\n\n    \\text{PhaseAdder}(k,mod) |\\phi (x) \\rangle = |\\phi (x+k \\; \\text{mod} \\; mod) \\rangle,\n\nwhere :math:`|\\phi (x) \\rangle` represents the :math:`| x \\rangle` state in the Fourier basis,\n\n.. math::\n\n    \\text{QFT} |x \\rangle = |\\phi (x) \\rangle.\n\nThe implementation is based on the quantum Fourier transform method presented in\n`arXiv:2311.08555 <https://arxiv.org/abs/2311.08555>`_.\n\n.. note::\n\n    To obtain the correct result, :math:`x` must be smaller than :math:`mod`. Also, when\n    :math:`mod \\neq 2^{\\text{len(x_wires)}}`, :math:`x` must satisfy :math:`x < 2^{\\text{len(x_wires)}-1}`,\n    which means that one extra wire in ``x_wires`` is required.\n\n.. seealso:: :class:`~.QFT` and :class:`~.Adder`.\n\nArgs:\n    k (int): the number that needs to be added\n    x_wires (Sequence[int]): the wires the operation acts on. The number of wires must be enough\n        for a binary representation of the value being targeted, :math:`x`. In some cases an additional\n        wire is needed, see usage details below. The number of wires also limits the maximum\n        value for ``mod``.\n    mod (int): the modulo for performing the addition. If not provided, it will be set to its maximum value, :math:`2^{\\text{len(x_wires)}}`.\n    work_wire (Sequence[int] or int): the auxiliary wire to use for the addition. Optional\n        when ``mod`` is :math:`2^{\\text{len(x_wires)}}`. Defaults to empty tuple. The work wire must\n        be in the :math:`|0\\rangle` state.\n\n**Example**\n\nThis example computes the sum of two integers :math:`x=8` and :math:`k=5` modulo :math:`mod=15`.\n\n.. code-block:: python\n\n    x = 8\n    k = 5\n    mod = 15\n\n    x_wires =[0,1,2,3]\n    work_wire=[5]\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.qnode(dev, shots=1)\n    def circuit():\n        qml.BasisEmbedding(x, wires=x_wires)\n        qml.QFT(wires=x_wires)\n        qml.PhaseAdder(k, x_wires, mod, work_wire)\n        qml.adjoint(qml.QFT)(wires=x_wires)\n        return qml.sample(wires=x_wires)\n\n>>> print(circuit())\n[[1 1 0 1]]\n\nThe result, :math:`[[1 1 0 1]]`, is the binary representation of\n:math:`8 + 5  \\; \\text{modulo} \\; 15 = 13`.\n\n.. details::\n    :title: Usage Details\n\n    This template takes as input two different sets of wires.\n\n    The first one is ``x_wires``, used to encode the integer :math:`x < \\text{mod}` in the Fourier basis.\n    To represent :math:`x`, at least :math:`\\lceil \\log_2(x) \\rceil` wires are needed.\n    After the modular addition, the result can be as large as :math:`\\text{mod} - 1`,\n    requiring at least :math:`\\lceil \\log_2(\\text{mod}) \\rceil` wires. Since :math:`x < \\text{mod}`, a length of\n    :math:`\\lceil \\log_2(\\text{mod}) \\rceil` is sufficient for ``x_wires`` to cover all possible inputs and\n    outputs when :math:`mod = 2^{\\text{len(x_wires)}}`.\n    An exception occurs when :math:`mod \\neq 2^{\\text{len(x_wires)}}`. In that case one extra wire in ``x_wires`` will be needed to correctly perform the phase\n    addition operation.\n\n    The second set of wires is ``work_wire`` which consist of the auxiliary qubit used to perform the modular phase addition operation.\n\n    - If :math:`mod = 2^{\\text{len(x_wires)}}`, there will be no need for ``work_wire``, hence ``work_wire=()``. This is the case by default.\n\n    - If :math:`mod \\neq 2^{\\text{len(x_wires)}}`, one ``work_wire`` has to be provided.\n\n    Note that the ``PhaseAdder`` template allows us to perform modular addition in the Fourier basis. However if one just wants to perform standard addition (with no modulo),\n    that would be equivalent to setting the modulo :math:`mod` to a large enough value to ensure that :math:`x+k < mod`."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.semi_adder.SemiAdder",
    "summary": "This operator performs the plain addition of two integers :math:`x` and :math:`y` in the computational basis:",
    "docstring": "This operator performs the plain addition of two integers :math:`x` and :math:`y` in the computational basis:\n\n.. math::\n\n    \\text{SemiAdder} |x \\rangle | y \\rangle = |x \\rangle | x + y  \\rangle,\n\nThis operation is also referred to as semi-out-place addition or quantum-quantum in-place addition in the literature.\n\nThe implementation is based on `arXiv:1709.06648 <https://arxiv.org/abs/1709.06648>`_.\n\nArgs:\n    x_wires (Sequence[int]): The wires that store the integer :math:`x`. The number of wires must be sufficient to\n        represent :math:`x` in binary.\n    y_wires (Sequence[int]): The wires that store the integer :math:`y`. The number of wires must be sufficient to\n        represent :math:`y` in binary. These wires are also used\n        to encode the integer :math:`x+y` which is computed modulo :math:`2^{\\text{len(y_wires)}}` in the computational basis.\n    work_wires (Optional(Sequence[int])): The auxiliary wires to use for the addition. At least, ``len(y_wires) - 1`` work\n        wires should be provided.\n\n**Example**\n\nThis example computes the sum of two integers :math:`x=3` and :math:`y=4`.\n\n.. code-block:: python\n\n    x = 3\n    y = 4\n\n    wires = qml.registers({\"x\":3, \"y\":6, \"work\":5})\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.set_shots(1)\n    @qml.qnode(dev)\n    def circuit():\n        qml.BasisEmbedding(x, wires=wires[\"x\"])\n        qml.BasisEmbedding(y, wires=wires[\"y\"])\n        qml.SemiAdder(wires[\"x\"], wires[\"y\"], wires[\"work\"])\n        return qml.sample(wires=wires[\"y\"])\n\n.. code-block:: pycon\n\n    >>> print(circuit())\n    [[0 0 0 1 1 1]]\n\nThe result :math:`[[0 0 0 1 1 1]]`, is the binary representation of :math:`3 + 4 = 7`.\n\nNote that the result is computed modulo :math:`2^{\\text{len(y_wires)}}` which makes the computed value dependent on the size of the ``y_wires`` register. This behavior is demonstrated in the following example.\n\n.. code-block:: python\n\n    x = 3\n    y = 1\n\n    wires = qml.registers({\"x\":3, \"y\":2, \"work\":1})\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.set_shots(1)\n    @qml.qnode(dev)\n    def circuit():\n        qml.BasisEmbedding(x, wires=wires[\"x\"])\n        qml.BasisEmbedding(y, wires=wires[\"y\"])\n        qml.SemiAdder(wires[\"x\"], wires[\"y\"], wires[\"work\"])\n        return qml.sample(wires=wires[\"y\"])\n\n>>> print(circuit())\n[[0 0]]\n\nThe result :math:`[0\\ 0]` is the binary representation of :math:`3 + 1 = 4` where :math:`4 \\mod 2^2 = 0`."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.arithmetic.temporary_and.TemporaryAND",
    "summary": "TemporaryAND(wires, control_values)",
    "docstring": "TemporaryAND(wires, control_values)\n\nThe ``TemporaryAND`` operation is a three-qubit gate equivalent to an ``AND``, or reversible :class:`~pennylane.Toffoli`, gate that leverages extra information\nabout the target wire to enable more efficient circuit decompositions. The ``TemporaryAND`` assumes the target qubit\nto be initialized in :math:`|0\\rangle`, while the ``Adjoint(TemporaryAND)`` assumes the target output to be :math:`|0\\rangle`.\nFor more details, see Fig. 4 in `arXiv:1805.03662 <https://arxiv.org/abs/1805.03662>`_.\n\n.. note::\n\n    For correct usage of this operation, the user must ensure\n    that before computation the input state of the target wire is :math:`|0\\rangle`,\n    and that after uncomputation the output state of the target wire is :math:`|0\\rangle`,\n    when using ``TemporaryAND`` or ``Adjoint(TemporaryAND)``, respectively.\n    Otherwise, behaviour may differ from the expected ``AND``.\n\n**Details:**\n\n* Number of wires: 3\n* Number of parameters: 0\n\nArgs:\n    wires (Sequence[int]): the subsystem the gate acts on. The first two wires are the control wires and the\n        third one is the target wire.\n    control_values (tuple[bool or int]): The values on the control wires for which\n        the target operator is applied. Integers other than 0 or 1 will be treated as ``int(bool(x))``.\n        Default is ``(1,1)``, corresponding to a traditional ``AND`` gate.\n\n\n.. seealso:: The alias :class:`~Elbow`.\n\n**Example**\n\n.. code-block:: python\n\n    @qml.set_shots(1)\n    @qml.qnode(qml.device(\"default.qubit\"))\n    def circuit():\n        # |0000\u27e9\n        qml.X(0) # |1000\u27e9\n        qml.X(1) # |1100\u27e9\n        # The target wire is in state |0>, so we can apply TemporaryAND\n        qml.TemporaryAND([0,1,2]) # |1110\u27e9\n        qml.CNOT([2,3]) # |1111\u27e9\n        # The target wire will be in state |0> after adjoint(TemporaryAND) gate is applied,\n        # so we can apply adjoint(TemporaryAND)\n        qml.adjoint(qml.TemporaryAND([0,1,2])) # |1101\u27e9\n        return qml.sample(wires=[0,1,2,3])\n\n>>> print(qml.draw(circuit)())\n0: \u2500\u2500X\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u2524 \u256dSample\n1: \u2500\u2500X\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u2524 \u251cSample\n2: \u2500\u2500\u2500\u2500\u2570\u2295\u2500\u256d\u25cf\u2500\u2500\u2295\u256f\u2500\u2524 \u251cSample\n3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2524 \u2570Sample\n>>> print(circuit())\n[[1 1 0 1]]"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.controlled_sequence.ControlledSequence",
    "summary": "Creates a sequence of controlled gates raised to decreasing powers of 2. Can be used as a sub-block in building a `quantum phase estimation <https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm>`__ circuit.",
    "docstring": "Creates a sequence of controlled gates raised to decreasing powers of 2. Can be used as\na sub-block in building a `quantum phase estimation <https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm>`__\ncircuit.\n\nGiven an :class:`~.Operator` and a list of control wires, this template creates a sequence of\ncontrolled gates, one for each control wire, with the base :class:`~.Operator` raised to\ndecreasing powers of 2:\n\n.. figure:: ../../_static/templates/subroutines/big_ctrl.png\n    :align: center\n    :width: 40%\n    :target: javascript:void(0);\n\nArgs:\n    base (Operator): the phase estimation unitary, specified as an :class:`~.Operator`\n    control (Union[Wires, Sequence[int], or int]): the wires to be used for control\n\nRaises:\n    ValueError: if the wires in ``control`` and wires on the ``base`` operator share a common\n        element\n\n.. seealso:: :class:`~.QuantumPhaseEstimation`\n\n**Example**\n\n.. code-block:: python\n\n    dev = qml.device(\"default.qubit\", wires = 4)\n\n    @qml.qnode(dev)\n    def circuit():\n\n        for i in range(3):\n            qml.Hadamard(wires = i)\n\n        qml.ControlledSequence(qml.RX(0.25, wires = 3), control = [0, 1, 2])\n\n        qml.adjoint(qml.QFT)(wires = range(3))\n\n        return qml.probs(wires = range(3))\n\n>>> print(circuit()) # doctest: +SKIP\n[0.9206 0.0264 0.0073 0.0042 0.0036 0.0042 0.0073 0.0264]"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.fable.FABLE",
    "summary": "Construct a unitary with the fast approximate block encoding method.",
    "docstring": "Construct a unitary with the fast approximate block encoding method.\n\nThe FABLE method allows to simplify block encoding circuits without reducing accuracy,\nfor matrices of specific structure [`arXiv:2205.00081 <https://arxiv.org/abs/2205.00081>`_].\n\n\nArgs:\n    input_matrix (tensor_like): a :math:`(2^n \\times 2^n)` matrix to be encoded,\n        where :math:`n` is an integer\n    wires (Iterable[int, str], Wires): the wires the operation acts on. The number of wires can\n        be computed as :math:`(2 \\times n + 1)`.\n    tol (float): rotation gates that have an angle value smaller than this tolerance are removed\n    id (str or None): string representing the operation (optional)\n\nRaises:\n    ValueError: if the number of wires doesn't fit the dimensions of the matrix\n\n**Example**\n\nWe can define a matrix and a block-encoding circuit as follows:\n\n.. code-block:: python\n\n    input_matrix = np.array([[0.1, 0.2],[0.3, -0.2]])\n    dev = qml.device('default.qubit', wires=3)\n    @qml.qnode(dev)\n    def example_circuit():\n        qml.FABLE(input_matrix, wires=range(3), tol=0)\n        return qml.state()\n\nWe can see that the input matrix has been block encoded in the matrix of the circuit:\n\n>>> s = int(np.ceil(np.log2(max(len(input_matrix), len(input_matrix[0])))))\n>>> expected = 2**s * qml.matrix(example_circuit)().real[0 : 2**s, 0 : 2**s]\n>>> print(f\"Block-encoded matrix:\\n{expected}\")\nBlock-encoded matrix:\n[[ 0.1  0.2]\n [ 0.3 -0.2]]\n\n.. note::\n    FABLE can be implemented for matrices of arbitrary shape and size.\n    When given a :math:`(N \\times M)` matrix, the matrix is padded with zeroes\n    until it is of :math:`(N \\times N)` dimension, where :math:`N` is equal to :math:`2^n`,\n    and :math:`n` is an integer. It is also assumed that the values\n    of the input matrix are within :math:`[-1, 1]`. Apply a subnormalization factor if needed."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.flip_sign.FlipSign",
    "summary": "Flips the sign of a given basis state.",
    "docstring": "Flips the sign of a given basis state.\n\nThis template performs the following operation:\n\nFlipSign(n) :math:`|m\\rangle = -|m\\rangle` if :math:`m = n`\n\nFlipSign(n) :math:`|m\\rangle = |m\\rangle` if :math:`m \\not = n`,\n\nwhere n is the basis state to flip and m is the input.\n\nArgs:\n    n (array[int] or int): binary array or integer value representing the state on which to flip the sign\n    wires (array[int] or int): wires that the template acts on\n\n**Example**\n\nThis template changes the sign of the basis state passed as an argument.\nIn this example, when passing the element ``[1, 0]``, we will change the sign of the state :math:`|10\\rangle`.\nWe could alternatively pass the integer ``2`` and get the same result since its binary representation is ``[1, 0]``.\n\n.. code-block:: python\n\n    num_wires = 2\n    dev = qml.device(\"default.qubit\", wires=num_wires)\n\n    @qml.qnode(dev)\n    def circuit():\n        for wire in range(num_wires):\n            qml.Hadamard(wire)\n        qml.FlipSign([1, 0], wires=range(num_wires))\n        return qml.state()\n\nThe result for the above circuit is:\n\n>>> circuit()\narray([ 0.5+0.j,  0.5+0.j, -0.5+0.j,  0.5+0.j])"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.gqsp.GQSP",
    "summary": "Implements the generalized quantum signal processing (GQSP) circuit.",
    "docstring": "Implements the generalized quantum signal processing (GQSP) circuit.\n\nThis operation encodes a polynomial transformation of an input unitary operator following the algorithm\ndescribed in `arXiv:2308.01501 <https://arxiv.org/abs/2308.01501>`__ as:\n\n.. math::\n     U\n     \\xrightarrow{GQSP}\n     \\begin{pmatrix}\n     \\text{poly}(U) & * \\\\\n     * & * \\\\\n     \\end{pmatrix}\n\nThe implementation requires one control qubit.\n\nArgs:\n\n    unitary (Operator): the operator to be encoded by the GQSP circuit\n    angles (tensor[float]): array of angles defining the polynomial transformation. The shape of the array must be `(3, d+1)`, where `d` is the degree of the polynomial.\n    control (Union[Wires, int, str]): control qubit used to encode the polynomial transformation\n\n.. note::\n\n   The  :func:`~.poly_to_angles` function can be used to calculate the angles for a given polynomial.\n\nExample:\n\n.. code-block:: python\n\n    # P(x) = 0.1 + 0.2j x + 0.3 x^2\n    poly = [0.1, 0.2j, 0.3]\n\n    angles = qml.poly_to_angles(poly, \"GQSP\")\n\n    @qml.prod # transforms the qfunc into an Operator\n    def unitary(wires):\n        qml.RX(0.3, wires)\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.qnode(dev)\n    def circuit(angles):\n        qml.GQSP(unitary(wires = 1), angles, control = 0)\n        return qml.state()\n\n    matrix = qml.matrix(circuit, wire_order=[0, 1])(angles)\n\n.. code-block:: pycon\n\n    >>> print(np.round(matrix,3)[:2, :2])\n    [[0.387+0.198j 0.03 -0.089j]\n    [0.03 -0.089j 0.387+0.198j]]"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.grover.GroverOperator",
    "summary": "Performs the Grover Diffusion Operator.",
    "docstring": "Performs the Grover Diffusion Operator.\n\n.. math::\n\n    G = 2 |s \\rangle \\langle s | - I\n    = H^{\\bigotimes n} \\left( 2 |0\\rangle \\langle 0| - I \\right) H^{\\bigotimes n}\n\nwhere :math:`n` is the number of wires, and :math:`|s\\rangle` is the uniform superposition:\n\n.. math::\n\n    |s\\rangle = H^{\\bigotimes n} |0\\rangle =  \\frac{1}{\\sqrt{2^n}} \\sum_{i=0}^{2^n-1} | i \\rangle.\n\nFor this template, the operator is implemented with a layer of Hadamards, a layer of :math:`X`,\nfollowed by a multi-controlled :math:`Z` gate, then another layer of :math:`X` and Hadamards.\nThis is expressed in a compact form by the circuit below:\n\n.. figure:: ../../_static/templates/subroutines/grover.svg\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\nThe open circles on the controlled gate indicate control on 0 instead of 1.\nThe ``Z`` gates on the last wire result from leveraging the circuit identity :math:`HXH = Z`,\nwhere the last ``H`` gate converts the multi-controlled :math:`Z` gate into a\nmulti-controlled :math:`X` gate.\n\nArgs:\n    wires (Union[Wires, Sequence[int], or int]): the wires to apply to\n    work_wires (Union[Wires, Sequence[int], or int]): optional auxiliary wires to assist\n        in the decomposition of :class:`~.MultiControlledX`.\n\n**Example**\n\nThe Grover Diffusion Operator amplifies the magnitude of the basis state with\na negative phase.  For example, if the solution to the search problem is the :math:`|111\\rangle`\nstate, we require an oracle that flips its phase; this could be implemented using a `CCZ` gate:\n\n.. code-block:: python\n\n    n_wires = 3\n    wires = list(range(n_wires))\n\n    def oracle():\n        qml.Hadamard(wires[-1])\n        qml.Toffoli(wires=wires)\n        qml.Hadamard(wires[-1])\n\nWe can then implement the entire Grover Search Algorithm for ``num_iterations`` iterations by alternating calls to the oracle and the diffusion operator:\n\n.. code-block:: python\n\n    dev = qml.device('default.qubit', wires=wires)\n\n    @qml.qnode(dev)\n    def GroverSearch(num_iterations=1):\n        for wire in wires:\n            qml.Hadamard(wire)\n\n        for _ in range(num_iterations):\n            oracle()\n            qml.templates.GroverOperator(wires=wires)\n        return qml.probs(wires)\n\n>>> GroverSearch(num_iterations=1) # doctest: +SKIP\narray([0.0312, 0.0312, 0.0312, 0.0312, 0.0312, 0.0312, 0.0312, 0.7812])\n>>> GroverSearch(num_iterations=2) # doctest: +SKIP\narray([0.0078, 0.0078, 0.0078, 0.0078, 0.0078, 0.0078, 0.0078, 0.9453])\n\nWe can see that the marked :math:`|111\\rangle` state has the greatest probability amplitude.\n\nOptimally, the oracle-operator pairing should be repeated :math:`\\lceil \\frac{\\pi}{4}\\sqrt{2^{n}} \\rceil` times."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.hilbert_schmidt.HilbertSchmidt",
    "summary": "Create a Hilbert-Schmidt template that can be used to compute the Hilbert-Schmidt Test (HST).",
    "docstring": "Create a Hilbert-Schmidt template that can be used to compute the Hilbert-Schmidt Test (HST).\n\nThe HST is a useful quantity to compile a target unitary `U` with an approximate unitary `V`. The HST\nis used as a distance between `U` and `V`. The result of executing the HST is 0 if and only if `V` is equal to\n`U` (up to a global phase). As suggested in [1], we can define a cost function using the Hilbert-Schmidt inner product\nbetween the unitaries `U` and `V` as follows:\n\n.. math::\n    C_{HST} = 1 - \\frac{1}{d^2} \\left|Tr(V^{\\dagger}U)\\right|^2,\n\nwhere `d` is the dimension of the space in which the unitaries `U` and `V` act.\nThe quantity :math:`\\frac{1}{d^2} \\left|Tr(V^{\\dagger}U)\\right|^2` is obtained by executing the Hilbert-Schmidt Test.\n\nIt is equivalent to taking the outcome probability of the state :math:`|0 ... 0\\rangle`\nfor the following circuit:\n\n.. figure:: ../../_static/templates/subroutines/hst.png\n    :align: center\n    :width: 80%\n    :target: javascript:void(0);\n\nIt defines our decomposition for the Hilbert-Schmidt Test template.\n\nArgs:\n    V (Operator or Iterable[Operator]): The operators that represent the unitary `V`.\n    U (Operator or Iterable[Operator]): The operators that represent the unitary `U`.\n    id (str or None): Optional identifier for the operation.\n\nRaises:\n    ValueError: ``V`` is not an Operator or an iterable of Operators.\n    ValueError: ``U`` is not an Operator or an iterable of Operators.\n    ValueError: ``U`` and ``V`` do not have the same number of wires.\n    ValueError: Operators in ``U`` must act on distinct wires from those in ``v_wires``.\n\n**Reference**\n\n[1] Sumeet Khatri, Ryan LaRose, Alexander Poremba, Lukasz Cincio, Andrew T. Sornborger and Patrick J. Coles\nQuantum-assisted Quantum Compiling.\n`arxiv/1807.00800 <https://arxiv.org/pdf/1807.00800.pdf>`_\n\n.. seealso:: :class:`~.LocalHilbertSchmidt`\n\n.. details::\n    :title: Usage Details\n\n    Consider that we want to evaluate the Hilbert-Schmidt Test cost between the unitary ``U`` and an approximate\n    unitary ``V``. If the approximate unitary has fewer wires than the target unitary, a placeholder identity can be included.\n    We need to define some functions where it is possible to use the :class:`~.HilbertSchmidt`\n    template. In the example below, the considered unitary is ``Hadamard`` and we try to compute the cost for the approximate\n    unitary ``RZ``. For an angle that is equal to ``0`` (``Identity``), we have the maximal cost, which is ``1``.\n\n    .. code-block:: python\n\n        U = qml.Hadamard(0)\n        V = qml.RZ(0, wires=1)\n\n        dev = qml.device(\"default.qubit\", wires=2)\n\n        @qml.qnode(dev)\n        def hilbert_test(V, U):\n            qml.HilbertSchmidt(V, U)\n            return qml.probs()\n\n        def cost_hst(V, U):\n            return 1 - hilbert_test(V, U)[0]\n\n    Now that the cost function has been defined it can be called as follows:\n\n    >>> cost_hst(V, U)\n    np.float64(1.0)"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.hilbert_schmidt.LocalHilbertSchmidt",
    "summary": "Create a Local Hilbert-Schmidt template that can be used to compute the Local Hilbert-Schmidt Test (LHST).",
    "docstring": "Create a Local Hilbert-Schmidt template that can be used to compute the Local Hilbert-Schmidt Test (LHST).\n\nThe result of the LHST is a useful quantity for compiling a unitary `U` with an approximate unitary `V`. The\nLHST is used as a distance between `U` and `V`. It is similar to the Hilbert-Schmidt test, but the measurement is\nmade only on one qubit at the end of the circuit. The LHST cost is always smaller than the HST cost and is useful\nfor large unitaries.\n\n.. figure:: ../../_static/templates/subroutines/lhst.png\n    :align: center\n    :width: 80%\n    :target: javascript:void(0);\n\nArgs:\n    V (Operator or Iterable[Operator]): The operators that represent the approximate compiled unitary `V`.\n    U (Operator or Iterable[Operator]): The operators that represent the unitary `U`.\n    id (str or None): Optional identifier for the operation.\n\nRaises:\n    ValueError: ``V`` is not an Operator or an iterable of Operators.\n    ValueError: ``U`` is not an Operator or an iterable of Operators.\n    ValueError: ``U`` and ``V`` do not have the same number of wires.\n    ValueError: Operators in ``U`` must act on distinct wires from those in ``v_wires``.\n\n**Reference**\n\n[1] Sumeet Khatri, Ryan LaRose, Alexander Poremba, Lukasz Cincio, Andrew T. Sornborger and Patrick J. Coles\nQuantum-assisted Quantum Compiling.\n`arxiv/1807.00800 <https://arxiv.org/pdf/1807.00800.pdf>`_\n\n.. seealso:: :class:`~.HilbertSchmidt`\n\n.. details::\n    :title: Usage Details\n\n    Consider that we want to evaluate the Local Hilbert-Schmidt Test cost between the unitary ``U`` and an\n    approximate unitary ``V``. We need to define some functions where it is possible to use the\n    :class:`~.LocalHilbertSchmidt` template. Here the considered unitary is ``CZ`` and we try to compute the\n    cost for the approximate unitary.\n\n    .. code-block:: python\n\n        import numpy as np\n\n        params = [3 * np.pi / 2, 3 * np.pi / 2, np.pi / 2]\n\n        U = qml.CZ(wires=(0, 1))\n\n        V = [qml.RZ(params[0], wires=2),\n            qml.RZ(params[1], wires=3),\n            qml.CNOT(wires=[2, 3]),\n            qml.RZ(params[2], wires=3),\n            qml.CNOT(wires=[2, 3])]\n\n        dev = qml.device(\"default.qubit\", wires=4)\n\n        @qml.qnode(dev)\n        def local_hilbert_test(V, U):\n            qml.LocalHilbertSchmidt(V, U)\n            return qml.probs()\n\n        def cost_lhst(V, U):\n            return 1 - local_hilbert_test(V, U)[0]\n\n    Now that the cost function has been defined it can be called for specific parameters:\n\n    >>> cost_lhst(V, U)\n    np.float64(0.5...)"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.interferometer.Interferometer",
    "summary": "General linear interferometer, an array of beamsplitters and phase shifters.",
    "docstring": "General linear interferometer, an array of beamsplitters and phase shifters.\n\nFor :math:`M` wires, the general interferometer is specified by\nproviding :math:`M(M-1)/2` transmittivity angles :math:`\\theta` and the same number of\nphase angles :math:`\\phi`, as well as :math:`M-1` additional rotation\nparameters :math:`\\varphi`.\n\nBy specifying the keyword argument ``mesh``, the scheme used to implement the interferometer\nmay be adjusted:\n\n* ``mesh='rectangular'`` (default): uses the scheme described in\n  `Clements et al. <https://dx.doi.org/10.1364/OPTICA.3.001460>`__, resulting in a *rectangular* array of\n  :math:`M(M-1)/2` beamsplitters arranged in :math:`M` slices and ordered from left\n  to right and top to bottom in each slice. The first beamsplitter acts on\n  wires :math:`0` and :math:`1`:\n\n  .. figure:: ../../_static/clements.png\n      :align: center\n      :width: 30%\n      :target: javascript:void(0);\n\n\n* ``mesh='triangular'``: uses the scheme described in `Reck et al. <https://dx.doi.org/10.1103/PhysRevLett.73.58>`__,\n  resulting in a *triangular* array of :math:`M(M-1)/2` beamsplitters arranged in\n  :math:`2M-3` slices and ordered from left to right and top to bottom. The\n  first and fourth beamsplitters act on wires :math:`M-1` and :math:`M`, the second\n  on :math:`M-2` and :math:`M-1`, and the third on :math:`M-3` and :math:`M-2`, and\n  so on.\n\n  .. figure:: ../../_static/reck.png\n      :align: center\n      :width: 30%\n      :target: javascript:void(0);\n\nIn both schemes, the network of :class:`~pennylane.ops.Beamsplitter` operations is followed by\n:math:`M` local :class:`~pennylane.ops.Rotation` Operations.\n\nThe rectangular decomposition is generally advantageous, as it has a lower\ncircuit depth (:math:`M` vs :math:`2M-3`) and optical depth than the triangular\ndecomposition, resulting in reduced optical loss.\n\nThis is an example of a 4-mode interferometer with beamsplitters :math:`B` and rotations :math:`R`,\nusing ``mesh='rectangular'``:\n\n.. figure:: ../../_static/layer_interferometer.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\n.. note::\n\n    The decomposition as formulated in `Clements et al. <https://dx.doi.org/10.1364/OPTICA.3.001460>`__ uses a different\n    convention for a beamsplitter :math:`T(\\theta, \\phi)` than PennyLane, namely:\n\n    .. math:: T(\\theta, \\phi) = BS(\\theta, 0) R(\\phi)\n\n    For the universality of the decomposition, the used convention is irrelevant, but\n    for a given set of angles the resulting interferometers will be different.\n\n    If an interferometer consistent with the convention from `Clements et al. <https://dx.doi.org/10.1364/OPTICA.3.001460>`__\n    is needed, the optional keyword argument ``beamsplitter='clements'`` can be specified. This\n    will result in each :class:`~pennylane.ops.Beamsplitter` being preceded by a :class:`~pennylane.ops.Rotation` and\n    thus increase the number of elementary operations in the circuit.\n\nArgs:\n    theta (tensor_like): size :math:`(M(M-1)/2,)` tensor of transmittivity angles :math:`\\theta`\n    phi (tensor_like): size :math:`(M(M-1)/2,)` tensor of phase angles :math:`\\phi`\n    varphi (tensor_like): size :math:`(M,)` tensor of rotation angles :math:`\\varphi`\n    wires (Iterable or Wires): Wires that the template acts on. Accepts an iterable of numbers or strings, or\n        a Wires object.\n    mesh (string): the type of mesh to use\n    beamsplitter (str): if ``clements``, the beamsplitter convention from\n      Clements et al. 2016 (https://dx.doi.org/10.1364/OPTICA.3.001460) is used; if ``pennylane``, the\n      beamsplitter is implemented via PennyLane's ``Beamsplitter`` operation.\n\nRaises:\n    ValueError: if inputs do not have the correct format\n\nExample:\n\n    The template requires :math:`3` sets of parameters. The ``mesh`` and ``beamsplitter`` keyword arguments are optional and\n    have ``'rectangular'`` and ``'pennylane'`` as default values.\n\n    .. code-block:: python\n\n        dev = qml.device('default.gaussian', wires=4)\n\n        @qml.qnode(dev)\n        def circuit(params):\n            qml.Interferometer(*params, wires=range(4))\n            return qml.expval(qml.Identity(0))\n\n        shapes = [[6, ], [6, ], [4, ]]\n        params = []\n        rng = np.random.default_rng(12345)\n        params = [rng.random(shape) for shape in shapes]\n\n    Using these random parameters, the resulting circuit is:\n\n    >>> print(qml.draw(circuit, level=\"device\")(params))\n    0: \u2500\u256dBS(0.23,0.60)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dBS(0.68,0.94)\u2500\u2500R(0.67)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <I>\n    1: \u2500\u2570BS(0.23,0.60)\u2500\u256dBS(0.80,0.67)\u2500\u2570BS(0.68,0.94)\u2500\u256dBS(0.33,0.95)\u2500\u2500R(0.10)\u2500\u2524\n    2: \u2500\u256dBS(0.32,0.19)\u2500\u2570BS(0.80,0.67)\u2500\u256dBS(0.39,0.25)\u2500\u2570BS(0.33,0.95)\u2500\u2500R(0.44)\u2500\u2524\n    3: \u2500\u2570BS(0.32,0.19)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570BS(0.39,0.25)\u2500\u2500R(0.89)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n    Using different values for optional arguments:\n\n    .. code-block:: python\n\n        @qml.qnode(dev)\n        def circuit(params):\n            qml.Interferometer(*params, wires=range(4), mesh='triangular', beamsplitter='clements')\n            return qml.expval(qml.Identity(0))\n\n        shapes = [[6, ], [6, ], [4, ]]\n        params = []\n        for shape in shapes:\n            params.append(np.random.random(shape))\n\n        print(qml.draw(circuit, level=\"device\")(params))\n\n    .. code-block::\n\n        0: \u2500\u2500R(0.71)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dBS(0.07,0.00)\u2500\u2500R(0.36)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        1: \u2500\u2500R(0.82)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dBS(0.80,0.00)\u2500\u2570BS(0.07,0.00)\u2500\u2500R(0.77)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dBS(0.77,0.00)\u2500\u2500R(0.12)\n        2: \u2500\u2500R(0.01)\u2500\u256dBS(0.14,0.00)\u2500\u2570BS(0.80,0.00)\u2500\u2500R(0.73)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dBS(0.99,0.00)\u2500\u2570BS(0.77,0.00)\u2500\u2500R(0.07)\n        3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570BS(0.14,0.00)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570BS(0.99,0.00)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <I>\n        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2500\u2500\u256dBS(0.20,0.00)\u2500\u2500R(0.86)\u2500\u2524\n        \u2500\u2500\u2570BS(0.20,0.00)\u2500\u2500R(0.62)\u2500\u2524"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.permute.Permute",
    "summary": "Applies a permutation to a set of wires.",
    "docstring": "Applies a permutation to a set of wires.\n\nArgs:\n    permutation (Sequence): A list of wire labels that represents the new ordering of wires\n        after the permutation. The list may consist of integers or strings, so long as\n        they match the labels of ``wires``.\n    wires (Iterable or Wires): Wires that the permutation acts on. Accepts an iterable\n        of numbers or strings, or a Wires object.\n\nRaises:\n    ValueError: if inputs do not have the correct format\n\n**Example**\n\n.. code-block:: python\n\n    import pennylane as qml\n\n    dev = qml.device('default.qubit', wires=5)\n\n    @qml.qnode(dev)\n    def apply_perm():\n        # Send contents of wire 4 to wire 0, of wire 2 to wire 1, etc.\n        qml.templates.Permute([4, 2, 0, 1, 3], wires=dev.wires)\n        return qml.expval(qml.Z(0))\n\nSee \"Usage Details\" for further examples.\n\n.. details::\n    :title: Usage Details\n\n    As a simple example, suppose we have a 4-qubit device with wires labeled\n    by the integers ``[0, 1, 2, 3]``. We apply a permutation to shuffle the\n    order to ``[3, 2, 0, 1]`` (i.e., the qubit state that was previously on\n    wire 3 is now on wire 0, the one from 2 is on wire 1, etc.).\n\n    .. code-block:: python\n\n        dev = qml.device('default.qubit', wires=4)\n\n        @qml.qnode(dev)\n        def apply_perm():\n            qml.Permute([3, 2, 0, 1], dev.wires)\n            return qml.expval(qml.Z(0))\n\n    >>> print(qml.draw(apply_perm, level=\"device\")())\n    0: \u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <Z>\n    1: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    2: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u256dSWAP\u2500\u2524\n    3: \u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u2524\n\n    ``Permute`` can also be used with quantum tapes. For example, suppose we\n    have a tape with 5 wires ``[0, 1, 2, 3, 4]``, and we'd like to reorder them\n    so that wire 4 is moved to the location of wire 0, wire 2 is moved to the\n    original location of wire 1, and so on.\n\n    .. code-block:: python\n\n        import pennylane as qml\n\n        op = qml.Permute([4, 2, 0, 1, 3], wires=[0, 1, 2, 3, 4])\n        tape = qml.tape.QuantumTape([op])\n\n    >>> [tape_expanded], _ = qml.transforms.decompose(tape, gate_set={qml.SWAP})\n    >>> print(qml.drawer.tape_text(tape_expanded, wire_order=range(5)))\n    0: \u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    1: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    2: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    3: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2524\n    4: \u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u2570SWAP\u2500\u2524\n\n    ``Permute`` can also be applied to wires with arbitrary labels, like so:\n\n    .. code-block:: python\n\n        wire_labels = [3, 2, \"a\", 0, \"c\"]\n\n        dev = qml.device('default.qubit', wires=wire_labels)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.Permute([\"c\", 3,\"a\",2,0], wires=wire_labels)\n            return qml.expval(qml.Z(\"c\"))\n\n    The permuted circuit is:\n\n    >>> print(qml.draw(circuit, level=\"device\")())\n    3: \u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    2: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    0: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2524\n    c: \u2500\u2570SWAP\u2500\u2570SWAP\u2500\u2570SWAP\u2500\u2524  <Z>\n\n    It is also possible to permute a subset of wires by\n    specifying a subset of labels. For example,\n\n    .. code-block:: python\n\n        wire_labels = [3, 2, \"a\", 0, \"c\"]\n\n        dev = qml.device('default.qubit', wires=wire_labels)\n\n        @qml.qnode(dev)\n        def circuit():\n            # Only permute the order of 3 of them\n            qml.Permute([\"c\", 2, 0], wires=[2, 0, \"c\"])\n            return qml.expval(qml.Z(\"c\"))\n\n    will permute only the second, third, and fifth wires as follows:\n\n    >>> print(qml.draw(circuit, level=\"device\", show_all_wires=True)())\n    3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    2: \u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    a: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    0: \u2500\u2502\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2524\n    c: \u2500\u2570SWAP\u2500\u2570SWAP\u2500\u2524  <Z>"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.prepselprep.PrepSelPrep",
    "summary": "Implements a block-encoding of a linear combination of unitaries.",
    "docstring": "Implements a block-encoding of a linear combination of unitaries.\n\n.. warning::\n    Derivatives of this operator are not always guaranteed to exist.\n\nArgs:\n    lcu (Union[.Hamiltonian, .Sum, .Prod, .SProd, .LinearCombination]): The operator\n        written as a linear combination of unitaries.\n    control (Iterable[Any], Wires): The control qubits for the PrepSelPrep operator.\n\n**Example**\n\nWe define an operator and a block-encoding circuit as:\n\n>>> lcu = qml.dot([0.3, -0.1], [qml.X(2), qml.Z(2)])\n>>> control = [0, 1]\n>>> @qml.qnode(qml.device(\"default.qubit\"))\n... def circuit(lcu, control):\n...     qml.PrepSelPrep(lcu, control)\n...     return qml.state()\n\nWe can see that the operator matrix, up to a normalization constant, is block encoded in the\ncircuit matrix:\n\n>>> matrix_psp = qml.matrix(circuit, wire_order = [0, 1, 2])(lcu, control = control)\n>>> print(matrix_psp.real[0:2, 0:2])\n[[-0.25  0.75]\n [ 0.75  0.25]]\n\n>>> matrix_lcu = qml.matrix(lcu)\n>>> print(qml.matrix(lcu).real / sum(abs(np.array(lcu.terms()[0]))))\n[[-0.25  0.75]\n [ 0.75  0.25]]"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qchem.all_singles_doubles.AllSinglesDoubles",
    "summary": "Builds a quantum circuit to prepare correlated states of molecules by applying all :class:`~.pennylane.SingleExcitation` and :class:`~.pennylane.DoubleExcitation` operations to the initial Hartree-Fock state.",
    "docstring": "Builds a quantum circuit to prepare correlated states of molecules\nby applying all :class:`~.pennylane.SingleExcitation` and\n:class:`~.pennylane.DoubleExcitation` operations to\nthe initial Hartree-Fock state.\n\nThe template initializes the :math:`n`-qubit system to encode\nthe input Hartree-Fock state and applies the particle-conserving\n:class:`~.pennylane.SingleExcitation` and\n:class:`~.pennylane.DoubleExcitation` operations which are implemented as\n`Givens rotations <https://en.wikipedia.org/wiki/Givens_rotation>`_ that act\non the subspace of two and four qubits, respectively. The total number of\nexcitation gates and the indices of the qubits they act on are obtained\nusing the :func:`~.excitations` function.\n\nFor example, the quantum circuit for the case of two electrons and six qubits\nis sketched in the figure below:\n\n|\n\n.. figure:: ../../_static/templates/subroutines/all_singles_doubles.png\n    :align: center\n    :width: 70%\n    :target: javascript:void(0);\n\n|\n\nIn this case, we have four single and double excitations that preserve the total-spin\nprojection of the Hartree-Fock state. The :class:`~.pennylane.SingleExcitation` gate\n:math:`G` act on the qubits ``[0, 2], [0, 4], [1, 3], [1, 5]`` as indicated by the\nsquares, while the :class:`~.pennylane.DoubleExcitation` operation :math:`G^{(2)}` is\napplied to the qubits ``[0, 1, 2, 3], [0, 1, 2, 5], [0, 1, 2, 4], [0, 1, 4, 5]``.\n\nThe resulting unitary conserves the number of particles and prepares the\n:math:`n`-qubit system in a superposition of the initial Hartree-Fock state and\nother states encoding multiply-excited configurations.\n\nArgs:\n    weights (tensor_like): size ``(len(singles) + len(doubles),)`` tensor containing the\n        angles entering the :class:`~.pennylane.SingleExcitation` and\n        :class:`~.pennylane.DoubleExcitation` operations, in that order\n    wires (Iterable): wires that the template acts on\n    hf_state (array[int]): Length ``len(wires)`` occupation-number vector representing the\n        Hartree-Fock state. ``hf_state`` is used to initialize the wires.\n    singles (Sequence[Sequence]): sequence of lists with the indices of the two qubits\n        the :class:`~.pennylane.SingleExcitation` operations act on\n    doubles (Sequence[Sequence]): sequence of lists with the indices of the four qubits\n        the :class:`~.pennylane.DoubleExcitation` operations act on\n\n.. details::\n    :title: Usage Details\n\n    Notice that:\n\n    #. The number of wires has to be equal to the number of spin orbitals included in\n       the active space.\n\n    #. The single and double excitations can be generated with the function\n       :func:`~.excitations`. See example below.\n\n    An example of how to use this template is shown below:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        import numpy as np\n\n        electrons = 2\n        qubits = 4\n\n        # Define the HF state\n        hf_state = qml.qchem.hf_state(electrons, qubits)\n\n        # Generate all single and double excitations\n        singles, doubles = qml.qchem.excitations(electrons, qubits)\n\n        # Define the device\n        dev = qml.device('default.qubit', wires=qubits)\n\n        wires = range(qubits)\n\n        @qml.qnode(dev)\n        def circuit(weights, hf_state, singles, doubles):\n            qml.templates.AllSinglesDoubles(weights, wires, hf_state, singles, doubles)\n            return qml.expval(qml.Z(0))\n\n        # Evaluate the QNode for a given set of parameters\n        params = np.random.normal(0, np.pi, len(singles) + len(doubles))\n        circuit(params, hf_state, singles=singles, doubles=doubles)"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qchem.basis_rotation.BasisRotation",
    "summary": "Implements a circuit that performs an exact single-body basis rotation using Givens rotations and phase shifts.",
    "docstring": "Implements a circuit that performs an exact single-body basis rotation using Givens\nrotations and phase shifts.\n\nThe :class:`~.BasisRotation` template performs the following unitary transformation\n:math:`U(u)` determined by the single-particle fermionic\ngenerators as given in `arXiv:1711.04789 <https://arxiv.org/abs/1711.04789>`_\\ :\n\n.. math::\n\n    U(u) = \\exp{\\left( \\sum_{pq} \\left[\\log u \\right]_{pq} (a_p^\\dagger a_q - a_q^\\dagger a_p) \\right)}.\n\nThe unitary :math:`U(u)` is implemented efficiently by performing its Givens decomposition into a sequence of\n:class:`~.PhaseShift` and :class:`~.SingleExcitation` gates using the construction scheme given in\n`Optica, 3, 1460 (2016) <https://opg.optica.org/optica/fulltext.cfm?uri=optica-3-12-1460&id=355743>`_\\ .\nFor real-valued, i.e., orthogonal :math:`u`, only ``SingleExcitation`` gates are required,\nexcept for a :class:`~.PauliZ` phase flip for :math:`\\operatorname{det}(u)=-1`.\nThis can be expressed concisely by applying ``PhaseShift((1-det(u)) * \u03c0 / 2)``.\n\n.. seealso:: :func:`~.math.decomposition.givens_decomposition` for the underlying matrix factorization.\n\nArgs:\n    wires (Iterable[Any]): wires that the operator acts on\n    unitary_matrix (array): matrix specifying the basis transformation\n    check (bool): test unitarity of the provided `unitary_matrix`\n\nRaises:\n    ValueError: if the provided matrix is not square.\n    ValueError: if length of the wires is less than two.\n\n.. details::\n    :title: Usage Details\n    :href: usage-basis-rotation\n\n    The :class:`~.pennylane.BasisRotation` template can be used to implement the evolution :math:`e^{iH}` where\n    :math:`H = \\sum_{pq} V_{pq} a^\\dagger_p a_q` and :math:`V` is an :math:`N \\times N` Hermitian matrix.\n    When the unitary matrix :math:`u` is the transformation matrix that diagonalizes :math:`V`, the evolution is:\n\n    .. math::\n\n        e^{i \\sum_{pq} V_{pq} a^\\dagger_p a_q} = U(u)^\\dagger \\prod_k e^{i\\lambda_k \\sigma_z^k} U(u),\n\n    where :math:`\\lambda_k` denotes the eigenvalues of matrix :math:`V`, the Hamiltonian coefficients matrix.\n\n    >>> V = np.array([[ 0.53672126+0.j        , -0.1126064 -2.41479668j],\n    ...               [-0.1126064 +2.41479668j,  1.48694623+0.j        ]])\n    >>> eigen_vals, eigen_vecs = np.linalg.eigh(V)\n    >>> umat = eigen_vecs.T\n    >>> wires = range(len(umat))\n    >>> def circuit():\n    ...    qml.adjoint(qml.BasisRotation(wires=wires, unitary_matrix=umat))\n    ...    for idx, eigenval in enumerate(eigen_vals):\n    ...        qml.RZ(eigenval, wires=[idx])\n    ...    qml.BasisRotation(wires=wires, unitary_matrix=umat)\n    >>> circ_unitary = qml.matrix(circuit, wire_order=wires)()\n    >>> np.round(circ_unitary/circ_unitary[0][0], 3)\n    array([[ 1.   -0.j   , -0.   +0.j   , -0.   +0.j   , -0.   +0.j   ],\n           [-0.   +0.j   , -0.516-0.596j, -0.302-0.536j, -0.   +0.j   ],\n           [-0.   +0.j   ,  0.35 +0.506j, -0.311-0.724j, -0.   +0.j   ],\n           [-0.   +0.j   , -0.   +0.j   , -0.   +0.j   , -0.438+0.899j]])\n\n    The ``BasisRotation`` is implemented with :class:`~.PhaseShift` and\n    :class:`~.SingleExcitation` gates:\n\n    >>> print(qml.draw(qml.BasisRotation(wires=wires, unitary_matrix=umat).decomposition)())\n    0: \u2500\u2500R\u03d5(-1.52)\u2500\u256dG(1.38)\u2500\u2500R\u03d5(-1.62)\u2500\u2524\n    1: \u2500\u2500R\u03d5(1.62)\u2500\u2500\u2570G(1.38)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n    For real-valued matrices, the decomposition only consists of ``SingleExcitation`` gates,\n    except for one phase gate to account for negative determinants:\n\n    >>> from scipy.stats import ortho_group\n    >>> O = ortho_group.rvs(4, random_state=51)\n    >>> print(qml.draw(qml.BasisRotation(wires=range(4), unitary_matrix=O).decomposition)())\n    0: \u2500\u2500R\u03d5(3.14)\u2500\u256dG(-3.19)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dG(2.63)\u2500\u2524\n    1: \u2500\u256dG(-3.13)\u2500\u2570G(-3.19)\u2500\u256dG(2.68)\u2500\u2570G(2.63)\u2500\u2524\n    2: \u2500\u2570G(-3.13)\u2500\u256dG(-2.98)\u2500\u2570G(2.68)\u2500\u256dG(5.70)\u2500\u2524\n    3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570G(-2.98)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570G(5.70)\u2500\u2524\n\n.. details::\n    :title: Theory\n    :href: theory-basis-rotation\n\n    The basis rotation performed by ``BasisRotation`` implements a transformation\n    in the qubit Hilbert space that corresponds to a simple basis change of\n    fermionic creation operators, translated to qubits via the Jordan-Wigner mapping.\n    The old fermionic creation operators :math:`a_p^\\dagger` and the new creation\n    operators :math:`b_p^\\dagger` are related to each other by the following equation:\n\n    .. math::\n\n        b_p^\\dagger = \\sum_{q}u_{pq} a_q^\\dagger.\n\n    The effect of :math:`U(u)`, the rotation in qubit Hilbert space, is then\n\n    .. math::\n\n        U(u) A_p^\\dagger U(u)^\\dagger = B_p^\\dagger,\n\n    where :math:`A_p^\\dagger` and :math:`B_p^\\dagger` are the original and transformed\n    creation operators under the Jordan-Wigner transformation, respectively.\n\n    **Underlying matrix factorization**\n\n    The rotation is irreducibly represented as a unitary :math:`N\\times N` matrix :math:`u`,\n    which can be factorized into nearest-neighbour Givens rotations and individual phase\n    shifts. Such a factorization of :math:`u` is implemented\n    in :func:`~.math.decomposition.givens_decomposition`.\n\n    The Givens rotations take the form\n\n    .. math::\n\n        T_{k}(\\theta) = \\begin{pmatrix}\n            1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 & 0 \\\\\n            0 & 1 & & & & & 0 & 0 \\\\\n            \\vdots & & \\ddots & & & & & \\vdots \\\\\n            0 & & & \\cos(\\theta) & -\\sin(\\theta) & & & 0 \\\\\n            0 & & & \\sin(\\theta) & \\cos(\\theta) & & & 0 \\\\\n            \\vdots & & & & & \\ddots & & \\vdots \\\\\n            0 & 0 & & & & & 1 & 0 \\\\\n            0 & 0 & \\cdots & 0 & 0  & \\cdots & 0 & 1 \\\\\n        \\end{pmatrix},\n\n    where the four non-trivial entries are at indices :math:`k` and :math:`k+1`.\n    It will also be useful to look at the generator of :math:`T_{k}`:\n\n    .. math::\n\n        T_k(\\theta) = \\exp(\\theta E_{k,k+1}),\n\n    where :math:`E_{k,\\ell}` is a matrix that is zero everywhere except for a\n    :math:`-1` in position :math:`(k,\\ell)` and a :math:`1` in position :math:`(\\ell,k)`.\n    The phase shifts in the decomposition read\n\n    .. math::\n\n        P_{j}(\\phi) = \\operatorname{diag}(1,\\cdots, 1, e^{i\\phi}, 1, \\cdots, 1),\n\n    with the single non-trivial entry at index :math:`j`.\n    Such a phase shift is generated in the following form:\n\n    .. math::\n\n        P_j(\\phi) = \\exp(i \\phi D_{j}),\n\n    where :math:`D_j` is zero everywhere except for a :math:`1` in position :math:`(j,j)`.\n\n    Next, we consider multiple Lie algebras generated by the :math:`E_{k,k+1}` and :math:`D_j`,\n    and in particular the full Lie algebra :math:`\\mathfrak{g}` generated by all of them:\n\n    .. math::\n\n        \\langle\\{E_{k,k+1}\\}_k\\rangle_\\text{Lie} &= \\text{span}_{\\mathbb{R}}\\{E_{k,\\ell} | 1\\leq k<\\ell\\leq N\\}\\cong\\mathfrak{so}(N)\\\\\n        \\langle\\{D_{j}\\}_j\\rangle_\\text{Lie} &= \\text{span}_{\\mathbb{R}}\\{D_{j} | 1\\leq j\\leq N\\}\\cong\\mathfrak{u}(1)^N\\\\\n        \\mathfrak{g}=\\langle\\{D_{j}\\}_j\\cup\\{E_{k,k+1}\\}_k\\rangle_\\text{Lie}\n        &=\\text{span}_{\\mathbb{R}}\\left(\\{E_{k,\\ell}, F_{k,\\ell}| 1\\leq k<\\ell \\leq N\\}\\cup\\{D_{j}\\}_j\\right)\n        \\cong \\mathfrak{u}(N).\n\n    The full algebra :math:`\\mathfrak{g}` contains the matrices :math:`F_{k,\\ell}` that\n    look like the matrices :math:`E_{k,\\ell}`, but without any\n    minus sign. There are ``N(N-1) / 2`` matrices :math:`E` and :math:`F` each,\n    and ``N`` matrices :math:`D`. So that all taken together span the\n    :math:`N^2`-dimensional algebra :math:`\\mathfrak{u}(N)`.\n\n    **Mapping the matrix factorization to a circuit**\n\n    The factorization of :math:`u` can be mapped to a quantum circuit by identifying:\n\n    .. math::\n\n        T_{k}(\\theta) &\\mapsto \\texttt{SingleExcitation}(2\\theta,\\texttt{wires=[k, k+1]}),\\\\\n        P_{j}(\\phi) &\\mapsto \\texttt{PhaseShift}(\\phi, \\texttt{wires=[j]}).\n\n    This identification is a group homomorphism, which is proven in\n    `arXiv:1711.04789 <https://arxiv.org/abs/1711.04789>`_. We can understand this\n    by looking at the algebra to which this mapping sends the algebra :math:`\\mathfrak{g}`\n    from above.\n    The ``SingleExcitation`` gates have the generators\n    :math:`\\hat{E}_{k,k+1}=\\tfrac{i}{2}(X_k Y_{k+1} - Y_k X_{k+1})`\n    (note the additional prefactor of :math:`2` from the mapping):\n\n    >>> qml.generator(qml.SingleExcitation(0.2512, [0, 1]))\n    (X(0) @ Y(1) + -1.0 * (Y(0) @ X(1)), np.float64(0.25))\n\n    Similarly, the ``PhaseShift`` gates have the generators\n    :math:`\\hat{D}_j=\\tfrac{i}{2}(\\mathbb{I}-Z_j)=i|1\\rangle\\langle 1|_j`:\n\n    >>> qml.generator(qml.PhaseShift(0.742, [0]))\n    (Projector(array([1]), wires=[0]), 1.0)\n\n    It turns out that these generators :math:`\\hat{E}_{k,k+1}` and :math:`\\hat{D}_j`\n    have commutation relations equivalent to those of\n    the irreducible matrices above, with a crucial feature in how the identification\n    :math:`E_{k,k+1}\\mapsto \\hat{E}_{k,k+1}` generalizes.\n    One could try to map, say, :math:`E_{2, 4}` to :math:`\\tfrac{i}{2}(X_2 Y_4 -Y_2 X_4)`,\n    but this will not be consistent with the operators and commutation relations in the\n    algebra. Instead, we need to insert strings of Pauli :math:`Z` operators whenever the\n    interaction encoded by the generator is not between nearest neighbours, so that\n    :math:`E_{2,4}` maps to :math:`\\tfrac{i}{2}(X_2 Z_3 Y_4 -Y_2 Z_3 X_4)`,\n    which we also denote as :math:`\\tfrac{i}{2}(\\overline{X_2 Y_4} -\\overline{Y_2 X_4})`.\n    Then we have\n\n    .. math::\n\n        E_{k,\\ell} & \\mapsto \\hat{E}_{k,\\ell} = \\tfrac{i}{2}(\\overline{X_kY_\\ell}-\\overline{Y_kX_\\ell}),\\\\\n        F_{k,\\ell} & \\mapsto \\hat{F}_{k,\\ell} = \\tfrac{i}{2}(\\overline{X_kX_\\ell}+\\overline{Y_kY_\\ell}),\\\\\n        D_{j} & \\mapsto \\hat{D}_{j} = \\tfrac{i}{2}(\\mathbb{I}-Z_j).\n\n    The fact that we need to use :math:`\\overline{X_kY_\\ell}` instead of :math:`X_kY_\\ell`\n    is a consequence of mapping fermions onto qubits via the Jordan-Wigner transformation.\n    Depending on the application, the relative signs between operators in this mapping need\n    to be evaluated with extra care.\n\n    **Real rotation matrices**\n\n    It is common for the orbital rotation matrix implemented by ``BasisRotation`` to be\n    real-valued and thus orthogonal. The generators :math:`E_{k,k+1}` generate the Lie\n    algebra :math:`\\mathfrak{so}(N)`, which means that the Givens rotations\n    :math:`T_k` are sufficient to factorize the full rotation, and only ``SingleExcitation``\n    gates are needed in the quantum circuit. A small exception occurs for orthogonal matrices\n    that are not *special* orthogonal (unit determinant), i.e., that have\n    determinant :math:`-1`. For those, the sign of one row or column of the matrix can be\n    inverted, corresponding to a phase flip gate :class:`~.PauliZ` in the circuit.\n    The new matrix then has a unit determinant and can be\n    implemented exclusively with ``SingleExcitation`` gates."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qchem.fermionic_double_excitation.FermionicDoubleExcitation",
    "summary": "Circuit to exponentiate the tensor product of Pauli matrices representing the double-excitation operator entering the Unitary Coupled-Cluster Singles and Doubles (UCCSD) ansatz. UCCSD is a VQE ansatz commonly used to run quantum chemistry simulations.",
    "docstring": "Circuit to exponentiate the tensor product of Pauli matrices representing the\ndouble-excitation operator entering the Unitary Coupled-Cluster Singles\nand Doubles (UCCSD) ansatz. UCCSD is a VQE ansatz commonly used to run quantum\nchemistry simulations.\n\nThe CC double-excitation operator is given by\n\n.. math::\n\n    \\hat{U}_{pqrs}(\\theta) = \\mathrm{exp} \\{ \\theta (\\hat{c}_p^\\dagger \\hat{c}_q^\\dagger\n    \\hat{c}_r \\hat{c}_s - \\mathrm{H.c.}) \\},\n\nwhere :math:`\\hat{c}` and :math:`\\hat{c}^\\dagger` are the fermionic annihilation and\ncreation operators and the indices :math:`r, s` and :math:`p, q` run over the occupied and\nunoccupied molecular orbitals, respectively. Using the `Jordan-Wigner transformation\n<https://arxiv.org/abs/1208.5986>`_ the fermionic operator defined above can be written\nin terms of Pauli matrices (for more details see\n`arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_):\n\n.. math::\n\n    \\hat{U}_{pqrs}(\\theta) = \\mathrm{exp} \\Big\\{\n    \\frac{i\\theta}{8} \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1}\n    \\hat{Z}_a (\\hat{X}_s \\hat{X}_r \\hat{Y}_q \\hat{X}_p +\n    \\hat{Y}_s \\hat{X}_r \\hat{Y}_q \\hat{Y}_p + \\hat{X}_s \\hat{Y}_r \\hat{Y}_q \\hat{Y}_p +\n    \\hat{X}_s \\hat{X}_r \\hat{X}_q \\hat{Y}_p - \\mathrm{H.c.}  ) \\Big\\}\n\nThe quantum circuit to exponentiate the tensor product of Pauli matrices entering\nthe latter equation is shown below (see `arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_):\n\n|\n\n.. figure:: ../../_static/templates/subroutines/double_excitation_unitary.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\n|\n\nAs explained in `Seely et al. (2012) <https://arxiv.org/abs/1208.5986>`_,\nthe exponential of a tensor product of Pauli-Z operators can be decomposed in terms of\n:math:`2(n-1)` CNOT gates and a single-qubit Z-rotation referred to as :math:`U_\\theta` in\nthe figure above. If there are :math:`X` or:math:`Y` Pauli matrices in the product, the\nHadamard (:math:`H`) or :math:`R_x` gate has to be applied to change to the :math:`X`\nor :math:`Y` basis, respectively. The latter operations are denoted as\n:math:`U_1`, :math:`U_2`, :math:`U_3` and :math:`U_4` in the figure above. See the\nUsage Details section for more details.\n\nArgs:\n    weight (float or tensor_like): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n    wires1 (Iterable): Wires of the qubits representing the subset of occupied orbitals\n        in the interval ``[s, r]``. The first wire is interpreted as ``s``\n        and the last wire as ``r``.\n        Wires in between are acted on with CNOT gates to compute the parity of the set of qubits.\n    wires2 (Iterable): Wires of the qubits representing the subset of unoccupied\n        orbitals in the interval ``[q, p]``. The first wire is interpreted as ``q`` and\n        the last wire is interpreted as ``p``. Wires in between are acted on with CNOT gates\n        to compute the parity of the set of qubits.\n\n.. details::\n    :title: Usage Details\n\n    Notice that:\n\n    #. :math:`\\hat{U}_{pqrs}(\\theta)` involves eight exponentiations where\n       :math:`\\hat{U}_1`, :math:`\\hat{U}_2`, :math:`\\hat{U}_3`, :math:`\\hat{U}_4` and\n       :math:`\\hat{U}_\\theta` are defined as follows,\n\n       .. math::\n\n           [U_1, && U_2, U_3, U_4, U_{\\theta}] = \\\\\n           && \\Bigg\\{\\bigg[H, H, R_x(-\\frac{\\pi}{2}), H, R_z(\\theta/8)\\bigg],\n           \\bigg[R_x(-\\frac{\\pi}{2}), H, R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}),\n           R_z(\\frac{\\theta}{8}) \\bigg], \\\\\n           && \\bigg[H, R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}),\n           R_z(\\frac{\\theta}{8}) \\bigg], \\bigg[H, H, H, R_x(-\\frac{\\pi}{2}),\n           R_z(\\frac{\\theta}{8}) \\bigg], \\\\\n           && \\bigg[R_x(-\\frac{\\pi}{2}), H, H, H, R_z(-\\frac{\\theta}{8}) \\bigg],\n           \\bigg[H, R_x(-\\frac{\\pi}{2}), H, H, R_z(-\\frac{\\theta}{8}) \\bigg], \\\\\n           && \\bigg[R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}),\n           H, R_z(-\\frac{\\theta}{8}) \\bigg], \\bigg[R_x(-\\frac{\\pi}{2}), R_x(-\\frac{\\pi}{2}),\n           H, R_x(-\\frac{\\pi}{2}), R_z(-\\frac{\\theta}{8}) \\bigg] \\Bigg\\}\n\n    #. For a given quadruple ``[s, r, q, p]`` with :math:`p>q>r>s`, seventy-two single-qubit\n       and ``16*(len(wires1)-1 + len(wires2)-1 + 1)`` CNOT operations are applied.\n       Consecutive CNOT gates act on qubits with indices between ``s`` and ``r`` and\n       ``q`` and ``p`` while a single CNOT acts on wires ``r`` and ``q``. The operations\n       performed across these qubits are shown in dashed lines in the figure above.\n\n    An example of how to use this template is shown below:\n\n    .. code-block:: python\n\n        import pennylane as qml\n\n        dev = qml.device('default.qubit', wires=5)\n\n        @qml.qnode(dev)\n        def circuit(weight, wires1=None, wires2=None):\n            qml.FermionicDoubleExcitation(weight, wires1=wires1, wires2=wires2)\n            return qml.expval(qml.Z(0))\n\n        weight = 1.34817\n        print(circuit(weight, wires1=[0, 1], wires2=[2, 3, 4]))"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qchem.fermionic_single_excitation.FermionicSingleExcitation",
    "summary": "Circuit to exponentiate the tensor product of Pauli matrices representing the single-excitation operator entering the Unitary Coupled-Cluster Singles and Doubles (UCCSD) ansatz. UCCSD is a VQE ansatz commonly used to run quantum chemistry simulations.",
    "docstring": "Circuit to exponentiate the tensor product of Pauli matrices representing the\nsingle-excitation operator entering the Unitary Coupled-Cluster Singles\nand Doubles (UCCSD) ansatz. UCCSD is a VQE ansatz commonly used to run quantum\nchemistry simulations.\n\nThe CC single-excitation operator is given by\n\n.. math::\n\n    \\hat{U}_{pr}(\\theta) = \\mathrm{exp} \\{ \\theta_{pr} (\\hat{c}_p^\\dagger \\hat{c}_r\n    -\\mathrm{H.c.}) \\},\n\nwhere :math:`\\hat{c}` and :math:`\\hat{c}^\\dagger` are the fermionic annihilation and\ncreation operators and the indices :math:`r` and :math:`p` run over the occupied and\nunoccupied molecular orbitals, respectively. Using the `Jordan-Wigner transformation\n<https://arxiv.org/abs/1208.5986>`_ the fermionic operator defined above can be written\nin terms of Pauli matrices (for more details see\n`arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_).\n\n.. math::\n\n    \\hat{U}_{pr}(\\theta) = \\mathrm{exp} \\Big\\{ \\frac{i\\theta}{2}\n    \\bigotimes_{a=r+1}^{p-1}\\hat{Z}_a (\\hat{Y}_r \\hat{X}_p) \\Big\\}\n    \\mathrm{exp} \\Big\\{ -\\frac{i\\theta}{2}\n    \\bigotimes_{a=r+1}^{p-1} \\hat{Z}_a (\\hat{X}_r \\hat{Y}_p) \\Big\\}.\n\nThe quantum circuit to exponentiate the tensor product of Pauli matrices entering\nthe latter equation is shown below (see `arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_):\n\n|\n\n.. figure:: ../../_static/templates/subroutines/single_excitation_unitary.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\n|\n\nAs explained in `Seely et al. (2012) <https://arxiv.org/abs/1208.5986>`_,\nthe exponential of a tensor product of Pauli-Z operators can be decomposed in terms of\n:math:`2(n-1)` CNOT gates and a single-qubit Z-rotation referred to as :math:`U_\\theta` in\nthe figure above. If there are :math:`X` or :math:`Y` Pauli matrices in the product,\nthe Hadamard (:math:`H`) or :math:`R_x` gate has to be applied to change to the\n:math:`X` or :math:`Y` basis, respectively. The latter operations are denoted as\n:math:`U_1` and :math:`U_2` in the figure above. See the Usage Details section for more\ninformation.\n\nArgs:\n    weight (float): angle :math:`\\theta` entering the Z rotation acting on wire ``p``\n    wires (Iterable): Wires that the template acts on.\n        The wires represent the subset of orbitals in the interval ``[r, p]``. Must be of\n        minimum length 2. The first wire is interpreted as ``r`` and the last wire as ``p``.\n        Wires in between are acted on with CNOT gates to compute the parity of the set\n        of qubits.\n\n.. details::\n    :title: Usage Details\n\n    Notice that:\n\n    #. :math:`\\hat{U}_{pr}(\\theta)` involves two exponentiations where :math:`\\hat{U}_1`,\n       :math:`\\hat{U}_2`, and :math:`\\hat{U}_\\theta` are defined as follows,\n\n       .. math::\n           [U_1, U_2, U_{\\theta}] = \\Bigg\\{\\bigg[R_x(-\\pi/2), H, R_z(\\theta/2)\\bigg],\n           \\bigg[H, R_x(-\\frac{\\pi}{2}), R_z(-\\theta/2) \\bigg] \\Bigg\\}\n\n    #. For a given pair ``[r, p]``, ten single-qubit and ``4*(len(wires)-1)`` CNOT\n       operations are applied. Notice also that CNOT gates act only on qubits\n       ``wires[1]`` to ``wires[-2]``. The operations performed across these qubits\n       are shown in dashed lines in the figure above.\n\n    An example of how to use this template is shown below:\n\n    .. code-block:: python\n\n        import pennylane as qml\n\n        dev = qml.device('default.qubit', wires=3)\n\n        @qml.qnode(dev)\n        def circuit(weight, wires=None):\n            qml.FermionicSingleExcitation(weight, wires=wires)\n            return qml.expval(qml.Z(0))\n\n        weight = 0.56\n        print(circuit(weight, wires=[0, 1, 2]))"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qchem.kupccgsd.kUpCCGSD",
    "summary": "Implements the k-Unitary Pair Coupled-Cluster Generalized Singles and Doubles (k-UpCCGSD) ansatz.",
    "docstring": "Implements the k-Unitary Pair Coupled-Cluster Generalized Singles and Doubles (k-UpCCGSD) ansatz.\n\nThe k-UpCCGSD ansatz calls the :func:`~.FermionicSingleExcitation` and :func:`~.FermionicDoubleExcitation`\ntemplates to exponentiate the product of :math:`k` generalized singles and pair coupled-cluster doubles\nexcitation operators. Here, \"generalized\" means that the single and double excitation terms do not\ndistinguish between occupied and unoccupied orbitals. Additionally, the term \"pair coupled-cluster\"\nrefers to the fact that the double excitations contain only those two-body excitations that move a\npair of electrons from one spatial orbital to another. This k-UpCCGSD belongs to the family of Unitary\nCoupled Cluster (UCC) based ans\u00e4tze, commonly used to solve quantum chemistry problems on quantum computers.\n\nThe k-UpCCGSD unitary, within the first-order Trotter approximation for a given integer :math:`k`, is given by:\n\n.. math::\n\n    \\hat{U}(\\vec{\\theta}) =\n    \\prod_{l=1}^{k} \\bigg(\\prod_{p,r}\\exp{\\Big\\{\n    \\theta_{r}^{p}(\\hat{c}^{\\dagger}_p\\hat{c}_r - \\text{H.c.})\\Big\\}}\n    \\ \\prod_{i,j} \\Big\\{\\exp{\\theta_{j_\\alpha j_\\beta}^{i_\\alpha i_\\beta}\n    (\\hat{c}^{\\dagger}_{i_\\alpha}\\hat{c}^{\\dagger}_{i_\\beta}\n    \\hat{c}_{j_\\alpha}\\hat{c}_{j_\\beta} - \\text{H.c.}) \\Big\\}}\\bigg)\n\nwhere :math:`\\hat{c}` and :math:`\\hat{c}^{\\dagger}` are the fermionic annihilation and creation operators.\nThe indices :math:`p, q` run over the spin orbitals and :math:`i, j` run over the spatial orbitals. The\nsingles and paired doubles amplitudes :math:`\\theta_{r}^{p}` and\n:math:`\\theta_{j_\\alpha j_\\beta}^{i_\\alpha i_\\beta}` represent the set of variational parameters.\n\nArgs:\n    weights (tensor_like): Tensor containing the parameters :math:`\\theta_{pr}` and :math:`\\theta_{pqrs}`\n        entering the Z rotation in :func:`~.FermionicSingleExcitation` and :func:`~.FermionicDoubleExcitation`.\n        These parameters are the coupled-cluster amplitudes that need to be optimized for each generalized\n        single and pair double excitation terms.\n    wires (Iterable): wires that the template acts on\n    k (int): Number of times UpCCGSD unitary is repeated.\n    delta_sz (int): Specifies the selection rule ``sz[p] - sz[r] = delta_sz``\n        for the spin-projection ``sz`` of the orbitals involved in the generalized single excitations.\n        ``delta_sz`` can take the values :math:`0` and :math:`\\pm 1`.\n    init_state (array[int]): Length ``len(wires)`` occupation-number vector representing the\n        HF state. ``init_state`` is used to initialize the wires.\n\n.. details::\n    :title: Usage Details\n\n    #. The number of wires has to be equal to the number of\n       spin-orbitals included in the active space, and should be even.\n\n    #. The number of trainable parameters scales linearly with the number of layers as\n       :math:`2 k n`, where :math:`n` is the total number of\n       generalized singles and paired doubles excitation terms.\n\n    An example of how to use this template is shown below:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        from pennylane import numpy as np\n\n        # Build the electronic Hamiltonian\n        symbols = [\"H\", \"H\"]\n        coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])\n        H, wires = qml.qchem.molecular_hamiltonian(symbols, coordinates)\n\n        # Define the Hartree-Fock state\n        electrons = 2\n        ref_state = qml.qchem.hf_state(electrons, wires)\n\n        # Define the device\n        dev = qml.device('default.qubit', wires=wires)\n\n        # Define the ansatz\n        @qml.qnode(dev)\n        def ansatz(weights):\n            qml.kUpCCGSD(weights, wires=[0, 1, 2, 3],\n                            k=1, delta_sz=0, init_state=ref_state)\n            return qml.expval(H)\n\n        # Get the shape of the weights for this template\n        layers = 1\n        shape = qml.kUpCCGSD.shape(k=layers,\n                            n_wires=wires, delta_sz=0)\n\n        # Initialize the weight tensors\n        np.random.seed(24)\n        weights = np.random.random(size=shape)\n\n        # Define the optimizer\n        opt = qml.GradientDescentOptimizer(stepsize=0.4)\n\n        # Store the values of the cost function\n        energy = [ansatz(weights)]\n\n        # Store the values of the circuit weights\n        angle = [weights]\n        max_iterations = 100\n        conv_tol = 1e-06\n        for n in range(max_iterations):\n            weights, prev_energy = opt.step_and_cost(ansatz, weights)\n            energy.append(ansatz(weights))\n            angle.append(weights)\n            conv = np.abs(energy[-1] - prev_energy)\n            if n % 4 == 0:\n                print(f\"Step = {n},  Energy = {energy[-1]:.8f} Ha\")\n            if conv <= conv_tol:\n                break\n\n        print(\"\\n\" f\"Final value of the ground-state energy = {energy[-1]:.8f} Ha\")\n        print(\"\\n\" f\"Optimal value of the circuit parameters = {angle[-1]}\")\n\n    .. code-block:: none\n\n        Step = 0,  Energy = -1.08949110 Ha\n        Step = 4,  Energy = -1.13370605 Ha\n        Step = 8,  Energy = -1.13581648 Ha\n        Step = 12,  Energy = -1.13613171 Ha\n        Step = 16,  Energy = -1.13618030 Ha\n        Step = 20,  Energy = -1.13618779 Ha\n\n        Final value of the ground-state energy = -1.13618779 Ha\n\n        Optimal value of the circuit parameters = [[0.97879636 0.46093583 0.98108824\n        0.45864352 0.65531446 0.44558289]]\n\n\n    **Parameter shape**\n\n    The shape of the weights argument can be computed by the static method\n    :meth:`~.kUpCCGSD.shape` and used when creating randomly\n    initialised weight tensors:\n\n    .. code-block:: python\n\n        shape = qml.kUpCCGSD.shape(k=2, n_wires=4, delta_sz=0)\n        weights = np.random.random(size=shape)\n\n    >>> weights.shape\n    (2, 6)"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qchem.uccsd.UCCSD",
    "summary": "Implements the Unitary Coupled-Cluster Singles and Doubles (UCCSD) ansatz.",
    "docstring": "Implements the Unitary Coupled-Cluster Singles and Doubles (UCCSD) ansatz.\n\nThe UCCSD ansatz calls the\n:func:`~.FermionicSingleExcitation` and :func:`~.FermionicDoubleExcitation`\ntemplates to exponentiate the coupled-cluster excitation operator. UCCSD is a VQE ansatz\ncommonly used to run quantum chemistry simulations.\n\nThe UCCSD unitary, within the first-order Trotter approximation, is given by:\n\n.. math::\n\n    \\hat{U}(\\vec{\\theta}) =\n    \\prod_{p > r} \\mathrm{exp} \\Big\\{\\theta_{pr}\n    (\\hat{c}_p^\\dagger \\hat{c}_r-\\mathrm{H.c.}) \\Big\\}\n    \\prod_{p > q > r > s} \\mathrm{exp} \\Big\\{\\theta_{pqrs}\n    (\\hat{c}_p^\\dagger \\hat{c}_q^\\dagger \\hat{c}_r \\hat{c}_s-\\mathrm{H.c.}) \\Big\\}\n\nwhere :math:`\\hat{c}` and :math:`\\hat{c}^\\dagger` are the fermionic annihilation and\ncreation operators and the indices :math:`r, s` and :math:`p, q` run over the occupied and\nunoccupied molecular orbitals, respectively. Using the `Jordan-Wigner transformation\n<https://arxiv.org/abs/1208.5986>`_ the UCCSD unitary defined above can be written in terms\nof Pauli matrices as follows (for more details see\n`arXiv:1805.04340 <https://arxiv.org/abs/1805.04340>`_):\n\n.. math::\n\n    \\hat{U}(\\vec{\\theta}) = && \\prod_{p > r} \\mathrm{exp} \\Big\\{ \\frac{i\\theta_{pr}}{2}\n    \\bigotimes_{a=r+1}^{p-1} \\hat{Z}_a (\\hat{Y}_r \\hat{X}_p - \\mathrm{H.c.}) \\Big\\} \\\\\n    && \\times \\prod_{p > q > r > s} \\mathrm{exp} \\Big\\{ \\frac{i\\theta_{pqrs}}{8}\n    \\bigotimes_{b=s+1}^{r-1} \\hat{Z}_b \\bigotimes_{a=q+1}^{p-1}\n    \\hat{Z}_a (\\hat{X}_s \\hat{X}_r \\hat{Y}_q \\hat{X}_p +\n    \\hat{Y}_s \\hat{X}_r \\hat{Y}_q \\hat{Y}_p +\n    \\hat{X}_s \\hat{Y}_r \\hat{Y}_q \\hat{Y}_p +\n    \\hat{X}_s \\hat{X}_r \\hat{X}_q \\hat{Y}_p -\n    \\{\\mathrm{H.c.}\\}) \\Big\\}.\n\nArgs:\n    weights (tensor_like): Size ``(n_repeats, len(s_wires) + len(d_wires),)`` tensor containing the\n        parameters (see usage details below) :math:`\\theta_{pr}` and :math:`\\theta_{pqrs}` entering\n        the Z rotation in :func:`~.FermionicSingleExcitation` and :func:`~.FermionicDoubleExcitation`.\n        These parameters are the coupled-cluster amplitudes that need to be optimized for each\n        single and double excitation generated with the :func:`~.excitations` function.\n        If the size of the given tensor is ``(len(s_wires) + len(d_wires),)``, it is assumed that ``n_repeats == 1``.\n        :math:`\\theta_{pr}` and :math:`\\theta_{pqrs}` entering the Z rotation in\n        :func:`~.FermionicSingleExcitation` and :func:`~.FermionicDoubleExcitation`.\n        These parameters are the coupled-cluster amplitudes that need to be optimized for each\n        single and double excitation generated with the :func:`~.excitations` function.\n    wires (Iterable): wires that the template acts on\n    s_wires (Sequence[Sequence]): Sequence of lists containing the wires ``[r,...,p]``\n        resulting from the single excitation\n        :math:`\\vert r, p \\rangle = \\hat{c}_p^\\dagger \\hat{c}_r \\vert \\mathrm{HF} \\rangle`,\n        where :math:`\\vert \\mathrm{HF} \\rangle` denotes the Hartee-Fock reference state.\n        The first (last) entry ``r`` (``p``) is considered the wire representing the\n        occupied (unoccupied) orbital where the electron is annihilated (created).\n    d_wires (Sequence[Sequence[Sequence]]): Sequence of lists, each containing two lists that\n        specify the indices ``[s, ...,r]`` and ``[q,..., p]`` defining the double excitation\n        :math:`\\vert s, r, q, p \\rangle = \\hat{c}_p^\\dagger \\hat{c}_q^\\dagger \\hat{c}_r\n        \\hat{c}_s \\vert \\mathrm{HF} \\rangle`. The entries ``s`` and ``r`` are wires\n        representing two occupied orbitals where the two electrons are annihilated\n        while the entries ``q`` and ``p`` correspond to the wires representing two unoccupied\n        orbitals where the electrons are created. Wires in-between represent the occupied\n        and unoccupied orbitals in the intervals ``[s, r]`` and ``[q, p]``, respectively.\n    init_state (array[int]): Length ``len(wires)`` occupation-number vector representing the\n        HF state. ``init_state`` is used to initialize the wires.\n    n_repeats (int): Number of times the UCCSD unitary is repeated. The default value is ``1``.\n\n.. details::\n    :title: Usage Details\n\n    Notice that:\n\n    #. The number of wires has to be equal to the number of spin orbitals included in\n       the active space.\n\n    #. The single and double excitations can be generated with the function\n       :func:`~.excitations`. See example below.\n\n    #. The vector of parameters ``weights`` is a two-dimensional array of shape\n       ``(n_repeats, len(s_wires)+len(d_wires))``.\n    #. If ``n_repeats=1``, then ``weights`` can also be a one-dimensional array of shape\n       ``(len(s_wires)+len(d_wires),)``.\n\n\n    An example of how to use this template is shown below:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        from pennylane import numpy as np\n\n        # Define the molecule\n        symbols  = ['H', 'H', 'H']\n        geometry = np.array([[0.01076341,  0.04449877,  0.0],\n                             [0.98729513,  1.63059094,  0.0],\n                             [1.87262415, -0.00815842,  0.0]], requires_grad = False)\n        electrons = 2\n        charge = 1\n\n        # Build the electronic Hamiltonian\n        H, qubits = qml.qchem.molecular_hamiltonian(symbols, geometry, charge=charge)\n\n        # Define the HF state\n        hf_state = qml.qchem.hf_state(electrons, qubits)\n\n        # Generate single and double excitations\n        singles, doubles = qml.qchem.excitations(electrons, qubits)\n\n        # Map excitations to the wires the UCCSD circuit will act on\n        s_wires, d_wires = qml.qchem.excitations_to_wires(singles, doubles)\n\n        # Define the device\n        dev = qml.device(\"default.qubit\", wires=qubits)\n\n        # Define the qnode\n        @qml.qnode(dev)\n        def circuit(params, wires, s_wires, d_wires, hf_state):\n            qml.UCCSD(params, wires, s_wires, d_wires, hf_state)\n            return qml.expval(H)\n\n        # Define the initial values of the circuit parameters\n        params = np.zeros(len(singles) + len(doubles))\n\n        # Define the optimizer\n        optimizer = qml.GradientDescentOptimizer(stepsize=0.5)\n\n        # Optimize the circuit parameters and compute the energy\n        for n in range(21):\n            params, energy = optimizer.step_and_cost(circuit, params,\n            wires=range(qubits), s_wires=s_wires, d_wires=d_wires, hf_state=hf_state)\n            if n % 2 == 0:\n                print(\"step = {:},  E = {:.8f} Ha\".format(n, energy))\n\n    .. code-block:: none\n\n        step = 0,  E = -1.24654994 Ha\n        step = 2,  E = -1.27016844 Ha\n        step = 4,  E = -1.27379541 Ha\n        step = 6,  E = -1.27434106 Ha\n        step = 8,  E = -1.27442311 Ha\n        step = 10,  E = -1.27443547 Ha\n        step = 12,  E = -1.27443733 Ha\n        step = 14,  E = -1.27443761 Ha\n        step = 16,  E = -1.27443765 Ha\n        step = 18,  E = -1.27443766 Ha\n        step = 20,  E = -1.27443766 Ha"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qft.QFT",
    "summary": "QFT(wires) Apply a quantum Fourier transform (QFT).",
    "docstring": "QFT(wires)\nApply a quantum Fourier transform (QFT).\n\nFor the :math:`N`-qubit computational basis state :math:`|m\\rangle`, the QFT performs the\ntransformation\n\n.. math::\n\n    |m\\rangle \\rightarrow \\frac{1}{\\sqrt{2^{N}}}\\sum_{n=0}^{2^{N} - 1}\\omega_{N}^{mn} |n\\rangle,\n\nwhere :math:`\\omega_{N} = e^{\\frac{2 \\pi i}{2^{N}}}` is the :math:`2^{N}`-th root of unity.\n\n**Details:**\n\n* Number of wires: Any (the operation can act on any number of wires)\n* Number of parameters: 0\n* Gradient recipe: None\n\nArgs:\n    wires (int or Iterable[Number, str]]): the wire(s) the operation acts on\n\n**Example**\n\nThe quantum Fourier transform is applied by specifying the corresponding wires:\n\n.. code-block:: python\n\n    wires = 3\n\n    dev = qml.device('default.qubit',wires=wires)\n\n    @qml.qnode(dev)\n    def circuit_qft(basis_state):\n        qml.BasisState(basis_state, wires=range(wires))\n        qml.QFT(wires=range(wires))\n        return qml.state()\n\n>>> circuit_qft(np.array([1.0, 0.0, 0.0])) # doctest: +SKIP\narray([ 0.3536+0.j, -0.3536+0.j,  0.3536+0.j, -0.3536+0.j,  0.3536+0.j,\n       -0.3536+0.j,  0.3536+0.j, -0.3536+0.j])\n\n.. details::\n    :title: Semiclassical Quantum Fourier transform\n\n    If the QFT is the last subroutine applied within a circuit, it can be\n    replaced by a\n    `semiclassical Fourier transform <https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.76.3228>`_.\n    It makes use of mid-circuit measurements and dynamic circuit control based\n    on the measurement values, allowing to reduce the number of two-qubit gates.\n\n    As an example, consider the following circuit implementing addition between two\n    numbers with ``n_wires`` bits (modulo ``2**n_wires``):\n\n    .. code-block:: python\n\n        dev = qml.device(\"default.qubit\")\n\n        @qml.qnode(dev, shots=1)\n        def qft_add(m, k, n_wires):\n            qml.BasisEmbedding(m, wires=range(n_wires))\n            qml.adjoint(qml.QFT)(wires=range(n_wires))\n            for j in range(n_wires):\n                qml.RZ(-k * np.pi / (2**j), wires=j)\n            qml.QFT(wires=range(n_wires))\n            return qml.sample()\n\n    >>> qft_add(7, 3, n_wires=4)\n    array([[1, 0, 1, 0]])\n\n    The last building block of this circuit is a QFT, so we may replace it by its\n    semiclassical counterpart:\n\n    .. code-block:: python\n\n        def scFT(n_wires):\n            '''semiclassical Fourier transform'''\n            for w in range(n_wires-1):\n                qml.Hadamard(w)\n                mcm = qml.measure(w)\n                for m in range(w + 1, n_wires):\n                    qml.cond(mcm, qml.PhaseShift)(np.pi / 2 ** (m + 1), wires=m)\n            qml.Hadamard(n_wires-1)\n\n        @qml.qnode(dev)\n        def scFT_add(m, k, n_wires):\n            qml.BasisEmbedding(m, wires=range(n_wires))\n            qml.adjoint(qml.QFT)(wires=range(n_wires))\n            for j in range(n_wires):\n                qml.RZ(-k * np.pi / (2**j), wires=j)\n            scFT(n_wires)\n            # Revert wire order because of PL's QFT convention\n            return qml.sample(wires=list(range(n_wires-1, -1, -1)))\n\n    >>> qml.set_shots(scFT_add, 1)(7, 3, n_wires=4) # doctest: +SKIP\n    array([[1, 1, 1, 0]])"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qmc.QuantumMonteCarlo",
    "summary": "Performs the `quantum Monte Carlo estimation <https://arxiv.org/abs/1805.00109>`__ algorithm.",
    "docstring": "Performs the `quantum Monte Carlo estimation <https://arxiv.org/abs/1805.00109>`__\nalgorithm.\n\nGiven a probability distribution :math:`p(i)` of dimension :math:`M = 2^{m}` for some\n:math:`m \\geq 1` and a function :math:`f: X \\rightarrow [0, 1]` defined on the set of\nintegers :math:`X = \\{0, 1, \\ldots, M - 1\\}`, this function implements the algorithm that\nallows the following expectation value to be estimated:\n\n.. math::\n\n    \\mu = \\sum_{i \\in X} p(i) f(i).\n\n.. figure:: ../../_static/templates/subroutines/qmc.svg\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\nArgs:\n    probs (array): input probability distribution as a flat array\n    func (callable): input function :math:`f` defined on the set of integers\n        :math:`X = \\{0, 1, \\ldots, M - 1\\}` such that :math:`f(i)\\in [0, 1]` for :math:`i \\in X`\n    target_wires (Union[Wires, Sequence[int], or int]): the target wires\n    estimation_wires (Union[Wires, Sequence[int], or int]): the estimation wires\n\nRaises:\n    ValueError: if ``probs`` is not flat or has a length that is not compatible with\n        ``target_wires``\n\n.. note::\n\n    This template is only compatible with simulators because the algorithm is performed using\n    unitary matrices. Additionally, this operation is not differentiable. To implement the\n    quantum Monte Carlo algorithm on hardware requires breaking down the unitary matrices into\n    hardware-compatible gates, check out the :func:`~.quantum_monte_carlo` transformation for\n    more details.\n\n.. details::\n    :title: Usage Details\n\n    The algorithm proceeds as follows:\n\n    #. The probability distribution :math:`p(i)` is encoded using a unitary :math:`\\mathcal{A}`\n       applied to the first :math:`m` qubits specified by ``target_wires``.\n    #. The function :math:`f(i)` is encoded onto the last qubit of ``target_wires`` using a unitary\n       :math:`\\mathcal{R}`.\n    #. The unitary :math:`\\mathcal{Q}` is defined with eigenvalues\n       :math:`e^{\\pm 2 \\pi i \\theta}` such that the phase :math:`\\theta` encodes the expectation\n       value through the equation :math:`\\mu = (1 + \\cos (\\pi \\theta)) / 2`. The circuit in steps 1\n       and 2 prepares an equal superposition over the two states corresponding to the eigenvalues\n       :math:`e^{\\pm 2 \\pi i \\theta}`.\n    #. The :func:`~.QuantumPhaseEstimation` circuit is applied so that :math:`\\pm\\theta` can be\n       estimated by finding the probabilities of the :math:`n` estimation wires. This in turn allows\n       for the estimation of :math:`\\mu`.\n\n    Visit `Rebentrost et al. (2018) <https://arxiv.org/abs/1805.00109>`__ for further details. In\n    this algorithm, the number of applications :math:`N` of the :math:`\\mathcal{Q}` unitary scales\n    as :math:`2^{n}`. However, due to the use of quantum phase estimation, the error\n    :math:`\\epsilon` scales as :math:`\\mathcal{O}(2^{-n})`. Hence,\n\n    .. math::\n\n        N = \\mathcal{O}\\left(\\frac{1}{\\epsilon}\\right).\n\n    This scaling can be compared to standard Monte Carlo estimation, where :math:`N` samples are\n    generated from the probability distribution and the average over :math:`f` is taken. In that\n    case,\n\n    .. math::\n\n        N =  \\mathcal{O}\\left(\\frac{1}{\\epsilon^{2}}\\right).\n\n    Hence, the quantum Monte Carlo algorithm has a quadratically improved time complexity with\n    :math:`N`. An example use case is given below.\n\n    Consider a standard normal distribution :math:`p(x)` and a function\n    :math:`f(x) = \\sin ^{2} (x)`. The expectation value of :math:`f(x)` is\n    :math:`\\int_{-\\infty}^{\\infty}f(x)p(x)dx \\approx 0.432332`. This number can be approximated by\n    discretizing the problem and using the quantum Monte Carlo algorithm.\n\n    First, the problem is discretized:\n\n    .. code-block:: python\n\n        from scipy.stats import norm\n\n        m = 5\n        M = 2 ** m\n\n        xmax = np.pi  # bound to region [-pi, pi]\n        xs = np.linspace(-xmax, xmax, M)\n\n        probs = np.array([norm().pdf(x) for x in xs])\n        probs /= np.sum(probs)\n\n        func = lambda i: np.sin(xs[i]) ** 2\n\n    The ``QuantumMonteCarlo`` template can then be used:\n\n    .. code-block:: python\n\n        n = 10\n        N = 2 ** n\n\n        target_wires = range(m + 1)\n        estimation_wires = range(m + 1, n + m + 1)\n\n        dev = qml.device(\"default.qubit\", wires=(n + m + 1))\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.templates.QuantumMonteCarlo(\n                probs,\n                func,\n                target_wires=target_wires,\n                estimation_wires=estimation_wires,\n            )\n            return qml.probs(estimation_wires)\n\n        phase_estimated = np.argmax(circuit()[:int(N / 2)]) / N\n\n    The estimated value can be retrieved using the formula :math:`\\mu = (1-\\cos(\\pi \\theta))/2`\n\n    >>> (1 - np.cos(np.pi * phase_estimated)) / 2\n    np.float64(0.4327...)"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qpe.QuantumPhaseEstimation",
    "summary": "Performs the `quantum phase estimation <https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm>`__ circuit.",
    "docstring": "Performs the\n`quantum phase estimation <https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm>`__\ncircuit.\n\nGiven a unitary matrix :math:`U`, this template applies the circuit for quantum phase\nestimation. The unitary is applied to the qubits specified by ``target_wires`` and :math:`n`\nqubits are used for phase estimation as specified by ``estimation_wires``.\n\n.. figure:: ../../_static/templates/subroutines/qpe.svg\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\nArgs:\n    unitary (array or Operator): the phase estimation unitary, specified as a matrix or an\n        :class:`~.Operator`\n    target_wires (Union[Wires, Sequence[int], or int]): the target wires to apply the unitary.\n        If the unitary is specified as an operator, the target wires should already have been\n        defined as part of the operator. In this case, target_wires should not be specified.\n    estimation_wires (Union[Wires, Sequence[int], or int]): the wires to be used for phase\n        estimation\n\nRaises:\n    QuantumFunctionError: if the ``target_wires`` and ``estimation_wires`` share a common\n        element, or if ``target_wires`` are specified for an operator unitary.\n\n.. details::\n    :title: Usage Details\n\n    This circuit can be used to perform the standard quantum phase estimation algorithm, consisting\n    of the following steps:\n\n    #. Prepare ``target_wires`` in a given state. If ``target_wires`` are prepared in an eigenstate\n       of :math:`U` that has corresponding eigenvalue :math:`e^{2 \\pi i \\theta}` with phase\n       :math:`\\theta \\in [0, 1)`, this algorithm will measure :math:`\\theta`. Other input states can\n       be prepared more generally.\n    #. Apply the ``QuantumPhaseEstimation`` circuit.\n    #. Measure ``estimation_wires`` using :func:`~.probs`, giving a probability distribution over\n       measurement outcomes in the computational basis.\n    #. Find the index of the largest value in the probability distribution and divide that number by\n       :math:`2^{n}`. This number will be an estimate of :math:`\\theta` with an error that decreases\n       exponentially with the number of qubits :math:`n`.\n\n    Note that if :math:`\\theta \\in (-1, 0]`, we can estimate the phase by again finding the index\n    :math:`i` found in step 4 and calculating :math:`\\theta \\approx \\frac{1 - i}{2^{n}}`. An example\n    of this case is below.\n\n    Consider the matrix corresponding to a rotation from an :class:`~.RX` gate:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        from pennylane.templates import QuantumPhaseEstimation\n        from pennylane import numpy as np\n\n        phase = 5\n        target_wires = [0]\n        unitary = qml.RX(phase, wires=0).matrix()\n\n    The ``phase`` parameter can be estimated using ``QuantumPhaseEstimation``. An example is\n    shown below using a register of five phase-estimation qubits:\n\n    .. code-block:: python\n\n        n_estimation_wires = 5\n        estimation_wires = range(1, n_estimation_wires + 1)\n\n        dev = qml.device(\"default.qubit\", wires=n_estimation_wires + 1)\n\n        @qml.qnode(dev)\n        def circuit():\n            # Start in the |+> eigenstate of the unitary\n            qml.Hadamard(wires=target_wires)\n\n            QuantumPhaseEstimation(\n                unitary,\n                target_wires=target_wires,\n                estimation_wires=estimation_wires,\n            )\n\n            return qml.probs(estimation_wires)\n\n        phase_estimated = np.argmax(circuit()) / 2 ** n_estimation_wires\n\n        # Need to rescale phase due to convention of RX gate\n        phase_estimated = 4 * np.pi * (1 - phase_estimated)\n\n    We can also perform phase estimation on an operator. Note that since operators are defined\n    with target wires, the target wires should not be provided for the QPE.\n\n    .. code-block:: python\n\n\n        # use the product to specify compound operators\n        unitary = qml.RX(np.pi / 2, wires=[0]) @ qml.CNOT(wires=[0, 1])\n        eigenvector = np.array([-1/2, -1/2, 1/2, 1/2])\n\n        n_estimation_wires = 5\n        estimation_wires = range(2, n_estimation_wires + 2)\n        target_wires = [0, 1]\n\n        dev = qml.device(\"default.qubit\", wires=n_estimation_wires + 2)\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.StatePrep(eigenvector, wires=target_wires)\n            QuantumPhaseEstimation(\n                unitary,\n                estimation_wires=estimation_wires,\n            )\n            return qml.probs(estimation_wires)\n\n        phase_estimated = np.argmax(circuit()) / 2 ** n_estimation_wires"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qrom.QROM",
    "summary": "Applies the QROM operator.",
    "docstring": "Applies the QROM operator.\n\nThis operator encodes bitstrings associated with indexes:\n\n.. math::\n    \\text{QROM}|i\\rangle|0\\rangle = |i\\rangle |b_i\\rangle,\n\nwhere :math:`b_i` is the bitstring associated with index :math:`i`.\n\nArgs:\n    bitstrings (list[str]): the bitstrings to be encoded\n    control_wires (Sequence[int]): the wires where the indexes are specified\n    target_wires (Sequence[int]): the wires where the bitstring is loaded\n    work_wires (Sequence[int]): the auxiliary wires used for the computation\n    clean (bool): if True, the work wires are not altered by operator, default is ``True``\n\n**Example**\n\nIn this example, the QROM operator is applied to encode the third bitstring, associated with index 2, in the target wires.\n\n.. code-block:: python\n\n    # a list of bitstrings is defined\n    bitstrings = [\"010\", \"111\", \"110\", \"000\"]\n\n    dev = qml.device(\"default.qubit\")\n\n    @qml.qnode(dev, shots=1)\n    def circuit():\n\n        # the third index is encoded in the control wires [0, 1]\n        qml.BasisEmbedding(2, wires = [0,1])\n\n        qml.QROM(bitstrings = bitstrings,\n                control_wires = [0,1],\n                target_wires = [2,3,4],\n                work_wires = [5,6,7])\n\n        return qml.sample(wires = [2,3,4])\n\n>>> print(circuit())\n[[1 1 0]]\n\n\n.. details::\n    :title: Usage Details\n\n    This template takes as input three different sets of wires. The first one is ``control_wires`` which is used\n    to encode the desired index. Therefore, if we have :math:`m` bitstrings, we need\n    at least :math:`\\lceil \\log_2(m)\\rceil` control wires.\n\n    The second set of wires is ``target_wires`` which stores the bitstrings.\n    For instance, if the bitstring is \"0110\", we will need four target wires. Internally, the bitstrings are\n    encoded using the :class:`~.BasisEmbedding` template.\n\n\n    The ``work_wires`` are the auxiliary qubits used by the template to reduce the number of gates required.\n    Let :math:`k` be the number of work wires. If :math:`k = 0`, the template is equivalent to executing :class:`~.Select`.\n    Following the idea in [`arXiv:1812.00954 <https://arxiv.org/abs/1812.00954>`__], auxiliary qubits can be used to\n    load more than one bitstring in parallel. Let :math:`\\lambda` be\n    the number of bitstrings we want to store in parallel, assumed to be a power of :math:`2`.\n    Then, :math:`k = l \\cdot (\\lambda-1)` work wires are needed,\n    where :math:`l` is the length of the bitstrings.\n\n    The QROM template has two variants. The first one (``clean = False``) is based on [`arXiv:1812.00954 <https://arxiv.org/abs/1812.00954>`__] that alternates the state in the ``work_wires``.\n    The second one (``clean = True``), based on [`arXiv:1902.02134 <https://arxiv.org/abs/1902.02134>`__], solves that issue by\n    returning ``work_wires`` to their initial state. This technique can be applied when the ``work_wires`` are not\n    initialized to zero."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qsvt.QSVT",
    "summary": "QSVT(UA,projectors) Implements the `quantum singular value transformation <https://arxiv.org/abs/1806.01838>`__ (QSVT) circuit.",
    "docstring": "QSVT(UA,projectors)\nImplements the\n`quantum singular value transformation <https://arxiv.org/abs/1806.01838>`__ (QSVT) circuit.\n\n.. note ::\n\n    This template allows users to define hardware-compatible block encoding and\n    projector-controlled phase shift circuits. For a QSVT implementation that is\n    tailored to work directly with an input matrix and a transformation polynomial\n    see :func:`~.qsvt`.\n\nGiven an :class:`~.Operator` :math:`U`, which block encodes the matrix :math:`A`, and a list of\nprojector-controlled phase shift operations :math:`\\vec{\\Pi}_\\phi`, this template applies a\ncircuit for the quantum singular value transformation as follows.\n\nWhen the number of projector-controlled phase shifts is even (:math:`d` is odd), the QSVT\ncircuit is defined as:\n\n.. math::\n\n    U_{QSVT} = \\tilde{\\Pi}_{\\phi_1}U\\left[\\prod^{(d-1)/2}_{k=1}\\Pi_{\\phi_{2k}}U^\\dagger\n    \\tilde{\\Pi}_{\\phi_{2k+1}}U\\right]\\Pi_{\\phi_{d+1}}.\n\n\nAnd when the number of projector-controlled phase shifts is odd (:math:`d` is even):\n\n.. math::\n\n    U_{QSVT} = \\left[\\prod^{d/2}_{k=1}\\Pi_{\\phi_{2k-1}}U^\\dagger\\tilde{\\Pi}_{\\phi_{2k}}U\\right]\n    \\Pi_{\\phi_{d+1}}.\n\nThis circuit applies a polynomial transformation (:math:`Poly^{SV}`) to the singular values of\nthe block encoded matrix:\n\n.. math::\n\n    \\begin{align}\n         U_{QSVT}(A, \\vec{\\phi}) &=\n         \\begin{bmatrix}\n            Poly^{SV}(A) & \\cdot \\\\\n            \\cdot & \\cdot\n        \\end{bmatrix}.\n    \\end{align}\n\n.. seealso::\n\n    :func:`~.qsvt` and `A Grand Unification of Quantum Algorithms <https://arxiv.org/pdf/2105.02859.pdf>`_.\n\nArgs:\n    UA (Operator): the block encoding circuit, specified as an :class:`~.Operator`,\n        like :class:`~.BlockEncode`\n    projectors (Sequence[Operator]): a list of projector-controlled phase\n        shifts that implement the desired polynomial\n\nRaises:\n    ValueError: if the input block encoding is not an operator\n\n**Example**\n\nTo implement QSVT in a circuit, we can use the following method:\n\n>>> dev = qml.device(\"default.qubit\", wires=[0])\n>>> block_encoding = qml.Hadamard(wires=0)  # note H is a block encoding of 1/sqrt(2)\n>>> phase_shifts = [qml.RZ(-2 * theta, wires=0) for theta in (1.23, -0.5, 4)]  # -2*theta to match convention\n\n>>> @qml.qnode(dev)\n... def example_circuit():\n...     qml.QSVT(block_encoding, phase_shifts)\n...     return qml.expval(qml.Z(0))\n... \n\n>>> example_circuit()\nnp.float64(0.5403...)\n\nWe can visualize the circuit as follows:\n\n>>> print(qml.draw(example_circuit)())\n0: \u2500\u2500QSVT\u2500\u2524  <Z>\n\nTo see the implementation details, we can expand the circuit:\n\n>>> q_script = qml.tape.QuantumScript(ops=[qml.QSVT(block_encoding, phase_shifts)])\n>>> print(q_script.expand().draw(decimals=2))\n0: \u2500\u2500RZ(-2.46)\u2500\u2500H\u2500\u2500RZ(1.00)\u2500\u2500H\u2020\u2500\u2500RZ(-8.00)\u2500\u2524\n\nSee the Usage Details section for more examples on implementing QSVT with different block\nencoding methods.\n\n.. details::\n    :title: Usage Details\n\n    The QSVT operation can be used with different block encoding methods, depending on the\n    initial operator for which the singular value transformation is applied and the desired\n    backend device. Examples are provided below.\n\n    If we want to transform the singular values of a matrix,\n    the matrix can be block-encoded with either the :class:`~.BlockEncode` or :class:`~.FABLE`\n    operations. Note that :class:`~.BlockEncode` is more efficient on simulator devices but\n    it cannot be used with hardware backends because it currently has no gate decomposition.\n    The :class:`~.FABLE` operation is less efficient on simulator devices but is hardware\n    compatible.\n\n    The following example applies the polynomial :math:`p(x) = -x + 0.5x^3 + 0.5x^5` to an\n    arbitrary hermitian matrix using :class:`~.BlockEncode` for block encoding.\n\n    .. code-block:: python\n\n        poly = np.array([0, -1, 0, 0.5, 0, 0.5])\n        angles = qml.poly_to_angles(poly, \"QSVT\")\n        input_matrix = np.array([[0.2, 0.1], [0.1, -0.1]])\n\n        wires = [0, 1]\n        block_encode = qml.BlockEncode(input_matrix, wires=wires)\n        projectors = [\n            qml.PCPhase(angles[i], dim=len(input_matrix), wires=wires)\n            for i in range(len(angles))\n        ]\n\n        dev = qml.device(\"default.qubit\")\n        @qml.qnode(dev)\n        def circuit():\n            qml.QSVT(block_encode, projectors)\n            return qml.state()\n\n    >>> circuit() # doctest: +SKIP\n    array([-0.1942+0.6665j, -0.0979+0.3583j,  0.332 -0.5105j, -0.0955+0.0104j])\n\n    If we want to transform the singular values of a linear\n    combination of unitaries, e.g., a Hamiltonian, it can be block-encoded with operations\n    such as :class:`~.PrepSelPrep` or :class:`~.Qubitization`. Note that both of these operations\n    have a gate decomposition and can be implemented on hardware. The following example applies the polynomial\n    :math:`p(x) = -x + 0.5x^3 + 0.5x^5` to the Hamiltonian :math:`H = 0.1X_3 - 0.7X_3Z_4 - 0.2Z_3Y_4`,\n    block-encoded with :class:`~.PrepSelPrep`.\n\n    .. code-block:: python\n\n        poly = np.array([0, -1, 0, 0.5, 0, 0.5])\n        H = 0.1 * qml.X(2) - 0.7 * qml.X(2) @ qml.Z(3) - 0.2 * qml.Z(2)\n\n        control_wires = [0, 1]\n        block_encode = qml.PrepSelPrep(H, control=control_wires)\n        angles = qml.poly_to_angles(poly, \"QSVT\")\n\n        projectors = [\n            qml.PCPhase(angles[i], dim=2 ** len(H.wires), wires=control_wires + H.wires)\n            for i in range(len(angles))\n        ]\n\n        dev = qml.device(\"default.qubit\")\n\n        @qml.qnode(dev)\n        def circuit():\n            qml.QSVT(block_encode, projectors)\n            return qml.state()\n\n    >>> circuit() # doctest: +SKIP\n    array([ 1.44000000e-01+1.01511390e-01j,  0.00000000e+00+0.00000000e+00j,\n            4.32000000e-01+3.04534169e-01j,  0.00000000e+00+0.00000000e+00j,\n            -4.14503215e-17+7.27402636e-17j,  0.00000000e+00+0.00000000e+00j,\n            5.59003542e-01+9.65699229e-02j,  0.00000000e+00+0.00000000e+00j,\n            4.22566958e-01+7.30000000e-02j,  0.00000000e+00+0.00000000e+00j,\n            -3.16925218e-01-5.47500000e-02j,  0.00000000e+00+0.00000000e+00j,\n            5.20486781e-18-4.91300614e-17j,  0.00000000e+00+0.00000000e+00j,\n            -2.79501771e-01-4.82849614e-02j,  0.00000000e+00+0.00000000e+00j])"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.qubitization.Qubitization",
    "summary": "Applies the `Qubitization <https://arxiv.org/abs/2204.11890>`__ operator.",
    "docstring": "Applies the `Qubitization <https://arxiv.org/abs/2204.11890>`__ operator.\n\nThis operator encodes a Hamiltonian, written as a linear combination of unitaries, into a unitary operator.\nIt is implemented with a quantum walk operator that takes a Hamiltonian as input and generates:\n\n.. math::\n    Q =  \\text{Prep}_{\\mathcal{H}}^{\\dagger} \\text{Sel}_{\\mathcal{H}} \\text{Prep}_{\\mathcal{H}}(2|0\\rangle\\langle 0| - I).\n\n\n\n.. seealso:: :class:`~.AmplitudeEmbedding` and :class:`~.Select`.\n\nArgs:\n    hamiltonian (Union[.Hamiltonian, .Sum, .Prod, .SProd, .LinearCombination]): The Hamiltonian written as a linear combination of unitaries.\n    control (Iterable[Any], Wires): The control qubits for the Qubitization operator.\n\n**Example**\n\nThis operator, when applied in conjunction with QPE, allows computing the eigenvalue of an eigenvector of the Hamiltonian.\n\n.. code-block:: python\n\n    H = qml.dot([0.1, 0.3, -0.3], [qml.Z(0), qml.Z(1), qml.Z(0) @ qml.Z(2)])\n\n    @qml.qnode(qml.device(\"default.qubit\"))\n    def circuit():\n\n        # initiate the eigenvector\n        qml.PauliX(2)\n\n        # apply QPE\n        measurements = qml.iterative_qpe(\n            qml.Qubitization(H, control = [3,4]), aux_wire = 5, iters = 3\n        )\n        return qml.probs(op = measurements)\n\n    output = circuit()\n\n    # post-processing\n    lamb = sum([abs(c) for c in H.terms()[0]])\n\n>>> print(\"eigenvalue: \", lamb * np.cos(2 * np.pi * (np.argmax(output)) / 8))\neigenvalue: 0.7"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.reflection.Reflection",
    "summary": "Apply a reflection about a state :math:`|\\Psi\\rangle`.",
    "docstring": "Apply a reflection about a state :math:`|\\Psi\\rangle`.\n\nThis operator works by providing an operation, :math:`U`, that prepares the desired state, :math:`\\vert \\Psi \\rangle`,\nthat we want to reflect about. We can also provide a reflection angle :math:`\\alpha`\nto define the operation in a more generic form:\n\n.. math::\n\n   R(U, \\alpha) = -I + (1 - e^{i\\alpha}) |\\Psi\\rangle \\langle \\Psi|\n\nThis operator is an important component of quantum algorithms such as amplitude amplification [`arXiv:quant-ph/0005055 <https://arxiv.org/abs/quant-ph/0005055>`__]\nand oblivious amplitude amplification [`arXiv:1312.1414 <https://arxiv.org/abs/1312.1414>`__].\n\nArgs:\n    U (Operator): the operator that prepares the state :math:`|\\Psi\\rangle`\n    alpha (float): the angle of the operator, default is :math:`\\pi`\n    reflection_wires (Any or Iterable[Any]): subsystem of wires on which to reflect, the\n        default is ``None`` and the reflection will be applied on the ``U`` wires.\n\n**Example**\n\nThis example shows how to apply the reflection :math:`-I + 2|+\\rangle \\langle +|` to the state :math:`|1\\rangle`.\n\n.. code-block:: python\n\n    U = qml.Hadamard(wires=0)\n    dev = qml.device('default.qubit')\n\n    @qml.qnode(dev)\n    def circuit():\n        qml.PauliX(wires=0)\n        qml.Reflection(U)\n        return qml.state()\n\n>>> circuit() # doctest: +SKIP\narray([1.+6.123234e-17j, 0.-6.123234e-17j])\n\nFor cases when :math:`U` comprises many operations, you can create a quantum\nfunction containing each operation, one per line, then decorate the quantum\nfunction with ``@qml.prod``:\n\n.. code-block:: python\n\n    @qml.prod\n    def U(wires):\n        qml.Hadamard(wires=wires[0])\n        qml.RY(0.1, wires=wires[1])\n\n    @qml.qnode(dev)\n    def circuit():\n        qml.Reflection(U([0, 1]))\n        return qml.state()\n\n>>> circuit() # doctest: +SKIP\narray([-0.0025-6.1385e-17j,  0.0499+3.0565e-18j,  0.9975+6.1079e-17j,\n        0.0499+3.0565e-18j])\n\n.. details::\n    :title: Theory\n\n    The operator is built as follows:\n\n    .. math::\n\n        \\text{R}(U, \\alpha) = -I + (1 - e^{i\\alpha}) |\\Psi\\rangle \\langle \\Psi| = U(-I + (1 - e^{i\\alpha}) |0\\rangle \\langle 0|)U^{\\dagger}.\n\n    The central block is obtained through a :class:`~.PhaseShift` controlled operator.\n\n    In the case of specifying the reflection wires, the operator would have the following expression.\n\n    .. math::\n\n        U(-I + (1 - e^{i\\alpha}) |0\\rangle^{\\otimes m} \\langle 0|^{\\otimes m}\\otimes I^{n-m})U^{\\dagger},\n\n    where :math:`m` is the number of reflection wires and :math:`n` is the total number of wires."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.select.Select",
    "summary": "The ``Select`` operator, also known as multiplexer or multiplexed operation, applies different operations depending on the state of designated control wires.",
    "docstring": "The ``Select`` operator, also known as multiplexer or multiplexed operation,\napplies different operations depending on the state of designated control wires.\n\n.. math:: Select|i\\rangle \\otimes |\\psi\\rangle = |i\\rangle \\otimes U_i |\\psi\\rangle\n\n.. figure:: ../../../doc/_static/templates/subroutines/select.png\n                :align: center\n                :width: 70%\n                :target: javascript:void(0);\n\nIf the applied operations :math:`\\{U_i\\}` are all single-qubit Pauli rotations about the\nsame axis, with the angle determined by the control wires, this is also called a\n**uniformly controlled rotation** gate.\n\n.. seealso:: :class:`~.SelectPauliRot`\n\nArgs:\n    ops (list[Operator]): operations to apply\n    control (Sequence[int]): the wires controlling which operation is applied.\n        At least :math:`\\lceil \\log_2 K\\rceil` wires are required for :math:`K` operations.\n    work_wires (Union[Wires, Sequence[int], or int]): auxiliary wire(s) that may be\n        utilized during the decomposition of the operator into native operations.\n        For details, see the section on the unary iterator decomposition below.\n    partial (bool): Whether the state on the wires provided in ``control`` are compatible with\n        a `partial Select <https://pennylane.ai/compilation/partial-select>`__ decomposition.\n        See the note below for details.\n    id (str or None): String representing the operation (optional)\n\n.. note::\n    The position of the operation in the list determines which qubit state implements that\n    operation. For example, when the qubit register is in the state :math:`|00\\rangle`,\n    we will apply ``ops[0]``. When the qubit register is in the state :math:`|10\\rangle`,\n    we will apply ``ops[2]``. To obtain the list position ``index`` for a given binary\n    bitstring representing the control state we can use the following relationship:\n    ``index = int(state_string, 2)``. For example, ``2 = int('10', 2)``.\n\n.. note::\n    Using ``partial=True`` assumes that the quantum state :math:`|\\psi\\rangle` on the\n    ``control`` wires satisfies :math:`\\langle j|\\psi\\rangle=0` for all :math:`j\\in [K, 2^c)`,\n    where :math:`K` is the number of operators (``len(ops)``) and :math:`c` is the number of\n    control wires (``len(control)``).\n    If you are unsure whether this condition is satisfied, set ``partial=False`` to guarantee\n    a correct, even though more expensive, decomposition.\n    For more details on the partial Select decomposition, see\n    `its compilation page <https://pennylane.ai/compilation/partial-select>`__.\n\n**Example**\n\n>>> dev = qml.device('default.qubit', wires=4)\n>>> ops = [qml.X(2), qml.X(3), qml.Y(2), qml.SWAP([2, 3])]\n>>> @qml.qnode(dev)\n... def circuit():\n...     qml.Select(ops, control=[0,1])\n...     return qml.state()\n...\n>>> print(qml.draw(circuit, level='device')())\n0: \u2500\u256d\u25cb\u2500\u256d\u25cb\u2500\u256d\u25cf\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2524 \u256dState\n1: \u2500\u251c\u25cb\u2500\u251c\u25cf\u2500\u251c\u25cb\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2524 \u251cState\n2: \u2500\u2570X\u2500\u2502\u2500\u2500\u2570Y\u2500\u251cSWAP\u2500\u2524 \u251cState\n3: \u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u2524 \u2570State\n\nIf there are fewer operators to be applied than possible for the given number of control\nwires, we call the ``Select`` operator a `partial Select <https://pennylane.ai/compilation/partial-select>`__.\nIn this case, the control structure can be simplified if the state on the control wires\ndoes not have overlap with the unused computational basis states (:math:`|j\\rangle` with\n:math:`j>K-1`). Passing ``partial=True`` tells ``Select`` that this criterion is\nsatisfied, and allows the decomposition to make use of the simplification:\n\n>>> ops = [qml.X(2), qml.X(3), qml.SWAP([2, 3])]\n>>> @qml.qnode(dev)\n... def circuit():\n...     qml.Select(ops, control=[0, 1], partial=True)\n...     return qml.state()\n...\n>>> print(qml.draw(circuit, level='device')())\n0: \u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2524 \u256dState\n1: \u2500\u251c\u25cb\u2500\u256d\u25cf\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2524 \u251cState\n2: \u2500\u2570X\u2500\u2502\u2500\u2500\u251cSWAP\u2500\u2524 \u251cState\n3: \u2500\u2500\u2500\u2500\u2570X\u2500\u2570SWAP\u2500\u2524 \u2570State\n\nNote how the first (second) control node of the second (third) operator was skipped.\n\n.. details::\n    :title: Unary iterator decomposition\n\n    Generically, ``Select`` is decomposed into one multi-controlled operator for each target\n    operator. However, if auxiliary wires are available, a decomposition using a\n    \"unary iterator\" can be applied. It was introduced by\n    `Babbush et al. (2018) <https://arxiv.org/abs/1805.03662>`__.\n\n    **Principle**\n\n    Unary iteration leverages auxiliary wires to store intermediate values for reuse between\n    the different multi-controlled operators, avoiding unnecessary recomputation.\n    In addition to this caching functionality, unary iteration reduces the cost of the\n    computation directly, because the involved reversible AND (or Toffoli) gates can be\n    implemented at lower cost if the target is known to be in the :math:`|0\\rangle` state\n    (see :class:`~TemporaryAND`).\n\n    For :math:`K` operators to be Select-applied, :math:`c=\\lceil\\log_2 K\\rceil` control\n    wires are required. Unary iteration demands an additional :math:`c-1` auxiliary wires.\n    Below we first show an example for :math:`K` being a power of two, i.e., :math:`K=2^c`.\n    Then we elaborate on implementation details for the case :math:`K<2^c`, which we call\n    a *partial Select* operator.\n\n    **Example**\n\n    Assume that we want to Select-apply :math:`K=8=2^3` operators to two target wires,\n    which requires :math:`c=\\lceil \\log_2 K\\rceil=3` control wires. The generic\n    decomposition for this takes the form\n\n    .. code-block::\n\n        0: \u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2524\n        1: \u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2524\n        2: \u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2524\n        3: \u2500\u251cU(M0)\u2500\u251cU(M1)\u2500\u251cU(M2)\u2500\u251cU(M3)\u2500\u251cU(M4)\u2500\u251cU(M5)\u2500\u251cU(M6)\u2500\u251cU(M7)\u2500\u2524\n        4: \u2500\u2570U(M0)\u2500\u2570U(M1)\u2500\u2570U(M2)\u2500\u2570U(M3)\u2500\u2570U(M4)\u2500\u2570U(M5)\u2500\u2570U(M6)\u2500\u2570U(M7)\u2500\u2524.\n\n    Unary iteration then uses :math:`c-1=2` auxiliary wires, denoted ``aux0`` and ``aux1``\n    below, to first rewrite the control structure:\n\n    .. code-block::\n\n        0:    \u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u256e\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u256e\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u256e\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u256e\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u2524\n        1:    \u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2524\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2524\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2524\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cb\u2524\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u2524\n        aux0:  \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2502\n        2:    \u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u25cb\u2524\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u25cf\u2524\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u25cb\u2524\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u25cf\u2524\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u25cb\u2524\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u25cf\u2524\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u25cb\u2524\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u25cf\u2524\u2500\u2500\u2500\u2524\n        aux1:    \u2570\u2500\u256d\u25cf\u2500\u2500\u256f     \u2570\u2500\u256d\u25cf\u2500\u2500\u256f     \u2570\u2500\u256d\u25cf\u2500\u2500\u256f     \u2570\u2500\u256d\u25cf\u2500\u2500\u256f     \u2570\u2500\u256d\u25cf\u2500\u2500\u256f     \u2570\u2500\u256d\u25cf\u2500\u2500\u256f     \u2570\u2500\u256d\u25cf\u2500\u2500\u256f     \u2570\u2500\u256d\u25cf\u2500\u2500\u256f   \u2502\n        3:    \u2500\u2500\u2500\u2500\u2500\u251cU(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u251cU(M1)\u2500\u2500\u2500\u2500\u2500\u2500\u251cU(M2)\u2500\u2500\u2500\u2500\u2500\u2500\u251cU(M3)\u2500\u2500\u2500\u2500\u2500\u2500\u251cU(M4)\u2500\u2500\u2500\u2500\u2500\u2500\u251cU(M5)\u2500\u2500\u2500\u2500\u2500\u2500\u251cU(M6)\u2500\u2500\u2500\u2500\u2500\u2500\u251cU(M7)\u2500\u2500\u2524\n        4:    \u2500\u2500\u2500\u2500\u2500\u2570U(M0)\u2500\u2500\u2500\u2500\u2500\u2500\u2570U(M1)\u2500\u2500\u2500\u2500\u2500\u2500\u2570U(M2)\u2500\u2500\u2500\u2500\u2500\u2500\u2570U(M3)\u2500\u2500\u2500\u2500\u2500\u2500\u2570U(M4)\u2500\u2500\u2500\u2500\u2500\u2500\u2570U(M5)\u2500\u2500\u2500\u2500\u2500\u2500\u2570U(M6)\u2500\u2500\u2500\u2500\u2500\u2500\u2570U(M7)\u2500\u2500\u2524\n\n    Here, we used the symbols\n\n    .. code-block::\n\n        0: \u2500\u256d\u25cf\u2500\u2500       \u2500\u25cf\u2500\u256e\u2500\n        1: \u2500\u251c\u25cf\u2500\u2500  and  \u2500\u25cf\u2500\u2524\u2500\n        2:  \u2570\u2500\u2500\u2500       \u2500\u2500\u2500\u256f\n\n    for :class:`~.TemporaryAND` and its adjoint, respectively, and skipped drawing the\n    auxiliary wires in areas where they are guaranteed to be in the state :math:`|0\\rangle`.\n    We will need three simplification rules for pairs of ``TemporaryAND`` gates:\n\n    .. code-block::\n\n        \u2500\u25cb\u2500\u256e\u2500\u256d\u25cb\u2500\u2500   \u2500\u2500     \u2500\u25cb\u2500\u256e\u2500\u256d\u25cb\u2500\u2500   \u2500\u256d\u25cb\u2500       \u2500\u25cb\u2500\u256e\u2500\u256d\u25cf\u2500\u2500   \u2500\u256d\u25cf\u2500\u2500\u2500\u2500\n        \u2500\u25cb\u2500\u2524\u2500\u251c\u25cb\u2500\u2500 = \u2500\u2500,    \u2500\u25cb\u2500\u2524\u2500\u251c\u25cf\u2500\u2500 = \u2500\u2502\u2500\u2500, and  \u2500\u25cf\u2500\u2524\u2500\u251c\u25cb\u2500\u2500 = \u2500\u2502\u2500\u2500\u256d\u25cf\u2500.\n        \u2500\u2500\u2500\u256f \u2570\u2500\u2500\u2500   \u2500\u2500     \u2500\u2500\u2500\u256f \u2570\u2500\u2500\u2500   \u2500\u2570X\u2500       \u2500\u2500\u2500\u256f \u2570\u2500\u2500\u2500   \u2500\u2570X\u2500\u2570X\u2500\n\n    Applying these simplifications reduces the computational cost of the ``Select``\n    template:\n\n    .. code-block::\n\n        0:    \u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u2524\n        1:    \u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u2524\n        aux0:  \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u2570X\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u2570X\u2500\u2570X\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u2570X\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u256e\u2500\u256f \u2502\n        2:    \u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2524\u2500\u2500\u2500\u2524\n        aux1:    \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u2570X\u2500\u256d\u25cf\u2500\u2500\u256f    \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u2570X\u2500\u2500\u256d\u25cf\u2500\u2500\u256f       \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u2570X\u2500\u2500\u256d\u25cf\u2500\u2500\u256f    \u2570\u2500\u256d\u25cf\u2500\u2500\u2500\u2570X\u2500\u2500\u256d\u25cf\u2500\u2500\u256f   \u2502\n        3:    \u2500\u2500\u2500\u2500\u2500\u251cU(M0)\u2500\u2500\u251cU(M1)\u2500\u2500\u2500\u2500\u2500\u251cU(M2)\u2500\u2500\u2500\u251cU(M3)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u251cU(M4)\u2500\u2500\u2500\u251cU(M5)\u2500\u2500\u2500\u2500\u2500\u251cU(M6)\u2500\u2500\u2500\u251cU(M7)\u2500\u2500\u2524\n        4:    \u2500\u2500\u2500\u2500\u2500\u2570U(M0)\u2500\u2500\u2570U(M1)\u2500\u2500\u2500\u2500\u2500\u2570U(M2)\u2500\u2500\u2500\u2570U(M3)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570U(M4)\u2500\u2500\u2500\u2570U(M5)\u2500\u2500\u2500\u2500\u2500\u2570U(M6)\u2500\u2500\u2500\u2570U(M7)\u2500\u2500\u2524\n\n    An additional cost reduction then results from the fact that the ``TemporaryAND``\n    gate and its adjoint require four and zero :class:`~T` gates, respectively,\n    in contrast to the seven ``T`` gates required by a decomposition of :class:`~Toffoli`.\n\n    For general :math:`c` and :math:`K=2^c`, the decomposition takes a similar form, with\n    alternating control and auxiliary wires.\n\n    An implementation of the unary iterator is achieved in the following steps:\n    We first define a recursive sub-circuit ``R``;\n    given :math:`L` operators and :math:`2 \\lceil\\log_2(L)\\rceil + 1` control and\n    auxiliary wires, there are three cases that ``R`` distinguishes. First, if ``L>1``,\n    it applies the circuit\n\n    .. code-block::\n\n        aux_j:   \u256dR   \u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u25cf\u2500\u256e\u2500\n        j+1:     \u251cR = \u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2524\u2500\n        aux_j+1: \u2570R    \u2570\u2500\u2500R\u2500\u2500\u2570X\u2500R\u2500\u2500\u2500\u2500\u256f ,\n\n    where each label ``R`` symbolizes a call to ``R`` itself, on the next recursion level.\n    These next-level calls use\n    :math:`L' = 2^{\\lceil\\log_2(L)\\rceil-1}` (i.e. half of :math:`L`, rounded up to the next\n    power of two) and :math:`L-L'` (i.e. the rest) operators, respectively.\n\n    Second, if ``L=1``, the single operator is applied, controlled on the first control wire.\n    Finally, if ``L=0``, ``R`` does not apply any operators.\n\n    With ``R`` defined, we are ready to outline the main circuit structure:\n\n    #. Apply the left-most ``TemporaryAND`` controlled on qubits ``0`` and ``1``.\n    #. Split the target operators into four \"quarters\" (often with varying sizes)\n       and apply the first quarter using ``R``.\n    #. Apply ``[X(0), CNOT([0, \"aux0\"]), X(0)]``.\n    #. Apply the second quarter using ``R``.\n    #. Apply ``[CNOT([0, \"aux0\"]), CNOT([1, \"aux0\"])]``.\n    #. Apply the third quarter using ``R``.\n    #. Apply ``[CNOT([0, \"aux0\"])]``.\n    #. Apply the last quarter using ``R``.\n    #. Apply the right-most ``adjoint(TemporaryAND)`` controlled on qubits ``0`` and ``1``.\n\n    **Partial Select decomposition**\n\n    The unary iterator decomposition of the ``Select`` template can be\n    simplified further if both of the following criteria are met:\n\n    #. There are fewer target operators than would maximally be possible for the given\n       number of control wires, i.e. :math:`K<2^c`.\n\n    #. The state :math:`|\\psi\\rangle` of the control wires satisfies\n       :math:`\\langle j | \\psi\\rangle=0` for all computational basis states with :math:`j\\geq K`.\n\n    We do not derive this reduction here but discuss the modifications to the implementation\n    above that result from it.\n\n    Given :math:`K=2^c-b` operators, where :math:`c` is defined as above and we\n    have :math:`0\\leq b<2^{c-1}`, the nine steps above are modified into one of three variants.\n    In each variant, the first :math:`2^{c-1}` operators are applied in two equal portions,\n    containing :math:`2^{c-2}` operators each.\n    After this, :math:`\\ell=2^{c-1} -b` operators remain and the three circuit variants are\n    distinguished, based on :math:`\\ell`:\n\n    - if :math:`\\ell \\geq 2^{c-2}`, the following, rather generic, circuit is applied:\n\n      .. code-block::\n\n          0:    \u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u256e\u2500\n          1:    \u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2524\u2500\n          aux0:  \u2570\u2500\u2500\u256dR\u2500\u2500\u2570X\u2500\u256dR\u2500\u2500\u2570X\u2500\u2570X\u2500\u256dR\u2500\u2500\u2570X\u2500\u256dR\u2500\u2500\u2500\u2500\u256f\n          2:    \u2500\u2500\u2500\u2500\u251cR\u2500\u2500\u2500\u2500\u2500\u251cR\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u251cR\u2500\u2500\u2500\u2500\u2500\u251cR\u2500\u2500\u2500\u2500\u2500\u2500\n          aux1:     \u2570R     \u2570R        \u2570R     \u2570R      .\n\n      Here, each operator with three ``R`` labels symbolizes a call to ``R``. The first\n      call in the second half applies :math:`2^{\\lceil\\log_2(\\ell)\\rceil-1}` operators.\n      Note that this case is triggered if :math:`K` is larger than or equal to\n      :math:`\\tfrac{3}{4}` of the maximal capacity for :math:`c` control wires.\n      Also note how the two middle ``TemporaryAND`` gates were merged into two CNOTs,\n      like for the non-partial Select operator.\n\n    - if :math:`1<\\ell < 2^{c-2}`, the following circuit is applied:\n\n      .. code-block::\n\n          0:    \u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u256e\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u256e\u2500\n          1:    \u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2524\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\n          aux0:  \u2570\u2500\u2500\u256dR\u2500\u2500\u2570X\u2500\u256dR\u2500\u2500\u2500\u2500\u256f\u2502      \u2502        \u2502\n          2:    \u2500\u2500\u2500\u2500\u251cR\u2500\u2500\u2500\u2500\u2500\u251cR\u2500\u2500\u2500\u2500\u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2524\u2500\n          aux1:     \u2570R     \u2570R     \u2570\u2500\u2500\u2500R\u2500\u2500\u2570X\u2500\u2500R\u2500\u2500\u2500\u2500\u256f\n\n      where the second half may skip more than one control and auxiliary wire each.\n      In this diagram, both the operators with three and one ``R`` labels represent calls to\n      ``R``, with single-label instances applying fewer operators.\n      The first call to ``R`` in the second half applies :math:`2^{\\lceil\\log_2(\\ell)\\rceil-1}`\n      operators. The middle elbows act on distinct wire triples and can not be merged as\n      above.\n\n    - if :math:`\\ell=1`, the following circuit is applied:\n\n      .. code-block::\n\n          0:    \u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u256d\u25cb\u2500\u2500\u2500\u2500\u2500\u25cb\u2500\u256e\u256d\u25cf\u2500\u2500\n          1:    \u2500\u251c\u25cb\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2524\u2502\u2500\u2500\u2500\n          aux0:  \u2570\u2500\u2500\u256dR\u2500\u2500\u2570X\u2500\u256dR\u2500\u2500\u2500\u2500\u256f\u2502\u2500\u2500\u2500\n          2:    \u2500\u2500\u2500\u2500\u251cR\u2500\u2500\u2500\u2500\u2500\u251cR\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\n          aux1:     \u2570R     \u2570R     \u2570U  .\n\n      Here, the three connected ``R`` labels symbolize a call to ``R`` and\n      apply :math:`2^{c-2}` operators each.\n      The controlled gate on the right applies the single remaining operator."
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.select_pauli_rot.SelectPauliRot",
    "summary": "Applies individual single-qubit Pauli rotations depending on the state of designated control qubits.",
    "docstring": "Applies individual single-qubit Pauli rotations depending on the state of\ndesignated control qubits.\n\nThis operator, also called a **multiplexed rotation** or **uniformly controlled rotation**,\napplies a sequence of multi-controlled rotations about the same axis to a single target qubit.\nThe rotation angles are selected based on the state of the control qubits.\nIts definition is given by:\n\n.. math::\n\n   \\sum_i | i \\rangle \\langle i | \\otimes R_P(\\alpha_i),\n\nwhere :math:`| i \\rangle` refers to the computational basis state of the control register,\nthe :math:`\\{\\alpha_i\\}` are the rotation angles, and :math:`R_P` denotes a Pauli rotation\nabout the Pauli operator :math:`P` applied to the target qubit.\n\n.. figure:: ../../../doc/_static/templates/subroutines/select_pauli_rot.png\n                :align: center\n                :width: 70%\n                :target: javascript:void(0);\n\nFor more details, see `M\u00f6tt\u00f6nen and Vartiainen (2005), Fig 7a <https://arxiv.org/abs/quant-ph/0504100>`_.\n\nArgs:\n    angles (tensor_like): The rotation angles to be applied. The length of the angles array must\n        be :math:`2^n`, where :math:`n` is the number of ``control_wires``.\n    control_wires (Sequence[int]): The control qubits used to select the rotation.\n    target_wire (Sequence[int]): The wire where the rotations are applied.\n    rot_axis (str): The axis around which the rotation is performed.\n        It can take the value ``X``, ``Y`` or ``Z``. Default is ``Z``.\n\nRaises:\n    ValueError: If the length of the angles array is not :math:`2^n`, where :math:`n` is the number\n        of ``control_wires``.\n    ValueError: If ``rot_axis`` has a value different from ``X``, ``Y`` or ``Z``.\n    ValueError: If the number of the target wires is not one.\n\n.. seealso:: :class:`~.Select`.\n\n**Example**\n\n.. code-block:: python\n\n    angles = np.array([1.0, 2.0, 3.0, 4.0])\n\n    wires = qml.registers({\"control\": 2, \"target\": 1})\n    dev = qml.device(\"default.qubit\", wires=3)\n\n    @qml.qnode(dev)\n    def circuit():\n        qml.SelectPauliRot(\n            angles,\n            control_wires=wires[\"control\"],\n            target_wire=wires[\"target\"],\n            rot_axis=\"Y\",\n        )\n        return qml.state()\n\n>>> print(circuit()) # doctest: +SKIP\n[0.8776+0.j 0.4794+0.j 0.    +0.j 0.    +0.j 0.    +0.j 0.    +0.j\n 0.    +0.j 0.    +0.j]"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.time_evolution.approx_time_evolution.ApproxTimeEvolution",
    "summary": "Applies the Trotterized time-evolution operator for an arbitrary Hamiltonian, expressed in terms of Pauli gates.",
    "docstring": "Applies the Trotterized time-evolution operator for an arbitrary Hamiltonian, expressed in terms\nof Pauli gates.\n\n.. note::\n\n    We recommend using :class:`~.TrotterProduct` as the more general operation for approximate\n    matrix exponentiation. One can recover the behaviour of :class:`~.ApproxTimeEvolution` by\n    taking the adjoint:\n\n    >>> qml.adjoint(qml.TrotterProduct(hamiltonian, time, order=1, n=n)) # doctest: +SKIP\n\nThe general time-evolution operator for a time-independent Hamiltonian is given by\n\n.. math:: U(t) \\ = \\ e^{-i H t},\n\nfor some Hamiltonian of the form:\n\n.. math:: H \\ = \\ \\displaystyle\\sum_{j} H_j.\n\nImplementing this unitary with a set of quantum gates is difficult, as the terms :math:`H_j` don't\nnecessarily commute with one another. However, we are able to exploit the Trotter-Suzuki decomposition formula,\n\n.. math:: e^{A \\ + \\ B} \\ = \\ \\lim_{n \\to \\infty} \\Big[ e^{A/n} e^{B/n} \\Big]^n,\n\nto implement an approximation of the time-evolution operator as\n\n.. math:: U \\ \\approx \\ \\displaystyle\\prod_{k \\ = \\ 1}^{n} \\displaystyle\\prod_{j} e^{-i H_j t / n},\n\nwith the approximation becoming better for larger :math:`n`.\nThe circuit implementing this unitary is of the form:\n\n.. figure:: ../../_static/templates/subroutines/approx_time_evolution.png\n    :align: center\n    :width: 60%\n    :target: javascript:void(0);\n\nIt is also important to note that\nthis decomposition is exact for any value of :math:`n` when each term of the Hamiltonian\ncommutes with every other term.\n\n.. warning::\n\n    The Trotter-Suzuki decomposition depends on the order of the summed observables. Two mathematically identical :class:`~.LinearCombination` objects may undergo different time evolutions\n    due to the order in which those observables are stored.\n\n.. note::\n\n   This template uses the :class:`~.PauliRot` operation in order to implement\n   exponentiated terms of the input Hamiltonian. This operation only takes\n   terms that are explicitly written in terms of products of Pauli matrices (:class:`~.PauliX`,\n   :class:`~.PauliY`, :class:`~.PauliZ`, and :class:`~.Identity`).\n   Thus, each term in the Hamiltonian must be expressed this way upon input, or else an error will be raised.\n\nArgs:\n    hamiltonian (.Hamiltonian): The Hamiltonian defining the\n       time-evolution operator.\n       The Hamiltonian must be explicitly written\n       in terms of products of Pauli gates (:class:`~.PauliX`, :class:`~.PauliY`,\n       :class:`~.PauliZ`, and :class:`~.Identity`).\n    time (int or float): The time of evolution, namely the parameter :math:`t` in :math:`e^{- i H t}`.\n    n (int): The number of Trotter steps used when approximating the time-evolution operator.\n\n.. seealso:: :class:`~.TrotterProduct`.\n\n.. details::\n    :title: Usage Details\n\n    The template is used inside a qnode:\n\n    .. code-block:: python\n\n        import pennylane as qml\n        from pennylane import ApproxTimeEvolution\n\n        n_wires = 2\n        wires = range(n_wires)\n\n        dev = qml.device('default.qubit', wires=n_wires)\n\n        coeffs = [1, 1]\n        obs = [qml.X(0), qml.X(1)]\n        hamiltonian = qml.Hamiltonian(coeffs, obs)\n\n        @qml.qnode(dev)\n        def circuit(time):\n            ApproxTimeEvolution(hamiltonian, time, 1)\n            return [qml.expval(qml.Z(i)) for i in wires]\n\n    >>> circuit(1)\n    [np.float64(-0.416...), np.float64(-0.416...)]"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.time_evolution.commuting_evolution.CommutingEvolution",
    "summary": "Applies the time-evolution operator for a Hamiltonian expressed as a linear combination of mutually commuting Pauli words.",
    "docstring": "Applies the time-evolution operator for a Hamiltonian expressed as a linear combination\nof mutually commuting Pauli words.\n\nA commuting Hamiltonian is of the form\n\n.. math:: H \\ = \\ \\displaystyle\\sum_{j} c_j P_j,\n\nwhere :math:`P_j` are mutually commutative Pauli words and :math:`c_j` are real coefficients.\nThe time-evolution under a commuting Hamiltonian is given by a unitary of the form\n\n.. math::\n\n    U(t) \\ = \\ e^{-i H t} \\ = \\exp(-i t \\displaystyle\\sum_j c_j P_j) =\n    \\displaystyle\\prod_j \\exp(-i t c_j P_j).\n\nIf the Hamiltonian has a small number of unique eigenvalues, partial derivatives of observable\nexpectation values, i.e.\n\n.. math:: \\langle 0 | W(t)^\\dagger O W(t) | 0 \\rangle,\n\nwhere :math:`W(t) = V U(t) Y` for some :math:`V` and :math:`Y`, taken with respect to\n:math:`t` may be efficiently computed through generalized parameter shift rules. When\ninitialized, this template will automatically compute the parameter-shift rule if given the\nHamiltonian's eigenvalue frequencies, i.e., the unique positive differences between\neigenvalues.\n\n.. warning::\n\n   This template uses the :class:`~.ApproxTimeEvolution` operation with ``n=1`` in order to\n   implement the time evolution, as a single-step Trotterization is exact for a commuting\n   Hamiltonian.\n\n   - If the input Hamiltonian contains Pauli words which do not commute, the\n     compilation of the time evolution operator to a sequence of gates will\n     not equate to the exact propagation under the given Hamiltonian.\n\n   - Furthermore, if the specified frequencies do not correspond to the\n     true eigenvalue frequency spectrum of the commuting Hamiltonian,\n     computed gradients will be incorrect in general.\n\nArgs:\n    hamiltonian (.Hamiltonian): The commuting Hamiltonian defining the time-evolution operator.\n       The Hamiltonian must be explicitly written\n       in terms of products of Pauli gates (:class:`~.PauliX`, :class:`~.PauliY`,\n       :class:`~.PauliZ`, and :class:`~.Identity`).\n    time (int or float): The time of evolution, namely the parameter :math:`t` in :math:`e^{- i H t}`.\n\nKeyword args:\n    frequencies (tuple[int or float]): The unique positive differences between eigenvalues in\n        the spectrum of the Hamiltonian. If the frequencies are not given, the cost function\n        partial derivative will be computed using the standard two-term shift rule applied to\n        the constituent Pauli words in the Hamiltonian individually.\n\n    shifts (tuple[int or float]): The parameter shifts to use in obtaining the\n        generalized parameter shift rules. If unspecified, equidistant shifts are used.\n\n.. details::\n    :title: Usage Details\n\n    The template is used inside a qnode:\n\n    .. code-block:: python\n\n        import pennylane as qml\n\n        n_wires = 2\n        dev = qml.device('default.qubit', wires=n_wires)\n\n        coeffs = [1, -1]\n        obs = [qml.X(0) @ qml.Y(1), qml.Y(0) @ qml.X(1)]\n        hamiltonian = qml.Hamiltonian(coeffs, obs)\n        frequencies = (2, 4)\n\n        @qml.qnode(dev)\n        def circuit(time):\n            qml.X(0)\n            qml.CommutingEvolution(hamiltonian, time, frequencies)\n            return qml.expval(qml.Z(0))\n\n    >>> circuit(1)\n    np.float64(0.653...)"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.time_evolution.qdrift.QDrift",
    "summary": "An operation representing the QDrift approximation for the complex matrix exponential of a given Hamiltonian.",
    "docstring": "An operation representing the QDrift approximation for the complex matrix exponential\nof a given Hamiltonian.\n\nThe QDrift subroutine provides a method to approximate the matrix exponential of a Hamiltonian\nexpressed as a linear combination of terms which in general do not commute. For the Hamiltonian\n:math:`H = \\Sigma_j h_j H_{j}`, the product formula is constructed by random sampling from the\nterms of the Hamiltonian with the probability :math:`p_j = h_j / \\sum_{j} hj` as:\n\n.. math::\n\n    \\prod_{j}^{n} e^{i \\lambda H_j \\tau / n},\n\nwhere :math:`\\tau` is time, :math:`\\lambda = \\sum_j |h_j|` and :math:`n` is the total number of\nterms to be sampled and added to the product. Note, the terms :math:`H_{j}` are assumed to be\nnormalized such that the \"impact\" of each term is fully encoded in the magnitude of :math:`h_{j}`.\n\nThe number of samples :math:`n` required for a given error threshold can be approximated by:\n\n.. math::\n\n    n \\ \\approx \\ \\frac{2\\lambda^{2}t^{2}}{\\epsilon}\n\nFor more details see `Phys. Rev. Lett. 123, 070503 (2019) <https://arxiv.org/abs/1811.08017>`_.\n\nArgs:\n    hamiltonian (Union[.Hamiltonian, .Sum]): The Hamiltonian written as a sum of operations\n    time (float): The time of evolution, namely the parameter :math:`t` in :math:`e^{iHt}`\n    n (int): An integer representing the number of exponentiated terms.\n    seed (int): The seed for the random number generator.\n\nRaises:\n    TypeError: The ``hamiltonian`` is not of type :class:`~.Sum`\n    QuantumFunctionError: If the coefficients of ``hamiltonian`` are trainable and are used\n        in a differentiable workflow.\n    ValueError: If there is only one term in the Hamiltonian.\n\n**Example**\n\n.. code-block:: python\n\n    coeffs = [0.25, 0.75]\n    ops = [qml.X(0), qml.Z(0)]\n    H = qml.dot(coeffs, ops)\n\n    dev = qml.device(\"default.qubit\", wires=2)\n    @qml.qnode(dev)\n    def my_circ():\n        # Prepare some state\n        qml.Hadamard(0)\n\n        # Evolve according to H\n        qml.QDrift(H, time=1.2, n=10, seed=10)\n\n        # Measure some quantity\n        return qml.probs()\n\n>>> my_circ()\narray([0.653..., 0.        , 0.346..., 0.        ])\n\n.. note::\n\n    The option to pass a custom ``decomposition`` to ``QDrift`` has been removed.\n    Instead, the custom decomposition can be applied using :func:`~.pennylane.apply`\n    on all operations in the decomposition.\n\n.. details::\n    :title: Usage Details\n\n    We currently **Do NOT** support computing gradients with respect to the\n    coefficients of the input Hamiltonian. We can however compute the gradient\n    with respect to the evolution time:\n\n    .. code-block:: python\n\n        dev = qml.device(\"default.qubit\", wires=2)\n\n        @qml.qnode(dev)\n        def my_circ(time):\n            # Prepare H:\n            H = qml.dot([0.2, -0.1], [qml.Y(0), qml.Z(1)])\n\n            # Prepare some state\n            qml.Hadamard(0)\n\n            # Evolve according to H\n            qml.QDrift(H, time, n=10, seed=10)\n\n            # Measure some quantity\n            return qml.expval(qml.Z(0) @ qml.Z(1))\n\n\n    >>> time = qml.numpy.array(1.23)\n    >>> print(qml.grad(my_circ)(time))\n    0.279...\n\n    The error in the approximation of time evolution with the QDrift protocol is\n    directly related to the number of samples used in the product. We provide a\n    method to upper-bound the error:\n\n    >>> H = qml.dot([0.25, 0.75], [qml.X(0), qml.Z(0)])\n    >>> print(qml.QDrift.error(H, time=1.2, n=10))\n    0.3661197552925645"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.time_evolution.trotter.TrotterProduct",
    "summary": "An operation representing the Suzuki-Trotter product approximation for the complex matrix exponential of a given Hamiltonian.",
    "docstring": "An operation representing the Suzuki-Trotter product approximation for the complex matrix\nexponential of a given Hamiltonian.\n\nThe Suzuki-Trotter product formula provides a method to approximate the matrix exponential of\nHamiltonian expressed as a linear combination of operands which in general do not commute.\nConsider the Hamiltonian :math:`H = \\Sigma^{N}_{j=0} O_{j}`, the product formula is constructed\nusing symmetrized products of the terms in the Hamiltonian. The symmetrized products of order\n:math:`m \\in [1, 2, 4, ..., 2k]` with :math:`k \\in \\mathbb{N}` are given by:\n\n.. math::\n\n    \\begin{align}\n        S_{1}(t) &= \\Pi_{j=0}^{N} \\ e^{i t O_{j}} \\\\\n        S_{2}(t) &= \\Pi_{j=0}^{N} \\ e^{i \\frac{t}{2} O_{j}} \\cdot \\Pi_{j=N}^{0} \\ e^{i \\frac{t}{2} O_{j}} \\\\\n        &\\vdots \\\\\n        S_{m}(t) &= S_{m-2}(p_{m}t)^{2} \\cdot S_{m-2}((1-4p_{m})t) \\cdot S_{m-2}(p_{m}t)^{2},\n    \\end{align}\n\nwhere the coefficient is :math:`p_{m} = 1 / (4 - \\sqrt[m - 1]{4})`. The :math:`m^{\\text{th}}` order,\n:math:`n`\\ -step Suzuki-Trotter approximation is then defined as:\n\n.. math:: e^{iHt} \\approx \\left [S_{m}(t / n)  \\right ]^{n}.\n\nFor more details see `J. Math. Phys. 32, 400 (1991) <https://pubs.aip.org/aip/jmp/article-abstract/32/2/400/229229>`_.\n\nArgs:\n    hamiltonian (Union[.Hamiltonian, .Sum, .SProd]): The Hamiltonian written as a linear combination\n        of operators with known matrix exponentials.\n    time (float): The time of evolution, namely the parameter :math:`t` in :math:`e^{iHt}`\n    n (int): An integer representing the number of Trotter steps to perform\n    order (int): An integer (:math:`m`) representing the order of the approximation (must be 1 or even)\n    check_hermitian (bool): A flag to enable the validation check to ensure this is a valid unitary operator\n\nRaises:\n    TypeError: The ``hamiltonian`` is not of type :class:`~.Sum`.\n    ValueError: The ``hamiltonian`` has only one term or no terms.\n    ValueError: One or more of the terms in ``hamiltonian`` are not Hermitian\n        (only for ``check_hermitian=True``)\n    ValueError: The ``order`` is not one or a positive even integer.\n\n**Example**\n\n.. code-block:: python\n\n    coeffs = [0.25, 0.75]\n    ops = [qml.X(0), qml.Z(0)]\n    H = qml.dot(coeffs, ops)\n\n    dev = qml.device(\"default.qubit\", wires=2)\n    @qml.qnode(dev)\n    def my_circ():\n        # Prepare some state\n        qml.Hadamard(0)\n\n        # Evolve according to H\n        qml.TrotterProduct(H, time=2.4, order=2)\n\n        # Measure some quantity\n        return qml.state()\n\n>>> my_circ()\narray([-0.132...+0.597...j,  0.        +0.j        , -0.132...-0.779...j,  0.        +0.j        ])\n\n.. warning::\n\n    The Trotter-Suzuki decomposition depends on the order of the summed observables. Two\n    mathematically identical :class:`~.LinearCombination` objects may undergo different time\n    evolutions due to the order in which those observables are stored. The order of observables\n    can be queried using the :attr:`~.Sum.operands` attribute. Also see the advanced example\n    below.\n\n.. warning::\n\n    ``TrotterProduct`` does not automatically simplify the input Hamiltonian. This allows\n    for a more fine-grained control over the decomposition but also risks an increased\n    runtime and/or number of gates. Simplification can be performed manually by\n    applying :func:`~.simplify` to your Hamiltonian before using it in ``TrotterProduct``.\n\n.. details::\n    :title: Usage Details\n\n    An *upper-bound* for the error in approximating time-evolution using this operator can be\n    computed by calling :func:`~.TrotterProduct.error()`. It is computed using two different\n    methods; the \"one-norm-bound\" scaling method and the \"commutator-bound\" scaling method.\n    (see `Childs et al. (2021) <https://arxiv.org/abs/1912.08854>`_)\n\n    >>> hamiltonian = qml.dot([1.0, 0.5, -0.25], [qml.X(0), qml.Y(0), qml.Z(0)])\n    >>> op = qml.TrotterProduct(hamiltonian, time=0.01, order=2)\n    >>> op.error(method=\"one-norm-bound\")\n    SpectralNormError(8.039062500000003e-06)\n    >>> op.error(method=\"commutator-bound\")\n    SpectralNormError(6.166666666666668e-06)\n\n    This operation is similar to the :class:`~.ApproxTimeEvolution`. One can recover the behaviour\n    of :class:`~.ApproxTimeEvolution` by taking the adjoint:\n\n    >>> qml.adjoint(qml.TrotterProduct(hamiltonian, time, order=1, n=n)) # doctest: +SKIP\n\n    The grouping of terms in the ``operands`` attribute of the ``hamiltonian`` impacts\n    the structure of the gates created by ``TrotterProduct``. To understand this, first\n    consider this simple two-qubit Hamiltonian with four Pauli word terms:\n\n    >>> coeffs = [0.5, 0.2, 0.1, -0.6]\n    >>> ops = [qml.X(0), qml.Y(1), qml.Y(0) @ qml.Z(1), qml.X(0) @ qml.Y(1)]\n    >>> H_flat = qml.dot(coeffs, ops)\n    >>> H_flat\n    (\n        0.5 * X(0)\n    + 0.2 * Y(1)\n    + 0.1 * (Y(0) @ Z(1))\n    + -0.6 * (X(0) @ Y(1))\n    )\n    >>> print(*H_flat.operands, sep=\"\\n\")\n    0.5 * X(0)\n    0.2 * Y(1)\n    0.1 * (Y(0) @ Z(1))\n    -0.6 * (X(0) @ Y(1))\n\n    As we can see, each Pauli word contributes an individual operand. As a result, the\n    ``TrotterProduct`` (of first order, for simplicity) of this Hamiltonian will contain four\n    exponentials per Trotter step:\n\n    >>> qml.TrotterProduct(H_flat, 1., n=1, order=1).decomposition()\n    [Evolution(1j -0.6 * (X(0) @ Y(1))), Evolution(1j 0.1 * (Y(0) @ Z(1))), Evolution(1j 0.2 * Y(1)), Evolution(1j 0.5 * X(0))]\n\n    If we first create two operands with two Pauli words each and then sum those, this is\n    reflected in the structure of the operator:\n\n    >>> H_grouped = qml.sum(qml.dot(coeffs[:2], ops[:2]), qml.dot(coeffs[2:], ops[2:]))\n    >>> print(*H_grouped.operands, sep=\"\\n\")\n    0.5 * X(0) + 0.2 * Y(1)\n    0.1 * (Y(0) @ Z(1)) + -0.6 * (X(0) @ Y(1))\n\n    The ``TrotterProduct`` accordingly has a different structure as well:\n\n    >>> qml.TrotterProduct(H_grouped, 1., n=1, order=1).decomposition()\n    [Evolution(1j 0.1 * (Y(0) @ Z(1)) + -0.6 * (X(0) @ Y(1))), Evolution(1j 0.5 * X(0) + 0.2 * Y(1))]\n\n\n    As we can see, the ``operands`` structure of the Hamiltonian directly impacts the\n    constructed Trotter circuit, and in general, those circuits will be different\n    approximations to the true time evolution.\n\n    We can also compute the gradient with respect to the coefficients of the Hamiltonian and the\n    evolution time. Note that this is currently only possible with backprop. \n\n    .. code-block:: python\n\n        @qml.qnode(dev, diff_method=\"backprop\")\n        def my_circ(c1, c2, time):\n            # Prepare H:\n            H = qml.dot([c1, c2], [qml.X(0), qml.Z(0)])\n\n            # Prepare some state\n            qml.Hadamard(0)\n\n            # Evolve according to H\n            qml.TrotterProduct(H, time, order=2)\n\n            # Measure some quantity\n            return qml.expval(qml.Z(0) @ qml.Z(1))\n\n    >>> args = qml.numpy.array([1.23, 4.5, 0.1])\n    >>> qml.grad(my_circ)(*tuple(args))\n    (tensor(0.077..., requires_grad=True), tensor(0.015..., requires_grad=True), tensor(1.642..., requires_grad=True))"
  },
  {
    "name": "/pennylane/pennylane.templates.subroutines.time_evolution.trotter.TrotterizedQfunc",
    "summary": "An operation representing the Suzuki-Trotter product approximation applied to a set of operations defined in a function.",
    "docstring": "An operation representing the Suzuki-Trotter product approximation applied to a set of\noperations defined in a function.\n\nThe Suzuki-Trotter product formula provides a method to approximate the matrix exponential of\na Hamiltonian expressed as a linear combination of terms which in general do not commute. Consider\nthe Hamiltonian :math:`H = \\Sigma^{N}_{j=0} O_{j}`, the product formula is constructed using\nsymmetrized products of the terms in the Hamiltonian. The symmetrized products of order\n:math:`m \\in [1, 2, 4, ..., 2k]` with :math:`k \\in \\mathbb{N}` are given by:\n\n.. math::\n\n    \\begin{align}\n        S_{1}(t) &= \\Pi_{j=0}^{N} \\ e^{i t O_{j}} \\\\\n        S_{2}(t) &= \\Pi_{j=0}^{N} \\ e^{i \\frac{t}{2} O_{j}} \\cdot \\Pi_{j=N}^{0} \\ e^{i \\frac{t}{2} O_{j}} \\\\\n        &\\vdots \\\\\n        S_{m}(t) &= S_{m-2}(p_{m}t)^{2} \\cdot S_{m-2}((1-4p_{m})t) \\cdot S_{m-2}(p_{m}t)^{2},\n    \\end{align}\n\nwhere the coefficient is :math:`p_{m} = 1 / (4 - \\sqrt[m - 1]{4})`. The :math:`m`th order,\n:math:`n`-step Suzuki-Trotter approximation is then defined as:\n\n.. math:: e^{iHt} \\approx \\left [S_{m}(t / n)  \\right ]^{n}.\n\nFor more details see `J. Math. Phys. 32, 400 (1991) <https://pubs.aip.org/aip/jmp/article-abstract/32/2/400/229229>`_.\n\nSuppose we have direct access to the operators which represent the exponentiated terms of\na hamiltonian:\n\n.. math:: \\{ \\hat{U}_{j} = e^{i t O_{j}}, j \\in [1, N] \\}.\n\nGiven a quantum circuit which uses these :math:`\\hat{U}_{j}` operators to represent the\nfirst order expansion :math:`S_{1}(t)`; this class expands it to any higher order Suzuki-Trotter product.\n\n.. warning::\n\n    :code:`TrotterizedQfunc` requires that the input function has a very specific function signature.\n    The first argument should be a time parameter which will be modified according to the Suzuki-Trotter\n    product formula. The wires required by the circuit should be either the last explicit argument or the\n    first keyword argument. :code:`qfunc((time, arg1, ..., arg_n, wires=[...], kwarg_1, ..., kwarg_n))`\n\n.. warning::\n\n    :code:`TrotterizedQfunc` currently does not support pickling. Instead please decompose the operation\n    first before attempting to pickle the quantum circuit.\n\nArgs:\n    time (float): the time of evolution, namely the parameter :math:`t` in :math:`e^{iHt}`\n    *trainable_args (tuple): the trainable arguments of the first-order expansion function\n    qfunc (Callable): the first-order expansion given as a callable function which queues operations\n    wires (Iterable): the set of wires the operation will act upon (should be identical to qfunc wires)\n    n (int): an integer representing the number of Trotter steps to perform\n    order (int): an integer (:math:`m`) representing the order of the approximation (must be 1 or even)\n    reverse (bool): if true, reverse the order of the operations queued by :code:`qfunc`\n    **non_trainable_kwargs (dict): non-trainable keyword arguments of the first-order expansion function\n\nRaises:\n    ValueError: A qfunc must be provided to be trotterized.\n\nSee also :func:`~.trotterize`.\n\n**Example**\n\n.. code-block:: python\n\n    def first_order_expansion(time, theta, phi, wires=[0, 1, 2], flip=False):\n        \"This is the first order expansion (U_1).\"\n        qml.RX(time*theta, wires[0])\n        qml.RY(time*phi, wires[1])\n        if flip:\n            qml.CNOT(wires=wires[:2])\n\n    @qml.qnode(qml.device(\"default.qubit\"))\n    def my_circuit(time, angles, num_trotter_steps):\n        qml.TrotterizedQfunc(\n            time,\n            *angles,\n            qfunc=first_order_expansion,\n            n=num_trotter_steps,\n            order=2,\n            wires=['a', 'b'],\n            flip=True,\n        )\n        return qml.state()\n\nWe can visualize the circuit to see the Suzuki-Trotter product formula being applied:\n\n>>> time = 0.1\n>>> angles = (0.12, -3.45)\n>>> print(qml.draw(my_circuit, level=\"device\")(time, angles, num_trotter_steps=1))\na: \u2500\u2500RX(0.01)\u2500\u2500\u256d\u25cf\u2500\u256d\u25cf\u2500\u2500RX(0.01)\u2500\u2500\u2524  State\nb: \u2500\u2500RY(-0.17)\u2500\u2570X\u2500\u2570X\u2500\u2500RY(-0.17)\u2500\u2524  State\n>>>\n>>> print(qml.draw(my_circuit, level=\"device\")(time, angles, num_trotter_steps=3))\na: \u2500\u2500RX(0.00)\u2500\u2500\u256d\u25cf\u2500\u256d\u25cf\u2500\u2500RX(0.00)\u2500\u2500\u2500RX(0.00)\u2500\u2500\u256d\u25cf\u2500\u256d\u25cf\u2500\u2500RX(0.00)\u2500\u2500\u2500RX(0.00)\u2500\u2500\u256d\u25cf\u2500\u256d\u25cf\u2500\u2500RX(0.00)\u2500\u2500\u2524  State\nb: \u2500\u2500RY(-0.06)\u2500\u2570X\u2500\u2570X\u2500\u2500RY(-0.06)\u2500\u2500RY(-0.06)\u2500\u2570X\u2500\u2570X\u2500\u2500RY(-0.06)\u2500\u2500RY(-0.06)\u2500\u2570X\u2500\u2570X\u2500\u2500RY(-0.06)\u2500\u2524  State"
  },
  {
    "name": "/pennylane/pennylane.templates.swapnetworks.ccl2.TwoLocalSwapNetwork",
    "summary": "Apply two-local gate operations using a canonical 2-complete linear (2-CCL) swap network.",
    "docstring": "Apply two-local gate operations using a canonical 2-complete linear (2-CCL) swap network.\n\nArgs:\n    wires (Iterable or Wires): ordered sequence of wires on which the swap network acts\n    acquaintances (Callable): callable `func(index, wires, param=None, **kwargs)` that returns\n        a two-local operation applied on a pair of logical wires specified by `index` currently\n        stored in physical wires provided by `wires` before they are swapped apart.\n        Parameters for the operation are specified using `param`, and any additional\n        keyword arguments for the callable should be provided using the ``kwargs`` separately\n    weights (tensor): weight tensor for the parametrized acquaintances of length\n        :math:`N \\times (N - 1) / 2`, where `N` is the length of `wires`\n    fermionic (bool): If ``True``, qubits are realized as fermionic modes and :class:`~.pennylane.FermionicSWAP` with :math:`\\phi=\\pi` is used instead of :class:`~.pennylane.SWAP`\n    shift (bool): If ``True``, odd-numbered layers begins from the second qubit instead of first one\n    **kwargs: additional keyword arguments for `acquaintances`\n\nRaises:\n    ValueError: if inputs do not have the correct format\n\n**Example**\n\n>>> import pennylane as qml\n>>> dev = qml.device('default.qubit', wires=5)\n>>> acquaintances = lambda index, wires, param=None: qml.CNOT(index)\n>>> @qml.qnode(dev)\n... def swap_network_circuit():\n...    qml.templates.TwoLocalSwapNetwork(dev.wires, acquaintances, fermionic=True, shift=False)\n...    return qml.state()\n>>> print(qml.draw(swap_network_circuit, level='device')())\n0: \u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2524 \u256dState\n1: \u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u2524 \u251cState\n2: \u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2524 \u251cState\n3: \u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u256d\u25cf\u2500\u256dfSWAP(3.14)\u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u2524 \u251cState\n4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2570fSWAP(3.14)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2570State\n\n.. details::\n    :title: Usage Details\n\n    More complex acquaintances can be utilized with the template. For example:\n\n    >>> dev = qml.device('default.qubit', wires=5)\n    >>> rng = np.random.default_rng(12345)\n    >>> weights = rng.random(size=qml.TwoLocalSwapNetwork.shape(len(dev.wires)))\n    >>> print(weights) # doctest: +SKIP\n    [0.2273 0.3168 0.7974 0.6763 0.3911 0.3328 0.5983 0.1867 0.6728 0.9418]\n    >>> acquaintances = lambda index, wires, param: (qml.CRY(param, wires=index)\n    ...                                  if np.abs(wires[0]-wires[1]) else qml.CRZ(param, wires=index))\n    >>> @qml.qnode(dev)\n    ... def swap_network_circuit():\n    ...    qml.templates.TwoLocalSwapNetwork(dev.wires, acquaintances, weights, fermionic=False)\n    ...    return qml.state()\n    >>> print(qml.draw(swap_network_circuit, level='device')())\n    0: \u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2524 \u256dState\n    1: \u2500\u2570RY(0.23)\u2500\u2570SWAP\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2570RY(0.39)\u2500\u2570SWAP\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2570RY(0.67)\u2500\u2570SWAP\u2500\u2524 \u251cState\n    2: \u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2570RY(0.80)\u2500\u2570SWAP\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2570RY(0.60)\u2500\u2570SWAP\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2524 \u251cState\n    3: \u2500\u2570RY(0.32)\u2500\u2570SWAP\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2570RY(0.33)\u2500\u2570SWAP\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2570RY(0.94)\u2500\u2570SWAP\u2500\u2524 \u251cState\n    4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570RY(0.68)\u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570RY(0.19)\u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2570State"
  },
  {
    "name": "/pennylane/pennylane.templates.tensornetworks.mera.MERA",
    "summary": "The MERA template broadcasts an input circuit across many wires following the architecture of a multi-scale entanglement renormalization ansatz tensor network. This architecture can be found in `arXiv:quant-ph/0610099 <https://arxiv.org/abs/quant-ph/0610099>`_ and closely resembles `quantum convolutional neural networks <https://arxiv.org/abs/1810.03787>`_.",
    "docstring": "The MERA template broadcasts an input circuit across many wires following the\narchitecture of a multi-scale entanglement renormalization ansatz tensor network.\nThis architecture can be found in `arXiv:quant-ph/0610099 <https://arxiv.org/abs/quant-ph/0610099>`_\nand closely resembles `quantum convolutional neural networks <https://arxiv.org/abs/1810.03787>`_.\n\nThe argument ``block`` is a user-defined quantum circuit. Each ``block`` may depend on a different set of parameters.\nThese are passed as a list by the ``template_weights`` argument.\n\nFor more details, see *Usage Details* below.\n\nArgs:\n    wires (Iterable): wires that the template acts on\n    n_block_wires (int): number of wires per block\n    block (Callable): quantum circuit that defines a block\n    n_params_block (int): the number of parameters in a block\n    template_weights (Sequence): list containing the weights for all blocks\n\n.. details::\n    :title: Usage Details\n\n    In general, the block takes D parameters and **must** have the following signature:\n\n    .. code-block::\n\n        unitary(parameter1, parameter2, ... parameterD, wires)\n\n    For a block with multiple parameters, ``n_params_block`` is equal to the number of parameters in ``block``.\n    For a block with a single parameter, ``n_params_block`` is equal to the length of the parameter array.\n\n    To avoid using ragged arrays, all block parameters should have the same dimension.\n\n    The length of the ``template_weights`` argument should match the number of blocks.\n    The expected number of blocks can be obtained from ``qml.MERA.get_n_blocks(wires, n_block_wires)``.\n\n    This example demonstrates the use of ``MERA`` for a simple block.\n\n    .. code-block:: python\n\n        import pennylane as qml\n        import numpy as np\n\n        def block(weights, wires):\n            qml.CNOT(wires=[wires[0],wires[1]])\n            qml.RY(weights[0], wires=wires[0])\n            qml.RY(weights[1], wires=wires[1])\n\n        n_wires = 4\n        n_block_wires = 2\n        n_params_block = 2\n        n_blocks = qml.MERA.get_n_blocks(range(n_wires),n_block_wires)\n        template_weights = [[0.1,-0.3]]*n_blocks\n\n        dev= qml.device('default.qubit',wires=range(n_wires))\n        @qml.qnode(dev)\n        def circuit(template_weights):\n            qml.MERA(range(n_wires),n_block_wires,block, n_params_block, template_weights)\n            return qml.expval(qml.Z(1))\n\n    It may be necessary to reorder the wires to see the MERA architecture clearly:\n\n    >>> print(qml.draw(circuit, level='device', wire_order=[2,0,1,3])(template_weights))\n    2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u256dX\u2500\u2500RY(-0.30)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    0: \u2500\u256dX\u2500\u2500RY(-0.30)\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u256d\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2524\n    1: \u2500\u2570\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dX\u2500\u2500RY(-0.30)\u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u2524  <Z>\n    3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u2570\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524"
  },
  {
    "name": "/pennylane/pennylane.templates.tensornetworks.mps.MPS",
    "summary": "The MPS template broadcasts an input circuit across many wires following the architecture of a Matrix Product State tensor network. The result is similar to the architecture in `arXiv:1803.11537 <https://arxiv.org/abs/1803.11537>`_.",
    "docstring": "The MPS template broadcasts an input circuit across many wires following the architecture of a Matrix Product State tensor network.\nThe result is similar to the architecture in `arXiv:1803.11537 <https://arxiv.org/abs/1803.11537>`_.\n\nThe keyword argument ``block`` is a user-defined quantum circuit that should accept two arguments: ``wires`` and ``weights``.\nThe latter argument is optional in case the implementation of ``block`` doesn't require any weights. Any additional arguments\nshould be provided using the ``kwargs``.\n\nArgs:\n    wires (Iterable): wires that the template acts on\n    n_block_wires (int): number of wires per block\n    block (Callable): quantum circuit that defines a block\n    n_params_block (int): the number of parameters in a block; equal to the length of the ``weights`` argument in ``block``\n    template_weights (Sequence): list containing the weights for all blocks\n    offset (int): offset value for positioning the subsequent blocks relative to each other.\n        If ``None``, it defaults to :math:`\\text{offset} = \\lfloor \\text{n_block_wires}/2  \\rfloor`,\n        otherwise :math:`\\text{offset} \\in [1, \\text{n_block_wires} - 1]`\n    **kwargs: additional keyword arguments for implementing the ``block``\n\n.. note::\n\n    The expected number of blocks can be obtained from ``qml.MPS.get_n_blocks(wires, n_block_wires, offset=0)``, and\n    the length of ``template_weights`` argument should match the number of blocks. Whenever either ``n_block_wires``\n    is odd or ``offset`` is not :math:`\\lfloor \\text{n_block_wires}/2  \\rfloor`, the template deviates from the maximally\n    unbalanced tree architecture described in `arXiv:1803.11537 <https://arxiv.org/abs/1803.11537>`_.\n\n.. details::\n    :title: Usage Details\n\n    This example demonstrates the use of ``MPS`` for a simple block.\n\n    .. code-block:: python\n\n        import pennylane as qml\n        import numpy as np\n\n        def block(weights, wires):\n            qml.CNOT(wires=[wires[0],wires[1]])\n            qml.RY(weights[0], wires=wires[0])\n            qml.RY(weights[1], wires=wires[1])\n\n        n_wires = 4\n        n_block_wires = 2\n        n_params_block = 2\n        n_blocks = qml.MPS.get_n_blocks(range(n_wires),n_block_wires)\n        template_weights = [[0.1, -0.3]] * n_blocks\n\n        dev= qml.device('default.qubit',wires=range(n_wires))\n        @qml.qnode(dev)\n        def circuit(template_weights):\n            qml.MPS(range(n_wires),n_block_wires,block, n_params_block, template_weights)\n            return qml.expval(qml.Z(n_wires-1))\n\n    >>> print(qml.draw(circuit, level='device')(template_weights))\n    0: \u2500\u256d\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    1: \u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u256d\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u256d\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2524\n    3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u2524  <Z>\n\n    MPS can also be used with an ``offset`` argument that shifts the positioning the subsequent blocks from the default ``n_block_wires/2``.\n\n    .. code-block:: python\n\n        import pennylane as qml\n        import numpy as np\n\n        def block(wires):\n            qml.MultiControlledX(wires=[wires[i] for i in range(len(wires))])\n\n        n_wires = 8\n        n_block_wires = 4\n        n_params_block = 2\n\n        dev= qml.device('default.qubit',wires=n_wires)\n        @qml.qnode(dev)\n        def circuit():\n            qml.MPS(range(n_wires),n_block_wires, block, n_params_block, offset = 1)\n            return qml.state()\n\n    >>> print(qml.draw(circuit, level='device')())\n        0: \u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u256dState\n        1: \u2500\u251c\u25cf\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cState\n        2: \u2500\u251c\u25cf\u2500\u251c\u25cf\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cState\n        3: \u2500\u2570X\u2500\u251c\u25cf\u2500\u251c\u25cf\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2524 \u251cState\n        4: \u2500\u2500\u2500\u2500\u2570X\u2500\u251c\u25cf\u2500\u251c\u25cf\u2500\u256d\u25cf\u2500\u2524 \u251cState\n        5: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u251c\u25cf\u2500\u251c\u25cf\u2500\u2524 \u251cState\n        6: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u251c\u25cf\u2500\u2524 \u251cState\n        7: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2524 \u2570State"
  },
  {
    "name": "/pennylane/pennylane.templates.tensornetworks.ttn.TTN",
    "summary": "The TTN template broadcasts an input circuit across many wires following the architecture of a tree tensor network. The result is similar to the architecture in `arXiv:1803.11537 <https://arxiv.org/abs/1803.11537>`_.",
    "docstring": "The TTN template broadcasts an input circuit across many wires following the architecture of a tree tensor network.\nThe result is similar to the architecture in `arXiv:1803.11537 <https://arxiv.org/abs/1803.11537>`_.\n\nThe argument ``block`` is a user-defined quantum circuit. Each ``block`` may depend on a different set of parameters.\nThese are passed as a list by the ``template_weights`` argument.\n\nFor more details, see *Usage Details* below.\n\nArgs:\n    wires (Iterable): wires that the template acts on\n    n_block_wires (int): number of wires per block\n    block (Callable): quantum circuit that defines a block\n    n_params_block (int): the number of parameters in a block\n    template_weights (Sequence): list containing the weights for all blocks\n\n.. details::\n    :title: Usage Details\n\n    In general, the block takes D parameters and **must** have the following signature:\n\n    .. code-block::\n\n        unitary(parameter1, parameter2, ... parameterD, wires)\n\n    For a block with multiple parameters, ``n_params_block`` is equal to the number of parameters in ``block``.\n    For a block with a single parameter, ``n_params_block`` is equal to the length of the parameter.\n\n    To avoid using ragged arrays, all block parameters should have the same dimension.\n\n    The length of the ``template_weights`` argument should match the number of blocks.\n    The expected number of blocks can be obtained from ``qml.TTN.get_n_blocks(wires, n_block_wires)``.\n\n    This example demonstrates the use of ``TTN`` for a simple block.\n\n    .. code-block:: python\n\n        import pennylane as qml\n        import numpy as np\n\n        def block(weights, wires):\n            qml.CNOT(wires=[wires[0],wires[1]])\n            qml.RY(weights[0], wires=wires[0])\n            qml.RY(weights[1], wires=wires[1])\n\n        n_wires = 4\n        n_block_wires = 2\n        n_params_block = 2\n        n_blocks = qml.TTN.get_n_blocks(range(n_wires),n_block_wires)\n        template_weights = [[0.1,-0.3]]*n_blocks\n\n        dev= qml.device('default.qubit',wires=range(n_wires))\n        @qml.qnode(dev)\n        def circuit(template_weights):\n            qml.TTN(range(n_wires),n_block_wires,block, n_params_block, template_weights)\n            return qml.expval(qml.Z(n_wires-1))\n\n    >>> print(qml.draw(circuit, level='device')(template_weights))\n    0: \u2500\u256d\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    1: \u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u256d\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2524\n    2: \u2500\u256d\u25cf\u2500\u2500RY(0.10)\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    3: \u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u2524  <Z>"
  }
]