[
  {
    "name": "/classiq/open_library.functions.amplitude_amplification.amplitude_amplification",
    "summary": "Applies the Amplitude Amplification algorithm; Prepares a state using the given `space_transform` function, and applies `reps` repetititions of the grover operator, using the given `oracle` functions which marks the \"good\" states.",
    "docstring": "Applies the Amplitude Amplification algorithm; Prepares a state using the given `space_transform` function, and applies `reps` repetititions\nof the grover operator, using the given `oracle` functions which marks the \"good\" states.\n\nArgs:\n    reps: Number of repetitions to apply the grover operator on the initial state. Should be determined by the user, according to the calculated amplification.\n    oracle: The oracle operator that marks the \"good\" states. This operator should flip the sign of the amplitude of the \"good\" state.\n    space_transform: The space transform operator (which is known also the state preparation operator). First applied to prepare the state before the amplification, then used inside the Grover operator.\n    packed_vars: The variable that holds the state to be amplified. Assumed to be in the zero state at the beginning of the algorithm."
  },
  {
    "name": "/classiq/open_library.functions.amplitude_amplification.exact_amplitude_amplification",
    "summary": "Applies an exact version of the Amplitude Amplification algorithm, assuming knowledge of the amplitude of the marked state. The function should be applied on the zero state, and it takes care for preparing the initial state before amplification using the `space_transform`.",
    "docstring": "Applies an exact version of the Amplitude Amplification algorithm, assuming knowledge of the amplitude of the marked state.\nThe function should be applied on the zero state, and it takes care for preparing the initial state before amplification using the `space_transform`.\n\nBased on the algorithm in [Quantum state preparation without coherent arithmetic](https://arxiv.org/abs/2210.14892).\n\nAssuming the `space_transform` creates a state $|\\psi\\rangle = a|\\psi_{good}\\rangle + \\sqrt{1-a}|\\psi_{bad}\\rangle$, given `a` as the `amplitude`\nargument, the function will load exactly the state $|\\psi_{good}\\rangle$.\n\nNote: if the `amplitude` argument is not exact, the resulting state will not be exactly $|\\psi_{good}\\rangle$, and there will be additional internal auxilliary of the function that is not released correctly.\n\nArgs:\n    amplitude: The amplitude of the state $|\\psi_{good}\\rangle$ with regards to the initial state prepared by `space_transform`.\n    oracle: The oracle operator that marks the \"good\" states. This operator should flip the sign of the amplitude of the \"good\" state.\n    space_transform: The space transform operator (which is known also the state preparation operator). First applied to prepare the state before the amplification, then used inside the Grover operator.\n    packed_vars: The variable that holds the state to be amplified. Assumed to be in the zero state at the beginning of the algorithm."
  },
  {
    "name": "/classiq/open_library.functions.amplitude_estimation.amplitude_estimation",
    "summary": "Estimate the probability of a state being marked by the operand `oracle` as a \"good state. \".",
    "docstring": "Estimate the probability of a state being marked by the operand `oracle` as a \"good state.\"\n\nThe algorithm prepares the state in the `packed_vars` register and estimates the probability of this state being marked by the oracle as a \"good state.\"\nThis is done using the Quantum Phase Estimation (QPE) algorithm, where the unitary for QPE is the Grover operator, which is composed of the `oracle` and `space_transform` operators.\n\nArgs:\n    oracle: The oracle operator that marks the \"good\" state. This operator should flip the sign of the amplitude of the \"good\" state.\n    space_transform: The space transform operator (which is known also the state preparation operator), which is first applied to prepare the state before the QPE, and then used inside the Grover operator.\n    phase: Assuming this variable starts from the zero state -this variable output holds the $phase=\\theta$ result in the [0,1] domain, which relates to the estimated probability $a$ through $a=\\sin^2(\\pi \\theta)$.\n    packed_vars: The variable that holds the state to be estimated. Assumed to be in the zero state at the beginning of the algorithm."
  },
  {
    "name": "/classiq/open_library.functions.discrete_sine_cosine_transform.qct_qst_type1",
    "summary": "Applies the quantum discrete cosine (DCT) and sine (DST) transform of type 1 to the qubit array `x`. Corresponds to the matrix (with $n\\equiv$`x.",
    "docstring": "Applies the quantum discrete cosine (DCT) and sine (DST)\ntransform of type 1 to the qubit array `x`.\nCorresponds to the matrix (with $n\\equiv$`x.len`):\n\n$$\n\\left(\n\begin{array}{ccc|c}\n{} &{} &{} \\\n  {}&{\rm DCT}^{(1)}(2^{n-1}+1) & {}& 0\\\n  {} &{} &{} \\\n  \\hline\n  {} & 0 & {} & i{\rm DST}^{(1)}(2^{n-1}-1)\n\\end{array}\n\right)\n$$\n\nArgs:\n    x: The qubit array to apply the transform to."
  },
  {
    "name": "/classiq/open_library.functions.discrete_sine_cosine_transform.qct_qst_type2",
    "summary": "Applies the quantum discrete cosine (DCT) and sine (DST) transform of type 2 to the qubit array `x` concatenated with `q`, with `q` being the MSB. Corresponds to the matrix (with $n\\equiv$`x.",
    "docstring": "Applies the quantum discrete cosine (DCT) and sine (DST)\ntransform of type 2 to the qubit array `x` concatenated with `q`, with `q` being the MSB.\nCorresponds to the matrix (with $n\\equiv$`x.len`+1):\n\n$$\n\\left(\n\begin{array}{c|c}\n  {\rm DCT}^{(2)}(2^{n-1}) & 0\\\n  \\hline\n  0 & -{\rm DST}^{(2)}(2^{n-1})\n\\end{array}\n\right)\n$$\n\nArgs:\n    x: The LSB part of the qubit array to apply the transform to.\n    q: The MSB of the qubit array to apply the transform to."
  },
  {
    "name": "/classiq/open_library.functions.discrete_sine_cosine_transform.qct_type2",
    "summary": "Applies the quantum discrete cosine (DCT) transform of type 2, ${ m DCT}^{(2)}$, to the qubit array `x`.",
    "docstring": "Applies the quantum discrete cosine (DCT)\ntransform of type 2, ${\rm DCT}^{(2)}$, to the qubit array `x`.\n\nArgs:\n    x: The qubit array to apply the transform to."
  },
  {
    "name": "/classiq/open_library.functions.discrete_sine_cosine_transform.qst_type2",
    "summary": "Applies the quantum discrete sine (DST) transform of type 2, ${ m DST}^{(2)}$, to the qubit array `x`.",
    "docstring": "Applies the quantum discrete sine (DST)\ntransform of type 2, ${\rm DST}^{(2)}$, to the qubit array `x`.\n\nArgs:\n    x: The qubit array to apply the transform to."
  },
  {
    "name": "/classiq/open_library.functions.grover.phase_oracle",
    "summary": "Creates a phase oracle operator based on a predicate function.",
    "docstring": "Creates a phase oracle operator based on a predicate function.\n\nApplies a predicate function and marks \"good\" and \"bad\" states with a phase flip.\nIf the predicate is marked as $\\chi$, and the oracle is marked as $S_{\\chi}$, then:\n\n\n$$\nS_{\\chi}\\lvert x \\rangle =\n\\begin{cases}\n-\\lvert x \\rangle & \\text{if } \\chi(x) = 1 \\\\\n\\phantom{-} \\lvert x \\rangle & \\text{if } \\chi(x) = 0\n\\end{cases}\n$$\n\nArgs:\n    predicate: A predicate function that takes a QArray of QBits and sets a single QBit |1> if the predicate is true, and |0> otherwise.\n    target: The target QArray of QBits to apply the phase oracle to."
  },
  {
    "name": "/classiq/open_library.functions.grover.reflect_about_zero",
    "summary": "Reflects the state about the |0> state (i. e.",
    "docstring": "Reflects the state about the |0> state (i.e. applies a (-1) phase to all states\nbesides the |0> state). Implements the operator $S_0$:\n\n$$\n\\begin{equation}\nS_0|{x}\\rangle = (-1)^{(x\\ne0)}|{x}\\rangle= (2|{0}\\rangle\\langle{0}|-I)|{x}\\rangle\n\\end{equation}\n$$\n\nArgs:\n    packed_vars: The quantum state to reflect."
  },
  {
    "name": "/classiq/open_library.functions.grover.grover_diffuser",
    "summary": "Reflects the given state about the A|0> state, where A is the `space_transform` parameter. It is defined as:.",
    "docstring": "Reflects the given state about the A|0> state, where A\nis the `space_transform` parameter. It is defined as:\n\n$$\n\\begin{equation}\nD = A S_0 A^{\\dagger}\n\\end{equation}\n$$\n\nwhere $S_0$ is the reflection about the |0> state (see `reflect_about_zero`).\n\nArgs:\n    space_transform: The operator which encodes the axis of reflection.\n    packed_vars: The state to which to apply the diffuser."
  },
  {
    "name": "/classiq/open_library.functions.grover.grover_operator",
    "summary": "Applies the grover operator, defined by:.",
    "docstring": "Applies the grover operator, defined by:\n\n$$\nQ=S_{\\psi_0}S_{\\psi_1}\n$$\n\nwhere $S_{\\psi_1}$ is a reflection about marked states, and $S_{\\psi_0}$ is a reflection\nabout a given state defined by $|\\psi_0\\rangle = A|0\\rangle$.\n\nArgs:\n    oracle: A unitary operator which adds a phase of (-1) to marked states.\n    space_transform: The operator which creates $|\\psi_0\\rangle$, the initial state, used by the diffuser to reflect about it.\n    packed_vars: The state to which to apply the grover operator."
  },
  {
    "name": "/classiq/open_library.functions.grover.grover_search",
    "summary": "Applies Grover search algorithm.",
    "docstring": "Applies Grover search algorithm.\n\nArgs:\n    reps: Number of repetitions of the grover operator.\n    oracle: An oracle that marks the solution.\n    packed_vars: Packed form of the variable to apply the grover operator on.\n\nReturns: None"
  },
  {
    "name": "/classiq/open_library.functions.hea.full_hea",
    "summary": "Implements an ansatz on a qubit array `x` with the given 1-qubit and 2-qubit operations.",
    "docstring": "Implements an ansatz on a qubit array `x` with the given 1-qubit and 2-qubit operations.\n\nThe number of ansatz layers is given in argument `reps`.\nEach layer applies the 1-qubit operands in `operands_1qubit` to all the qubits in `x`.\nNext, it applies the 2-qubit operands in `operands_2qubit` to qubits (i, j) for each\npair of indices (i, j) in `connectivity_map`.\n\nThe list `is_parametrized` specifies whether the operands in `operands_1qubit` and\n`operands_2qubit` are parametric (expect a classical argument).\n`is_parametrized` is a list of flags (0 and 1 integers) of length\n`len(operands_1qubit) + len(operands_2qubit)`.\nThe first `len(operands_1qubit)` flags refer to the `operands_1qubit` operands and\nthe next `len(operands_2qubit)` flags refer to the `operands_2qubit` operands.\n\nThe classical arguments to the parametric operands are given in argument\n`angle_params`.\n`angle_params` concatenates a set of arguments for each ansatz layer.\nEach set contains an argument for each qubit in `x` times the number\nof parametric operands in `operands_1qubit`.\nThese are followed by an argument for each mapping pair in `connectivity_map` times\nthe number of parametric operands in `operands_2qubit`.\n\nArgs:\n    num_qubits: The length of qubit array x\n    is_parametrized: A list of 0 and 1 flags\n    angle_params A list of arguments to gate\n    connectivity_map: A list of pairs of qubit indices\n    reps: The number of ansatz layers\n    operands_1qubit: A list of operations on a single qubit\n    operands_2qubit: A list of operations on two qubits\n    x: The quantum object to be transformed by the ansatz"
  },
  {
    "name": "/classiq/open_library.functions.lcu.lcu",
    "summary": "Implements a general linear combination of unitaries (LCU) procedure. The algorithm prepares a superposition over the `unitaries` according to `magnitudes`, and then conditionally applies each unitary controlled by the `block`.",
    "docstring": "Implements a general linear combination of unitaries (LCU) procedure. The algorithm prepares a superposition\nover the `unitaries` according to `magnitudes`, and then conditionally applies each unitary controlled by the `block`.\n\nThe operation is of the form:\n\n$$\\sum_j \\alpha_j U_j$$\n\nwhere $U_j$ is a unitary operation applied to `data`.\n\nArgs:\n    coefficients: L1-normalized array of  $\\{ \\alpha_j \\}$ of the LCU coefficients.\n    unitaries: A list of quantum callable functions to be applied conditionally.\n    block: Quantum variable that holds the superposition index used for conditional application of each unitary."
  },
  {
    "name": "/classiq/open_library.functions.lcu.lcu_pauli",
    "summary": "Applies a linear combination of unitaries (LCU) where each unitary is a Pauli term, represented as a tensor product of Pauli operators. The function prepares a superposition over the unitaries according to the given magnitudes and phases, and applies the corresponding Pauli operators conditionally.",
    "docstring": "Applies a linear combination of unitaries (LCU) where each unitary is a Pauli term,\nrepresented as a tensor product of Pauli operators. The function prepares a superposition\nover the unitaries according to the given magnitudes and phases, and applies the corresponding\nPauli operators conditionally.\n\nThis is useful for implementing Hamiltonian terms of the form:\n\n$$H=\\sum_j \\alpha_j P_j$$\n\nwhere $P_j$ is a tensor product of Pauli operators.\n\nArgs:\n    operator: Operator consists of pauli strings with their coefficients, represented in a sparse format.\n    data: Quantum Variable on which the Pauli operators act. Its size must match the number of qubits required by the Pauli operator.\n    block: Quantum variable that holds the superposition index used for conditional application of each term."
  },
  {
    "name": "/classiq/open_library.functions.linear_pauli_rotation.linear_pauli_rotations",
    "summary": "Performs a rotation on a series of $m$ target qubits, where the rotation angle is a linear function of an $n$-qubit control register.",
    "docstring": "Performs a rotation on a series of $m$ target qubits,\nwhere the rotation angle is a linear function of an $n$-qubit\ncontrol register.\n\nCorresponds to the braket notation:\n\n$$\n\\left|x\\right\\rangle _{n}\\left|q\\right\\rangle\n_{m}\\rightarrow\\left|x\\right\\rangle\n_{n}\\prod_{k=1}^{m}\\left(\\cos\\left(\\frac{a_{k}}{2}x+\\frac{b_{k}}{2}\\right)-\ni\\sin\\left(\\frac{a_{k}}{2}x+\\frac{b_{k}}{2}\\right)P_{k}\\right)\\left|q_{k}\\right\\rangle\n$$\n\nwhere $\\left|x\\right\\rangle$ is the control register,\n$\\left|q\\right\\rangle$ is the target register, each $P_{k}$ is one of\nthe three Pauli matrices $X$, $Y$, or $Z$, and $a_{k}$, $b_{k}$ are\nthe user given slopes and offsets, respectively.\n\nArgs:\n    bases: List of Pauli Enums.\n    slopes: Rotation slopes for each of the given Pauli bases.\n    offsets:  Rotation offsets for each of the given Pauli bases.\n    x: Quantum state to apply the rotation based on its value.\n    q: List of indicator qubits for each of the given Pauli bases.\n\nNotice that bases, slopes, offset and q should be of the same size."
  },
  {
    "name": "/classiq/open_library.functions.lookup_table.span_lookup_table",
    "summary": "Applies a classical function to quantum numbers.",
    "docstring": "Applies a classical function to quantum numbers.\n\nWorks by reducing the function into a lookup table over all the possible values\nof the quantum numbers.\n\nArgs:\n    func: A Python function\n    *targets: One or more initialized quantum numbers\n\nReturns:\n    The quantum result of applying func to targets\n\nNotes:\n    Must be called inside a generative function (`@qfunc`)"
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.qft_space_add_const",
    "summary": "Adds a constant to a quantum number (in the Fourier space) using the Quantum Fourier Transform (QFT) Adder algorithm. Assuming that the input `phi_b` has `n` qubits, the result will be $\\phi_b+=value \\mod 2^n$.",
    "docstring": "Adds a constant to a quantum number (in the Fourier space) using the Quantum Fourier Transform (QFT) Adder algorithm.\nAssuming that the input `phi_b` has `n` qubits, the result will be $\\phi_b+=value \\mod 2^n$.\n\nTo perform the full algorithm, use:\nwithin_apply(lambda: QFT(phi_b), qft_space_add_const(value, phi_b))\n\nArgs:\n    value: The constant to add to the quantum number.\n    phi_b: The quantum number (at the aft space) to which the constant is added."
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.cc_modular_add",
    "summary": "Adds a constant `a` to a quantum number `phi_b` modulo the constant `n`, controlled by 2 qubits. The quantum number `phi_b` and the constant `a` are assumed to be in the QFT space.",
    "docstring": "Adds a constant `a` to a quantum number `phi_b` modulo the constant `n`, controlled by 2 qubits.\nThe quantum number `phi_b` and the constant `a` are assumed to be in the QFT space.\n\nArgs:\n    n: The modulo number.\n    a: The constant to add to the quantum number.\n    phi_b: The quantum number to which the constant is added.\n    c1: a control qubit.\n    c2: a control qubit."
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.c_modular_multiply",
    "summary": "Performs out-of-place multiplication of a quantum number `x` by a classical number `a` modulo classical number `n`, controlled by a quantum bit `ctrl` and adds the result to a quantum array `b`. Applies $b += xa \\mod n$ if `ctrl=1`, and the identity otherwise.",
    "docstring": "Performs out-of-place multiplication of a quantum number `x` by a classical number `a` modulo classical number `n`,\ncontrolled by a quantum bit `ctrl` and adds the result to a quantum array `b`. Applies $b += xa \\mod n$ if `ctrl=1`, and the identity otherwise.\n\nArgs:\n    n: The modulo number. Should be non-negative.\n    a: The classical factor. Should be non-negative.\n    b: The quantum number added to the multiplication result. Stores the result of the multiplication.\n    x: The quantum factor.\n    ctrl: The control bit."
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.multiswap",
    "summary": "Swaps the qubit states between two arrays. Qubits of respective indices are swapped, and additional qubits in the longer array are left unchanged.",
    "docstring": "Swaps the qubit states between two arrays.\nQubits of respective indices are swapped, and additional qubits in the longer array are left unchanged.\n\nArgs:\n    x: The first array\n    y: The second array"
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.inplace_c_modular_multiply",
    "summary": "Performs multiplication of a quantum number `x` by a classical number `a` modulo classical number `n`, controlled by a quantum bit `ctrl`. Applies $x=xa \\mod n$ if `ctrl=1`, and the identity otherwise.",
    "docstring": "Performs multiplication of a quantum number `x` by a classical number `a` modulo classical number `n`,\ncontrolled by a quantum bit `ctrl`. Applies $x=xa \\mod n$ if `ctrl=1`, and the identity otherwise.\n\nArgs:\n    n: The modulo number. Should be non-negative.\n    a: The classical factor. Should be non-negative.\n    x: The quantum factor.\n    ctrl: The control bit."
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.modular_add_qft_space",
    "summary": "Adds a constant `a` to a quantum number `phi_b` modulo the constant `n`. The quantum number `phi_b` is assumed to be in the QFT space.",
    "docstring": "Adds a constant `a` to a quantum number `phi_b` modulo the constant `n`.\nThe quantum number `phi_b` is assumed to be in the QFT space.\n\nArgs:\n    n: The modulo number.\n    a: The constant to add to the quantum number.\n    phi_b: The quantum number to which the constant is added."
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.modular_multiply",
    "summary": "Performs out-of-place multiplication of a quantum number `x` by a classical number `a` modulo classical number `n`, and adds the result to a quantum array `b` (Applies $b += xa \\mod n$).",
    "docstring": "Performs out-of-place multiplication of a quantum number `x` by a classical number `a` modulo classical number `n`,\nand adds the result to a quantum array `b` (Applies $b += xa \\mod n$).\n\nArgs:\n    n: The modulo number. Should be non-negative.\n    a: The classical factor. Should be non-negative.\n    b: The quantum number added to the multiplication result. Stores the result of the multiplication.\n    x: The quantum factor."
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.inplace_modular_multiply",
    "summary": "Performs multiplication of a quantum number `x` by a classical number `a` modulo classical number `n` (Applies $x=xa \\mod n$).",
    "docstring": "Performs multiplication of a quantum number `x` by a classical number `a` modulo classical number `n`\n(Applies $x=xa \\mod n$).\n\nArgs:\n    n: The modulo number. Should be non-negative.\n    a: The classical factor. Should be non-negative.\n    x: The quantum factor.\n\nComment: It is assumed that `a` has an inverse modulo `n`"
  },
  {
    "name": "/classiq/open_library.functions.modular_exponentiation.modular_exp",
    "summary": "Raises a classical integer `a` to the power of a quantum number `power` modulo classical integer `n` times a quantum number `x`. Performs $x=(a^{power} \\mod n)*x$ in-place.",
    "docstring": "Raises a classical integer `a` to the power of a quantum number `power` modulo classical integer `n`\ntimes a quantum number `x`. Performs $x=(a^{power} \\mod n)*x$ in-place.\n(and specifically if at the input $x=1$, at the output $x=a^{power} \\mod n$).\n\nArgs:\n    n: The modulus number. Should be non-negative.\n    a: The base of the exponentiation. Should be non-negative.\n    x: A quantum number that multiplies the modular exponentiation and holds the output. It should be at least the size of $\\lceil \\log(n) \rceil$.\n    power: The power of the exponentiation."
  },
  {
    "name": "/classiq/open_library.functions.qaoa_penalty.qaoa_mixer_layer",
    "summary": "Applies the mixer layer for the QAOA algorithm. The mixer layer is a sequence of `X` gates applied to each qubit in the target quantum array variable.",
    "docstring": "Applies the mixer layer for the QAOA algorithm.\nThe mixer layer is a sequence of `X` gates applied to each qubit in the target quantum\narray variable.\n\nArgs:\n    b: The rotation parameter for the mixer layer.\n    target: The target quantum array."
  },
  {
    "name": "/classiq/open_library.functions.qaoa_penalty.qaoa_cost_layer",
    "summary": "Applies the cost layer to the QAOA model.",
    "docstring": "Applies the cost layer to the QAOA model.\n\nThis function integrates the problem-specific cost function into the QAOA model's objective function.\nThe cost layer represents the primary objective that the QAOA algorithm seeks to optimize, such as\nminimizing energy or maximizing profit, depending on the application.\n\nArgs:\n    g: The rotation parameter for the cost layer (prefactor).\n    hamiltonian: The Hamiltonian terms for the QAOA model.\n    target: The target quantum array variable."
  },
  {
    "name": "/classiq/open_library.functions.qaoa_penalty.qaoa_layer",
    "summary": "Applies the QAOA layer, which concatenates the cost layer and the mixer layer.",
    "docstring": "Applies the QAOA layer, which concatenates the cost layer and the mixer layer.\n\nThe `qaoa_layer` function integrates both the cost and mixer layers, essential components of the\nQuantum Approximate Optimization Algorithm (QAOA). The cost layer encodes the problem's objective,\nwhile the mixer layer introduces quantum superposition and drives the search across the solution space.\n\nArgs:\n       g: The rotation parameter for the cost layer.\n       b: The rotation parameter for the mixer layer.\n       hamiltonian: The Hamiltonian terms for the QAOA model.\n       target: The target quantum array variable."
  },
  {
    "name": "/classiq/open_library.functions.qaoa_penalty.qaoa_init",
    "summary": "Initializes the QAOA circuit by applying the Hadamard gate to all qubits.",
    "docstring": "Initializes the QAOA circuit by applying the Hadamard gate to all qubits.\n\nIn the Quantum Approximate Optimization Algorithm (QAOA), the initial state is a uniform superposition\ncreated by applying the Hadamard gate to each qubit. This function prepares the qubits for the subsequent\napplication of the cost and mixer layers by preparing them in an equal superposition state.\n\nArgs:\n       target: The target quantum array variable."
  },
  {
    "name": "/classiq/open_library.functions.qaoa_penalty.qaoa_penalty",
    "summary": "Applies the penalty layer to the QAOA model.",
    "docstring": "Applies the penalty layer to the QAOA model.\n\nThis function adds a penalty term to the objective function of the QAOA model to\nenforce certain constraints (e.g., binary or integer variables) during the\noptimization process.\n\nArgs:\n    num_qubits: The number of qubits in the quantum circuit.\n    params_list The list of QAOA parameters.\n    hamiltonian: The Hamiltonian terms for the QAOA model.\n    target: The target quantum array variable."
  },
  {
    "name": "/classiq/open_library.functions.qft_functions.qft_no_swap",
    "summary": "Applies the Quantum Fourier Transform (QFT) without the swap gates.",
    "docstring": "Applies the Quantum Fourier Transform (QFT) without the swap gates.\n\nArgs:\n    qbv: The quantum number to which the QFT is applied."
  },
  {
    "name": "/classiq/open_library.functions.qft_functions.qft",
    "summary": "Performs the Quantum Fourier Transform (QFT) on `target` in-place. Implements the following transformation:.",
    "docstring": "Performs the Quantum Fourier Transform (QFT) on `target` in-place.\nImplements the following transformation:\n\n$$\ny_{k} = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} x_j e^{2\\pi i \\frac{jk}{N}}\n$$\n\nArgs:\n    target: The quantum object to be transformed"
  },
  {
    "name": "/classiq/open_library.functions.qpe.qpe_flexible",
    "summary": "Implements the Quantum Phase Estimation (QPE) algorithm, which estimates the phase (eigenvalue) associated with an eigenstate of a given unitary operator $U$. This is a flexible version that allows the user to provide a callable that generates the unitary operator $U^k$ for a given integer $k$, offering greater flexibility in handling different quantum circuits using some powering rule.",
    "docstring": "Implements the Quantum Phase Estimation (QPE) algorithm,  which estimates the phase (eigenvalue) associated with an eigenstate of a given unitary operator $U$.\nThis is a flexible version that allows the user to provide a callable that generates the unitary operator $U^k$ for a given integer $k$, offering greater flexibility in handling different quantum circuits using some powering rule.\n\nArgs:\n    unitary_with_power: A callable that returns the unitary operator $U^k$ given an integer $k$. This callable is used to control the application of powers of the unitary operator.\n    phase: The quantum variable that represents the estimated phase (eigenvalue), assuming initialized to zero."
  },
  {
    "name": "/classiq/open_library.functions.qpe.qpe",
    "summary": "Implements the standard Quantum Phase Estimation (QPE) algorithm, which estimates the phase (eigenvalue) associated with an eigenstate of a given unitary operator $U$.",
    "docstring": "Implements the standard Quantum Phase Estimation (QPE) algorithm, which estimates the phase (eigenvalue) associated with an eigenstate of a given unitary operator $U$.\n\nArgs:\n    unitary: A callable representing the unitary operator $U$, whose eigenvalue is to be estimated.\n    phase: The quantum variable that represents the estimated phase (eigenvalue), assuming initialized to zero."
  },
  {
    "name": "/classiq/open_library.functions.qsvt.qsvt_step",
    "summary": "Applies a single QSVT step, composed of 2 projector-controlled-phase rotations, and applications of the block encoding unitary `u` and its inverse:.",
    "docstring": "Applies a single QSVT step, composed of 2 projector-controlled-phase rotations, and applications of the block encoding unitary `u` and its inverse:\n\n$$\n\\Pi_{\\phi_2}U^{\\dagger}\\tilde{\\Pi}_{\\phi_{1}}U\n$$\n\nArgs:\n    phase1: 1st rotation phase.\n    phase2: 2nd rotation phase.\n    proj_cnot_1: Projector-controlled-not unitary that locates the encoded matrix columns within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    proj_cnot_2: Projector-controlled-not unitary that locates the encoded matrix rows within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    u: A block encoded unitary matrix.\n    qvar: The quantum variable to which U is applied, which resides in the entire block encoding space.\n    aux: A zero auxilliary qubit, used for the projector-controlled-phase rotations. Given as an inout so that qsvt can be used as a building-block in a larger algorithm."
  },
  {
    "name": "/classiq/open_library.functions.qsvt.qsvt",
    "summary": "Implements the Quantum Singular Value Transformation (QSVT) - an algorithmic framework, used to apply polynomial transformations of degree `d` on the singular values of a block encoded matrix, given as the unitary `u`. Given a unitary $U$, a list of phase angles $\\phi_1, \\phi_2,.",
    "docstring": "Implements the Quantum Singular Value Transformation (QSVT) - an algorithmic framework, used to apply polynomial transformations of degree `d` on the singular values of a block encoded matrix, given as the unitary `u`.    Given a unitary $U$, a list of phase angles  $\\phi_1, \\phi_2, ..., \\phi_{d+1}$ and 2 projector-controlled-not operands $C_{\\Pi}NOT,C_{\\tilde{\\Pi}}NOT$, the QSVT sequence is as follows:\nGiven a unitary $U$, a list of phase angles  $\\phi_1, \\phi_2, ..., \\phi_{d+1}$ and 2 projector-controlled-not operands $C_{\\Pi}NOT,C_{\\tilde{\\Pi}}NOT$, the QSVT sequence is as follows:\n\n$$\n\\tilde{\\Pi}_{\\phi_{d+1}}U \\prod_{k=1}^{(d-1)/2} (\\Pi_{\\phi_{d-2k}} U^{\\dagger}\\tilde{\\Pi}_{\\phi_{d - (2k+1)}}U)\\Pi_{\\phi_{1}}\n$$\n\nfor odd $d$, and:\n\n$$\n\\prod_{k=1}^{d/2} (\\Pi_{\\phi_{d-(2k-1)}} U^{\\dagger}\\tilde{\\Pi}_{\\phi_{d-2k}}U)\\Pi_{\\phi_{1}}\n$$\n\nfor even $d$.\n\nEach of the $\\Pi$s is a projector-controlled-phase unitary, according to the given projectors.\n\nArgs:\n    phase_seq: A sequence of phase angles of length d+1.\n    proj_cnot_1: Projector-controlled-not unitary that locates the encoded matrix columns within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    proj_cnot_2: Projector-controlled-not unitary that locates the encoded matrix rows within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    u: A block encoded unitary matrix.\n    qvar: The quantum variable to which U is applied, which resides in the entire block encoding space.\n    aux: A zero auxilliary qubit, used for the projector-controlled-phase rotations. Given as an inout so that qsvt can be used as a building-block in a larger algorithm."
  },
  {
    "name": "/classiq/open_library.functions.qsvt.projector_controlled_phase",
    "summary": "Assigns a phase to the entire subspace determined by the given projector. Corresponds to the operation:.",
    "docstring": "Assigns a phase to the entire subspace determined by the given projector. Corresponds to the operation:\n\n$$\n\\Pi_{\\phi} = (C_{\\Pi}NOT) e^{-i\frac{\\phi}{2}Z}(C_{\\Pi}NOT)\n$$\n\nArgs:\n    phase: A rotation phase.\n    proj_cnot: Projector-controlled-not unitary that sets an auxilliary qubit to |1> when the state is in the projection.\n    qvar: The quantum variable to which the rotation applies, which resides in the entire block encoding space.\n    aux: A zero auxilliary qubit, used for the projector-controlled-phase rotation. Given as an inout so that qsvt can be used as a building-block in a larger algorithm."
  },
  {
    "name": "/classiq/open_library.functions.qsvt.qsvt_inversion",
    "summary": "Implements matrix inversion on a given block-encoding of a square matrix, using the QSVT framework. Applies a polynomial approximation of the inverse of the singular values of the matrix encoded in `u`.",
    "docstring": "Implements matrix inversion on a given block-encoding of a square matrix, using the QSVT framework. Applies a polynomial approximation\nof the inverse of the singular values of the matrix encoded in `u`. The phases for the polynomial should be pre-calculated and passed into the function.\n\nArgs:\n    phase_seq: A sequence of phase angles of length d+1, corresponding to an odd polynomial approximation of the scaled inverse function.\n    block_encoding_cnot: Projector-controlled-not unitary that locates the encoded matrix columns within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    u: A block encoded unitary matrix.\n    qvar: The quantum variable to which U is applied, which resides in the entire block encoding space.\n    aux: A zero auxilliary qubit, used for the projector-controlled-phase rotations. Given as an inout so that qsvt can be used as a building-block in a larger algorithm."
  },
  {
    "name": "/classiq/open_library.functions.qsvt.projector_controlled_double_phase",
    "summary": "Assigns 2 phases to the entire subspace determined by the given projector, each one is controlled differentely on a given `lcu` qvar. Used in the context of the `qsvt_lcu` function.",
    "docstring": "Assigns 2 phases to the entire subspace determined by the given projector, each one is controlled differentely on a given `lcu` qvar.\nUsed in the context of the `qsvt_lcu` function. Corresponds to the operation:\n\n$$\n\\Pi_{\\phi_{odd}, \\phi_{even}} = (C_{\\Pi}NOT) (C_{lcu=1}e^{-i\\frac{\\phi_{even}}{2}Z}) (C_{lcu=0}e^{-i\\frac{\\phi_{odd}}{2}Z}) (C_{\\Pi}NOT)\n$$\n\nArgs:\n    phase_even: Rotation phase, corresponds to 'lcu'=1.\n    phase_odd: Rotation phase, corresponds to 'lcu'=0.\n    proj_cnot: Projector-controlled-not unitary that sets an auxilliary qubit to |1> when the state is in the projection.\n    qvar: The quantum variable to which the rotation applies, which resides in the entire block encoding space.\n    aux: A zero auxilliary qubit, used for the projector-controlled-phase rotation. Given as an inout so that qsvt can be used as a building-block in a larger algorithm."
  },
  {
    "name": "/classiq/open_library.functions.qsvt.qsvt_lcu_step",
    "summary": "Applies a single QSVT-lcu step, composed of 2 double phase projector-controlled-phase rotations, and applications of the block encoding unitary `u` and its inverse:.",
    "docstring": "Applies a single QSVT-lcu step, composed of 2 double phase projector-controlled-phase rotations, and applications of the block encoding unitary `u` and its inverse:\n\n$$\n(C_{lcu=1}\\Pi^{even}_{\\phi_2})(C_{lcu=0}\\Pi^{odd}_{\\phi_2})U^{\\dagger}(C_{lcu=1}\\tilde{\\Pi}^{even}_{\\phi_1})(C_{lcu=0}\\tilde{\\Pi}^{odd}_{\\phi_1})U\n$$\n\nArgs:\n    phases_even: 2 rotation phases for the even polynomial\n    phases_odd: 2 rotation phases for the odd polynomial\n    proj_cnot_1: Projector-controlled-not unitary that locates the encoded matrix columns within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    proj_cnot_2: Projector-controlled-not unitary that locates the encoded matrix rows within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    u: A block encoded unitary matrix.\n    qvar: The quantum variable to which U is applied, which resides in the entire block encoding space.\n    aux: A zero auxilliary qubit, used for the projector-controlled-phase rotations. Given as an inout so that qsvt can be used as a building-block in a larger algorithm.\n    lcu: A qubit used for the combination of 2 polynomials within a single qsvt application"
  },
  {
    "name": "/classiq/open_library.functions.qsvt.qsvt_lcu",
    "summary": "Implements the Quantum Singular Value Transformation (QSVT) for a linear combination of odd and even polynomials, so that it is possible to encode a polynomial of indefinite parity, such as approximation to exp(i*A) or exp(A). Should work for Hermitian block encodings.",
    "docstring": "Implements the Quantum Singular Value Transformation (QSVT) for a linear combination of odd and even polynomials, so that\nit is possible to encode a polynomial of indefinite parity, such as approximation to exp(i*A) or exp(A). Should work\nfor Hermitian block encodings.\n\nThe function is equivalent to applying the `qsvt` function for odd and even polynomials with a LCU function, but\nis more efficient as the two polynomials share the same applications of the given unitary.\n\nThe function is intended to be called within a context of LCU, where it is called as the SELECT operator, and wrapped\nwith initialization of the `lcu` qubit to get the desired combination coefficients.\nThe even polynomial corresponds to the case where the $lcu=|0\\rangle$, while the odd to #lcu=|1\\rangle$.\n\nNote: the two polynomials should have the same degree up to a difference of 1.\n\nArgs:\n    phase_seq_odd: A sequence of phase angles of length d+(d%2) for the odd polynomial.\n    phase_seq_even: A sequence of phase angles of length d+(d+1)%2 for the even polynomial.\n    proj_cnot_1: Projector-controlled-not unitary that locates the encoded matrix columns within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    proj_cnot_2: Projector-controlled-not unitary that locates the encoded matrix rows within U. Accepts a quantum variable of the same size as qvar, and a qubit that is set to |1> when the state is in the block.\n    u: A block encoded unitary matrix.\n    qvar: The quantum variable to which U is applied, which resides in the entire block encoding space.\n    aux: A zero auxilliary qubit, used for the projector-controlled-phase rotations. Given as an inout so that qsvt can be used as a building-block in a larger algorithm.\n    lcu: A qubit used for the combination of 2 polynomials within a single qsvt application"
  },
  {
    "name": "/classiq/open_library.functions.qsvt.gqsp",
    "summary": "Implements Generalized Quantum Signal Processing (GQSP), which realizes a (Laurent) polynomial transformation of degree d on the eigenvalues of the given signal unitary `u`. The protocol is according to https://arxiv.",
    "docstring": "Implements Generalized Quantum Signal Processing (GQSP), which realizes a\n (Laurent) polynomial transformation of degree d on the eigenvalues of the given\n signal unitary `u`. The protocol is according to https://arxiv.org/abs/2308.01501\n Fig.2.\n\nNotes:\n- The user is encouraged to use the function `gqsp_phases` to find `phases` that\n  correspond to the wanted polynomial transformation.\n- Feasibility: the target polynomial must satisfy |P(e^{i*theta})| <= 1 for all\n  theta in [0, 2*pi). This ensures a unitary completion exists.\n- Using `negative_power = m` (m >= 0) you can realize Laurent polynomials with\n  negative exponents: the implemented transform is equivalent to applying\n  z^{-m} * P(z) (i.e., shift the minimal degree to -m).\n  For ordinary (non-Laurent) polynomials, set `negative_power = 0`.\n\nArgs:\n    u: The signal unitary.\n    aux: Auxiliary qubit used for the phase rotations. Should start in |0>.\n    phases:  3 x (d+1) real array of angles: phases[0] = thetas, phases[1] = phis,\n             phases[2] = lambdas.\n    negative_power: Integer m in [0, d]. Encodes the minimal Laurent power -m of\n                    the realized transformation."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_uniform_trimmed_state",
    "summary": "Initializes a quantum variable in a uniform superposition of the first `m` computational basis states:.",
    "docstring": "Initializes a quantum variable in a uniform superposition of the first `m` computational basis states:\n\n$$\n    \\left|\\text{q}\\right\\rangle = \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}{|i\\rangle}\n$$\n\nThe number of allocated qubits would be $\\left\\lceil\\log_2{m}\\right\\rceil$.\nThe function is especially useful when `m` is not a power of 2.\n\nArgs:\n    m: The number of states to load in the superposition.\n    q: The quantum variable that will receive the initialized state. Must be uninitialized.\n\nNotes:\n    1. If the output variable has been declared with a specific number of qubits, it must match the number of allocated qubits.\n    2. The synthesis engine automatically handles the allocation, either by drawing new qubits from the available pool or by reusing existing ones."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_uniform_interval_state",
    "summary": "Initializes a quantum variable in a uniform superposition of the specified interval in the computational basis states:.",
    "docstring": "Initializes a quantum variable in a uniform superposition of the specified interval in the computational basis states:\n\n$$\n    \\left|\\text{q}\\right\\rangle = \\frac{1}{\\sqrt{\\text{end} - \\text{start}}}\\sum_{i=\\text{start}}^{\\text{end}-1}{|i\\rangle}\n$$\n\nThe number of allocated qubits would be $\\left\\lceil\\log_2{\\left(\\text{end}\\right)}\\right\\rceil$.\n\nArgs:\n    start: The lower bound of the interval to load (inclusive).\n    end: The upper bound of the interval to load (exclusive).\n    q: The quantum variable that will receive the initialized state. Must be uninitialized.\n\nNotes:\n    1. If the output variable has been declared with a specific number of qubits, it must match the number of allocated qubits.\n    2. The synthesis engine automatically handles the allocation, either by drawing new qubits from the available pool or by reusing existing ones."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_ghz_state",
    "summary": "Initializes a quantum variable in a Greenberger-Horne-Zeilinger (GHZ) state. i.",
    "docstring": "Initializes a quantum variable in a Greenberger-Horne-Zeilinger (GHZ) state. i.e., a balanced superposition of all ones and all zeros, on an arbitrary number of qubits..\n\nArgs:\n    size: The number of qubits in the GHZ state. Must be a positive integer.\n    q: The quantum variable that will receive the initialized state. Must be uninitialized.\n\nNotes:\n    The synthesis engine automatically handles the allocation, either by drawing new qubits from the available pool or by reusing existing ones."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_exponential_state",
    "summary": "Prepares a quantum state with exponentially decreasing amplitudes. The state is prepared in the computational basis, with the amplitudes of the states decreasing exponentially with the index of the state:.",
    "docstring": "Prepares a quantum state with exponentially decreasing amplitudes. The state is prepared in the computational basis, with the amplitudes of the states decreasing exponentially with the index of the state:\n\n$$\n    P(n) = \\frac{1}{Z} e^{- \\text{rate} \\cdot n}\n$$\n\nArgs:\n    rate: The rate of the exponential decay.\n    q: The quantum register to prepare."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_bell_state",
    "summary": "Initializes a quantum array of size 2 in one of the four Bell states.",
    "docstring": "Initializes a quantum array of size 2 in one of the four Bell states.\n\nArgs:\n    state_num: The number of the Bell state to be prepared. Must be an integer between 0 and 3.\n    qpair: The quantum variable that will receive the initialized state. Must be uninitialized.\n\nBell States:\n    The four Bell states are defined as follows (each state correlates to an integer between 0 and 3 as defined by the `state_num` argument):\n\n    If `state_num` = 0 the function prepares the Bell state:\n\n    $$\n        \\left|\\Phi^+\\right\\rangle = \\frac{1}{\\sqrt{2}} \\left( \\left| 00 \\right\\rangle + \\left| 11 \\right\\rangle \\right)\n    $$\n\n    If `state_num` = 1 the function prepares the Bell state:\n\n    $$\n        \\left|\\Phi^-\\right\\rangle = \\frac{1}{\\sqrt{2}} \\left( \\left| 00 \\right\\rangle - \\left| 11 \\right\\rangle \\right)\n    $$\n\n    If `state_num` = 2 the function prepares the Bell state:\n\n    $$\n        \\left|\\Psi^+\\right\\rangle = \\frac{1}{\\sqrt{2}} \\left( \\left| 01 \\right\\rangle + \\left| 10 \\right\\rangle \\right)\n    $$\n\n    If `state_num` = 3 the function prepares the Bell state:\n\n    $$\n        \\left|\\Psi^-\\right\\rangle = \\frac{1}{\\sqrt{2}} \\left( \\left| 01 \\right\\rangle - \\left| 10 \\right\\rangle \\right)\n    $$\n\nNotes:\n    The synthesis engine automatically handles the allocation, either by drawing new qubits from the available pool or by reusing existing ones."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.inplace_prepare_int",
    "summary": "This function is **deprecated**. Use in-place-xor assignment statement in the form _target-var_ **^=** _quantum-expression_ or **inplace_xor(**_quantum-expression_**,** _target-var_**)** instead.",
    "docstring": "This function is **deprecated**. Use in-place-xor assignment statement in the form _target-var_ **^=** _quantum-expression_ or **inplace_xor(**_quantum-expression_**,** _target-var_**)** instead.\n\nTransitions a quantum variable in the zero state $|0\\rangle$ into the computational basis state $|\\text{value}\\rangle$.\nIn the general case, the function performs a bitwise-XOR, i.e. transitions the state $|\\psi\\rangle$ into $|\\psi \\oplus \\text{value}\\rangle$.\n\nArgs:\n    value: The value to assign to the quantum variable.\n    target: The quantum variable to act upon.\n\nNote:\n    If the value cannot fit into the quantum variable, it is truncated, i.e. treated as the value modulo $2^\\text{target.size}$."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_int",
    "summary": "This function is **deprecated**. Use assignment statement in the form _target-var_ **|=** _quantum-expression_ or **assign(**_quantum-expression_**,** _target-var_**)** instead.",
    "docstring": "This function is **deprecated**. Use assignment statement in the form _target-var_ **|=** _quantum-expression_ or **assign(**_quantum-expression_**,** _target-var_**)** instead.\n\nInitializes a quantum variable to the computational basis state $|\\text{value}\\rangle$.\nThe number of allocated qubits is automatically computed from the value, and is the minimal number required for representation in the computational basis.\n\nArgs:\n    value: The value to assign to the quantum variable.\n    out: The allocated quantum variable. Must be uninitialized.\n\nNote:\n    If the output variable has been declared with a specific number of qubits, it must match the number of allocated qubits."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.inplace_prepare_complex_amplitudes",
    "summary": "Prepares a quantum state with amplitudes and phases for each state according to the given parameters, in polar representation. Expects to act on an initialized zero state $|0\\rangle$.",
    "docstring": "Prepares a quantum state with amplitudes and phases for each state according to the given parameters, in polar representation.\nExpects to act on an initialized zero state $|0\\rangle$.\n\nArgs:\n    magnitudes: Absolute values of the state amplitudes.\n    phases: phases of the state amplitudes. should be of the same size as `amplitudes`.\n    target: The quantum variable to act upon."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_complex_amplitudes",
    "summary": "Initializes and prepares a quantum state with amplitudes and phases for each state according to the given parameters, in polar representation.",
    "docstring": "Initializes and prepares a quantum state with amplitudes and phases for each state according to the given parameters, in polar representation.\n\nArgs:\n    magnitudes: Absolute values of the state amplitudes.\n    phases: phases of the state amplitudes. should be of the same size as `amplitudes`.\n    out: The allocated quantum variable. Must be uninitialized."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_dicke_state_unary_input",
    "summary": "Prepares a Dicke state with a variable number of excitations based on an unary-encoded input.",
    "docstring": "Prepares a Dicke state with a variable number of excitations based on an unary-encoded input.\n\nThe Dicke state is defined to be:\n\n$$\\mathrm{Dicke}(n, k) = \\frac{1}{\\sqrt{\\binom{n}{k}}} \\sum_{x \\in \\{0,1\\}^n,\\, |x| = k} |x\\rangle$$\n\nThe input register `qvar` is expected to already be initialized in a unary encoding:\nthe value k is represented by a string of k ones followed by zeros, e.g., k = 3 -> |11100...0>.\nThe function generates a Dicke state with k excitations over a new quantum register,\nwhere 0 <= k < max_k.\n\nArgs:\n    max_k: The maximum number of allowed excitations (upper bound for k).\n    qvar: Unary-encoded quantum input register of length >= max_k. Must be pre-initialized."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_dicke_state",
    "summary": "Prepares a Dicke state with k excitations over the provided quantum register.",
    "docstring": "Prepares a Dicke state with k excitations over the provided quantum register.\n\nA Dicke state of n qubits with k excitations is an equal superposition of all basis states\nwith exactly k qubits in the $|1\\rangle$ state and $(n - k)$ qubits in the $|0\\rangle$ state.\nFor example, $\\mathrm{Dicke}(2, 1) = (|01\\rangle + |10\\rangle) / \\sqrt(2)$.\n\nIn the general case it is defined to be:\n\n$$\\mathrm{Dicke}(n, k) = \\frac{1}{\\sqrt{\\binom{n}{k}}} \\sum_{x \\in \\{0,1\\}^n,\\, |x| = k} |x\\rangle$$\n\nArgs:\n    k: The number of excitations (i.e., number of qubits in state $|1\\rangle$).\n    qvar: The quantum register (array of qubits) to initialize. Must be uninitialized and have length >= k."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_basis_state",
    "summary": "Initializes a quantum array in the specified basis state.",
    "docstring": "Initializes a quantum array in the specified basis state.\n\nArgs:\n    values: The desired basis state, given as a list of boolean values for each qubit.\n    arr: The quantum array to prepare."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_linear_amplitudes",
    "summary": "Initializes a quantum variable in a state with linear amplitudes: $$|\\psi angle = rac{1}{Z}\\sum_{x=0}^{2^n-1}{x|x angle}$$ Where $Z$ is a normalization constant.",
    "docstring": "Initializes a quantum variable in a state with linear amplitudes:\n$$|\\psi\rangle = \frac{1}{Z}\\sum_{x=0}^{2^n-1}{x|x\rangle}$$\nWhere $Z$ is a normalization constant.\n\nBased on the paper https://quantum-journal.org/papers/q-2024-03-21-1297/pdf/\n\nArgs:\n    x: The quantum register to prepare."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.inplace_prepare_sparse_amplitudes",
    "summary": "Prepares a quantum state with the given (complex) amplitudes. The input is given sparse format, as a list of non-zero states and their corresponding amplitudes.",
    "docstring": "Prepares a quantum state with the given (complex) amplitudes. The input is given sparse format, as a list of non-zero states and their corresponding amplitudes.\nNotice that the function is only suitable sparse states. Inspired by https://arxiv.org/abs/2310.19309.\n\nFor example, `inplace_prepare_sparse_amplitudes([1, 8], [np.sqrt(0.5), np.sqrt(0.5)], target)` will prepare the state sqrt(0.5)|1> + sqrt(0.5)|8>\non the target variable, assuming it starts in the |0> state.\n\nComplexity: Asymptotic gate complexity is $O(dn)$ where d is the number of states and n is the target number of qubits.\n\nArgs:\n    states: A list of distinct computational basis indices to populate. Each integer corresponds to the basis state in the computational basis.\n    amplitudes: A list of complex amplitudes for the corresponding entries in `states`. Must have the same length as `states`.\n    target: The quantum variable on which the state is to be prepared. Its size must be sufficient to represent all states in `states`."
  },
  {
    "name": "/classiq/open_library.functions.state_preparation.prepare_sparse_amplitudes",
    "summary": "Initializes and prepares a quantum state with the given (complex) amplitudes. The input is given sparse format, as a list of non-zero states and their corresponding amplitudes.",
    "docstring": "Initializes and prepares a quantum state with the given (complex) amplitudes. The input is given sparse format, as a list of non-zero states and their corresponding amplitudes.\nNotice that the function is only suitable sparse states. Inspired by https://arxiv.org/abs/2310.19309.\n\nFor example, `prepare_sparse_amplitudes([1, 8], [np.sqrt(0.5), np.sqrt(0.5)], out)` will and allocate it to be of size 4 qubits, and\nprepare it in the state sqrt(0.5)|1> + sqrt(0.5)|8>.\n\nComplexity: Asymptotic gate complexity is $O(dn)$ where d is the number of states and n is the required number of qubits.\n\nArgs:\n    states: A list of distinct computational basis indices to populate. Each integer corresponds to the basis state in the computational basis.\n    amplitudes: A list of complex amplitudes for the corresponding entries in `states`. Must have the same length as `states`.\n    out: The allocated quantum variable."
  },
  {
    "name": "/classiq/open_library.functions.swap_test.swap_test",
    "summary": "Tests the overlap (in terms of fidelity) of two quantum states. The fidelity of `state1` and `state2` is calculated from the probability of measuring `test` qubit in the state 0 as follows:.",
    "docstring": "Tests the overlap (in terms of fidelity) of two quantum states.\nThe fidelity of `state1` and `state2` is calculated from the probability of measuring `test` qubit in the state 0 as follows:\n\n$$\n    |\\langle state1 | state2 \\rangle |^2 = 2*Prob(test=0)-1\n$$\n\nArgs:\n    state1: A quantum state to check its overlap with state2.\n    state2: A quantum state to check its overlap with state1.\n    test: A qubit for which the probability of measuring 0 is $0.5*(|\\langle state1 | state2 \\rangle |^2+1)$"
  },
  {
    "name": "/classiq/open_library.functions.utility_functions.apply_to_all",
    "summary": "Applies the single-qubit operand `gate_operand` to each qubit in the qubit array `target`.",
    "docstring": "Applies the single-qubit operand `gate_operand` to each qubit in the qubit\narray `target`.\n\nArgs:\n    gate_operand: The single-qubit gate to apply to each qubit in the array.\n    target: The qubit array to apply the gate to."
  },
  {
    "name": "/classiq/open_library.functions.utility_functions.hadamard_transform",
    "summary": "Applies Hadamard transform to the target qubits.",
    "docstring": "Applies Hadamard transform to the target qubits.\n\nCorresponds to the braket notation:\n\n$$\n H^{\\otimes n} |x\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{y=0}^{2^n - 1} (-1)^{x \\\\cdot y} |y\\rangle\n$$\n\nArgs:\n    target:  qubits to apply to Hadamard transform to."
  },
  {
    "name": "/classiq/open_library.functions.utility_functions.modular_increment",
    "summary": "Adds $a$ to $x$ modulo the range of $x$, assumed that $x$ is a non-negative integer and $a$ is an integer. Mathematically it is described as:.",
    "docstring": "Adds $a$ to $x$ modulo the range of $x$, assumed that $x$ is a non-negative integer and $a$ is an integer.\nMathematically it is described as:\n\n$$\n    x = (x+a)\\ \\mod \\ 2^{x.size}-1\n$$\n\nArgs:\n    a: A classical integer to be added to x.\n    x: A quantum number that is assumed to be non-negative integer."
  },
  {
    "name": "/classiq/open_library.functions.variational.encode_in_angle",
    "summary": "Creates an angle encoding of n data points on n qubits.",
    "docstring": "Creates an angle encoding of n data points on n qubits.\n\nApplies RY($\\pi$data[i]) on qba[i].\n\nArgs:\n    data: A classical array representing the data to encode.\n    qba: The array of qubits on which the data is encoded."
  },
  {
    "name": "/classiq/open_library.functions.variational.encode_on_bloch",
    "summary": "Creates a dense angle encoding of n data points on n//2 qubits.",
    "docstring": "Creates a dense angle encoding of n data points on n//2 qubits.\n\nEncodes pairs of data points on a Bloch sphere, via RX($\\pi$data[2*i])RZ($\\pi$data[2*i+1]) on qba[i].\nIf the length of the data is odd then RX($\\pi$data[i]) is applied on the last qubit.\n\nArgs:\n    data: A classical array representing the data to encode.\n    qba: The QArray of QBits on which the data is encoded."
  },
  {
    "name": "/classiq/qmod.builtins.functions.exponentiation.suzuki_trotter",
    "summary": "Applies the Suzuki-Trotter decomposition to a Pauli operator.",
    "docstring": "Applies the Suzuki-Trotter decomposition to a Pauli operator.\n\nThe Suzuki-Trotter decomposition is a method for approximating the exponential of a sum of operators by a product of exponentials of each operator.\nThe Suzuki-Trotter decomposition of a given order nullifies the error of the Taylor series expansion of the product of exponentials up to that order.\nThe error of a Suzuki-Trotter decomposition decreases as the order and number of repetitions increase.\n\nArgs:\n    pauli_operator: The Pauli operator to be exponentiated.\n    evolution_coefficient: A global evolution coefficient multiplying the Pauli operator.\n    order: The order of the Suzuki-Trotter decomposition.\n    repetitions: The number of repetitions of the Suzuki-Trotter decomposition.\n    qbv: The target quantum variable of the exponentiation."
  }
]